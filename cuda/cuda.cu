#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <assert.h>

#include <cuda.h>

#ifdef _OPENMP
#include <omp.h>
#endif

#include "cudalib.h"
#include "cuda-fmt.h"
#include "cuda-fmt-m.h"
#include "cuda-integ.h"
#include "cuda-twoint-direct.h"
#include "cuda-ifc4c-calc.h"
#include "check.h"

#ifdef __cplusplus
extern "C" {
#endif
//#include "integ/ofmo-twoint-direct.h"
#include "integ/ofmo-index.h"
extern FILE* fp_prof; // from common/ofmo-prof.h
#ifdef __cplusplus
}
#endif

static int CUDA_OPTSYNC = FALSE;
//static int CUDA_OPTSYNC = TRUE;

static int SCF_Malloced = FALSE;

static int CUDA_NDEV = 0;
static struct dev_Data *devData = NULL;

static int nL[] = {1, 3, 6, 10};

static int CUDA_ME = 0;
static int CUDA_NP = 1;

static int CUDA_NBLOCKS  = 0;
static int CUDA_NTHREADS = 0;

/* ------------------------------------- */

__device__ __constant__ int ncs;
__device__ __constant__ int nat;
__device__ __constant__ int maxlqn;
__device__ __constant__ int ncspair;
__device__ __constant__ int npspair;
__device__ __constant__ int nao;
__device__ __constant__ int max_num_klcs;
__device__ __constant__ int num_Gkl;
__device__ __constant__ int num_Gi;
// DFT
__device__ __constant__ double x_coef;

//__device__ __constant__ int *p_ijcounter;
__device__ int *ijcounter;

__device__ __constant__ int *shel_atm;
__device__ __constant__ int *shel_ini;
__device__ __constant__ double *atom_x;
__device__ __constant__ double *atom_y;
__device__ __constant__ double *atom_z;
__device__ __constant__ int *leading_cs;
__device__ __constant__ int *leading_cs_pair;
__device__ __constant__ int *csp_leading_ps_pair;
__device__ __constant__ int *csp_ics;
__device__ __constant__ int *csp_jcs;
__device__ __constant__ int *sklcs_b;
__device__ __constant__ double *psp_zeta;
__device__ __constant__ double *psp_dkps;
__device__ __constant__ double *psp_xiza;
__device__ __constant__ double *DFACT;
__device__ __constant__ float *csp_schwarz;
__device__ __constant__ float *Dcs;
__device__ __constant__ int *sorted_csp;
__device__ __constant__ double *Ds;
__device__ __constant__ double *G_d;
__device__ __constant__ double *G_b;
__device__ __constant__ double *Gkl_b;
__device__ __constant__ double *Gi_t;
//__device__ __constant__ double *Gj_t;
__device__ __constant__ double *work_b;

/* ------------------------------------- */
__host__ static void cuda_init_dev_Data(struct dev_Data *dev)
{
  dev->ijcounter = NULL;
  for (int i=0; i<10; i++) dev->fmt_table[i] = NULL;
  for (int i=0; i<9; i++) dev->fmt_m_table[i] = NULL;
  dev->shel_atm = NULL;
  dev->shel_ini = NULL;
  dev->atom_x = NULL;
  dev->atom_y = NULL;
  dev->atom_z = NULL;
  dev->leading_cs = NULL;
  dev->leading_cs_pair = NULL;
  dev->csp_leading_ps_pair = NULL;
  dev->csp_ics = NULL;
  dev->csp_jcs = NULL;
  dev->sklcs_b = NULL;
  dev->psp_zeta = NULL;
  dev->psp_dkps = NULL;
  dev->psp_xiza = NULL;
  dev->DFACT = NULL;
  dev->csp_schwarz = NULL;
  dev->Dcs = NULL;
  dev->sorted_csp = NULL;
  dev->Ds = NULL;
  dev->G_d = NULL;
  dev->G_b = NULL;
  dev->Gkl_b = NULL;
  dev->Gi_t = NULL;
  dev->work_b = NULL;
// for ifc4c
  dev->shel_atm_frg = NULL;
  dev->shel_ini_frg = NULL;
  dev->atom_x_frg = NULL;
  dev->atom_y_frg = NULL;
  dev->atom_z_frg = NULL;
  dev->leading_cs_frg = NULL;
  dev->leading_cs_pair_frg = NULL;
  dev->csp_leading_ps_pair_frg = NULL;
  dev->csp_ics_frg = NULL;
  dev->csp_jcs_frg = NULL;
  dev->psp_zeta_frg = NULL;
  dev->psp_dkps_frg = NULL;
  dev->psp_xiza_frg = NULL;
  dev->csp_schwarz_frg = NULL;
  dev->shel_atm_mon = NULL;
  dev->shel_ini_mon = NULL;
  dev->atom_x_mon = NULL;
  dev->atom_y_mon = NULL;
  dev->atom_z_mon = NULL;
  dev->leading_cs_mon = NULL;
  dev->leading_cs_pair_mon = NULL;
  dev->csp_leading_ps_pair_mon = NULL;
  dev->csp_ics_mon = NULL;
  dev->csp_jcs_mon = NULL;
  dev->psp_zeta_mon = NULL;
  dev->psp_dkps_mon = NULL;
  dev->psp_xiza_mon = NULL;
  dev->csp_schwarz_mon = NULL;
  dev->D_mon = NULL;
  dev->V_frg = NULL;
  dev->V_frgP = NULL;
}



/* ------------------------------------- */
__host__ struct dev_Data *cuda_SCF_get_dev_Data(const int ndev)
{
  int NDEV = cuda_get_numDevice();
  if (ndev<0 || ndev>=NDEV) return NULL;
  return devData+ndev;
}

__host__ int cuda_set_Device(int idev)
{
  int NDEV = cuda_get_numDevice();
  if (NDEV > 1) {
    cudaError_t err;
    err = cudaSetDevice(idev);
    if (err != cudaSuccess) return -1;
  }
  return 0;
}

__host__ int cuda_get_numDevice(void)
{
#if 0
  int ndev = 0;
#ifdef _OPENMP
#pragma omp master
  {
    ndev = CUDA_NDEV;
  }
#else
    ndev = CUDA_NDEV;
#endif
#else
  int ndev = CUDA_NDEV;
#ifdef _OPENMP
  int master = FALSE;
#pragma omp master
  master = TRUE;
  if (CUDA_NDEV>0 && !master) ndev = -1;
#endif
#endif
  return ndev;
}

__host__ int cuda_use_Device(void)
{
  return (CUDA_NDEV>0);
}

/* ------------------------------------- */

__host__ int cuda_get_numBlocks(void)
{
  return CUDA_NBLOCKS;
}

__host__ int cuda_get_numThreads(void)
{
  return CUDA_NTHREADS;
}

__host__ int cuda_set_BT(const int nblk0, const int nthb0, const int maxlqn)
{
  int i;
  int nblk=0;
  int nthb=0;
  int La, Lb, Lc, Ld;
  int Lab, Lcd, Labcd;

  for ( La=0; La<=maxlqn; La++ ) {
    for ( Lb=0; Lb<=La; Lb++ ) {
      Lab = La*(La+1)/2 + Lb;
      for ( Lc=0; Lc<=La; Lc++ ) {
        for ( Ld=0; Ld<=(Lc==La? Lb : Lc ); Ld++ ) {
          Lcd = Lc*(Lc+1)/2 + Ld;
          Labcd = Lab*(Lab+1)/2 + Lcd;
          //if (nblk0>0) dim2e[Labcd][0] = nblk0;
          if (nblk0>0 && dim2e[Labcd][0]!=0) dim2e[Labcd][0] = nblk0;
          if (nthb0>0) dim2e[Labcd][1] = nthb0;
          nblk = MAX2(nblk, dim2e[Labcd][0]);
          nthb = MAX2(nthb, dim2e[Labcd][1]);
          if (dim2e[Labcd][1]%WARP_SIZE != 0) return -1;
        }
      }
    }
  }
  CUDA_NBLOCKS = nblk;
  CUDA_NTHREADS = nthb;
  return nblk*nthb;
}

/* ------------------------------------- */

__host__ int cuda_get_Nprocs(void)
{
  return CUDA_NP;
}

__host__ int cuda_get_myRank(void)
{
  return CUDA_ME;
}
/* ------------------------------------- */
__host__ int cuda_find2eType(char *str)
{
  int i;
  int n = cuda_get_num_types();
  if (str==NULL) return -1;
  for (i=0; i<n; i++)
    if (strncasecmp(str, cuda_s2e[i], 4)==0) return i;
  return -1;
}

__host__ int cuda_set_optCPU(char *optstr)
{
  int n = cuda_get_num_types();
  char *str, *str1, *str2;
  char *savptr1, *savptr2;
  char *stype1, *stype2;
  char *idx;
  int type1, type2;
  int i;

  //printf("optCPU = %s\n", optstr);
  for (str1=optstr;; str1=NULL) {
    str = strtok_r(str1, ", ", &savptr1);
    if (str==NULL) break;
    idx = index(str, '-');
    stype1 = strtok_r(str, "-", &savptr2);
    stype2 = strtok_r(NULL, "- ", &savptr2);
    type1 = cuda_find2eType(stype1);
    type2 = cuda_find2eType(stype2);
    //printf("%d %d\n", type1, type2);
    if (type1<0) return -1;
    if (idx == NULL) dim2e[type1][0] = 0;
    else if (stype2 != NULL)
      for (i=type1;i<=type2;i++) dim2e[i][0] = 0;
    else if (stype1 == str)
      for (i=type1;i<=n;i++) dim2e[i][0] = 0;
    else
      for (i=0;i<=type1;i++) dim2e[i][0] = 0;
  }
  //for (i=0;i<n;i++) printf("(%2d) %s %1d\n",i,s2e[i],dim2e[i][0]);
  return 0;
}

__host__ int cuda_get_optCPU(int Labcd)
{
  return (dim2e[Labcd][0]>0);
}

/* ------------------------------------- */
__host__ int cuda_set_optsync(int optsync)
{
  CUDA_OPTSYNC = optsync;
  return CUDA_OPTSYNC;
}

__host__ int cuda_get_optsync(void)
{
  return CUDA_OPTSYNC;
}

/* ------------------------------------- */
__host__ void cuda_Print_DEFS(void)
{
  printf("DEFS: "
#ifdef SORT_CSP
  "SORT_CSP "
#endif
#ifdef SORT_CSP_SCHWARZ
  "SORT_CSP_SCHWARZ "
#endif
#ifdef SORT_CSP_REV
  "SORT_CSP_REV "
#endif
  );
  if (cuda_get_optsync()) printf("SYNC_TWOINT ");
  printf("\n");

  printf("CUDA_DEFS: "
#ifdef GPU_DLB
  "GPU_DLB "
#endif
#ifdef USE_ATOMIC
  "USE_ATOMIC "
#endif
#ifdef USE_INSTANT_SCHWARZ
  "USE_INSTANT_SCHWARZ "
#endif
#ifdef ADD_FULL_NAO
  "ADD_FULL_NAO "
#endif
#ifdef DLB_KL
  "DLB_KL "
#endif
/*
#ifdef DLB_KL_SSSS
  "DLB_KL_SSSS "
#endif
#ifdef DLB_KL_PSSS
  "DLB_KL_PSSS "
#endif
#ifdef DLB_KL_PSPS
  "DLB_KL_PSPS "
#endif
#ifdef DLB_KL_PPSS
  "DLB_KL_PPSS "
#endif
#ifdef DLB_KL_PPPS
  "DLB_KL_PPPS "
#endif
#ifdef DLB_KL_PPPP
  "DLB_KL_PPPP "
#endif
#ifdef DLB_KL_DSSS
  "DLB_KL_DSSS "
#endif
#ifdef DLB_KL_DSPS
  "DLB_KL_DSPS "
#endif
#ifdef DLB_KL_DSPP
  "DLB_KL_DSPP "
#endif
#ifdef DLB_KL_DSDS
  "DLB_KL_DSDS "
#endif
#ifdef DLB_KL_DPSS
  "DLB_KL_DPSS "
#endif
#ifdef DLB_KL_DPPS
  "DLB_KL_DPPS "
#endif
#ifdef DLB_KL_DPPP
  "DLB_KL_DPPP "
#endif
#ifdef DLB_KL_DPDS
  "DLB_KL_DPDS "
#endif
#ifdef DLB_KL_DPDP
  "DLB_KL_DPDP "
#endif
#ifdef DLB_KL_DDSS
  "DLB_KL_DDSS "
#endif
#ifdef DLB_KL_DDPS
  "DLB_KL_DDPS "
#endif
#ifdef DLB_KL_DDPP
  "DLB_KL_DDPP "
#endif
#ifdef DLB_KL_DDDS
  "DLB_KL_DDDS "
#endif
#ifdef DLB_KL_DDDP
  "DLB_KL_DDDP "
#endif
#ifdef DLB_KL_DDDD
  "DLB_KL_DDDD "
#endif
*/
#ifdef SORT_IJ_SCHWARZ
  "SORT_IJ_SCHWARZ "
#endif
#ifdef SORT_KL_SCHWARZ
  "SORT_KL_SCHWARZ "
#endif
  );
#ifdef CUDA_FMT_M
#ifdef CUDA_FMT_M_SM
  printf("CUDA_FMT_M(%d,%d,shared)",CUDA_FMT_M, CUDA_FMT_M_NEXP);
#else
  printf("CUDA_FMT_M(%d,%d)",CUDA_FMT_M, CUDA_FMT_M_NEXP);
#endif
#endif
  printf("\n");
}

/* ------------------------------------- */

//__host__ int cuda_Init(const int ndev, const int myrank, const int nprocs)
__host__ int cuda_Init_Sub(const int ndev, const int myrank, const int nprocs)
{
  int NDEV = 0;
#ifdef _OPENMP
  int master = FALSE;
#pragma omp master
  {
    master = TRUE;
  }
  if (!master) return 0;
#endif
  CUDA_ME = myrank;
  CUDA_NP = nprocs;

  if (ndev < 0) return 1;
  if (ndev == 0) {
    CUDA_NDEV = 0;
    return 0;
  };
  cudaGetDeviceCount(&NDEV);
  if (NDEV>1) NDEV = 1; // Force single dev.
  //if (ndev > NDEV) return -1;
  if (ndev > NDEV) {
    char hn[16];
    gethostname(hn, 16);
    printf("%s: ndev %d > NDEV %d\n",hn, myrank, ndev, NDEV);
  }
  assert(ndev <= NDEV);

  devData=(struct dev_Data *)malloc(ndev*sizeof(struct dev_Data));
  if (devData==NULL) return -1;
  for (int i=0; i<ndev; i++) {
    struct dev_Data *dev=devData+i;
    cuda_init_dev_Data(dev);
  }

  int i;
  cudaError_t err;
  struct cudaDeviceProp prop;
  struct dev_Data *dev;
  if (ndev==1) {
//    i=myrank/4;
//    cudaSetDevice(i);
    cudaDeviceReset();
    cudaDeviceSetCacheConfig(cudaFuncCachePreferL1);
    cudaGetDevice(&i);
    err=cudaGetDeviceProperties(&prop, i);
    if (err!=cudaSuccess) return -2;
    dev = devData;
    dev->numSM = prop.multiProcessorCount;
  } else {
  for (i=0; i<ndev; i++) {
    cuda_set_Device(i);
    cudaDeviceReset();
    cudaDeviceSetCacheConfig(cudaFuncCachePreferL1);
    err=cudaGetDeviceProperties(&prop, i);
    if (err!=cudaSuccess) return -2;
    dev = devData + i;
    dev->numSM = prop.multiProcessorCount;
  }
  }
  for (i=0; i<21; i++) {
    dim2e[i][0] *= dev->numSM;
    dim2e[i][1] *= WARP_SIZE;
  }
  {
    int nblk=-1, nthd=-1;
    char *p;
    if ((p=getenv("OFMO_CUDA_IFC4C_BLK"))!=NULL) nblk = atoi(p);
    if ((p=getenv("OFMO_CUDA_IFC4C_THD"))!=NULL) nthd = atoi(p);
    for (i=0; i<12*3; i++) {
      if (dim_ifc4c[i][0]!=0) {
        if (nblk>=0) dim_ifc4c[i][0] = nblk;
        if (nthd>0) dim_ifc4c[i][1] = nthd;
        dim_ifc4c[i][0] *= dev->numSM;
        dim_ifc4c[i][1] *= WARP_SIZE;
      }
    }
  }
  cudaGetDevice(&i);
  if(fp_prof) fprintf(fp_prof, "(%2d) cuda_Init(): %d %d\n",myrank,NDEV,i);
  if(fp_prof) fprintf(fp_prof, "(%2d) cuda_Init(): %d %d [%s (%d)] %d\n",
        myrank, NDEV, i, prop.name , CUDA_ARCH, dev->numSM);
  CUDA_NDEV = ndev;

  return 0;
}

__host__ int cuda_Finalize_Sub(void)
{
  int i;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  //if (CUDA_ME==0) cuda_print_wifc4c();
  cuda_SCF_Free();
  cuda_FMT_Finalize();
#ifdef CUDA_FMT_M
  cuda_FMT_m_Finalize();
#endif
  free(devData);
  devData = NULL;
  for (i=0; i<NDEV; i++) {
    cuda_set_Device(i);
    //cudaDeviceReset();
  }
  CUDA_NDEV = 0;

  return 0;
}

#define McudaDevMalloc(name, num, kind) \
  { ret--;\
    if (dev->name!=NULL) {ret-=1000;break;}; \
    if ((err=cudaMalloc((void **)&(dev->name), (num)*sizeof(kind)))!=cudaSuccess) {break;}}

/* ------------------------------------- */
__host__ int cuda_SCF_Malloc(const int ncs, const int nat, const int maxlqn,
    const int ncspair, const int npspair, const int nao,
    const int max_num_klcs, const int num_Gkl, const int num_Gi)
{
  char fn[]="cuda_SCF_Malloc";
  cudaError_t err;
  int i, ret;
  int NDEV = cuda_get_numDevice();
  int maxlqn2 = (maxlqn+1)*(maxlqn+2)/2;
  int nblk = cuda_get_numBlocks();
  int nthb = cuda_get_numThreads();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (SCF_Malloced) return 1;
  if(fp_prof) fprintf(fp_prof, "(%d) %s()\n", CUDA_ME, fn);
  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    ret = -(i+1)*100;
    McudaDevMalloc(Gi_t, num_Gi*nblk*nthb, double);
    McudaDevMalloc(ijcounter, 21, int);
    McudaDevMalloc(shel_atm, ncs, int);
    McudaDevMalloc(shel_ini, ncs+1, int);
    McudaDevMalloc(atom_x, nat, double);
    McudaDevMalloc(atom_y, nat, double);
    McudaDevMalloc(atom_z, nat, double);
    McudaDevMalloc(leading_cs, maxlqn+2, int);
    McudaDevMalloc(leading_cs_pair, maxlqn2+2, int);
    McudaDevMalloc(csp_leading_ps_pair, ncspair+1, int);
    McudaDevMalloc(csp_ics, ncspair, int);
    McudaDevMalloc(csp_jcs, ncspair, int);
    McudaDevMalloc(sklcs_b, max_num_klcs*nblk, int);
    McudaDevMalloc(psp_zeta, npspair, double);
    McudaDevMalloc(psp_dkps, npspair, double);
    McudaDevMalloc(psp_xiza, npspair, double);
    McudaDevMalloc(DFACT, 36, double);
    McudaDevMalloc(csp_schwarz, ncspair, float);
    McudaDevMalloc(Dcs, ncs*ncs, float);
    McudaDevMalloc(sorted_csp, ncspair, int);
    McudaDevMalloc(Ds, nao*nao, double);
    McudaDevMalloc(G_d, nao*nao, double);
    McudaDevMalloc(G_b, nao*nao*nblk, double);
    McudaDevMalloc(Gkl_b, num_Gkl*nblk, double);
    McudaDevMalloc(work_b, WORK_SIZE*nblk*nthb, double);
    ret = 0;
  }
  if (ret<0 && fp_prof) {
    if (ret<-1000) {
      fprintf(fp_prof, "(%d) %s() %d: may not clean pointer!\n", CUDA_ME, fn, ret);
    } else {
      fprintf(fp_prof, "(%d) %s() %d: %s\n", CUDA_ME, fn, ret, cudaGetErrorString(err));
    }
    fprintf(fp_prof, "(%d) %s(%d,%d,%d,%d,%d,%d,\n"
                     "        %d,%d,%d)\n", CUDA_ME, fn,
                     ncs, nat, maxlqn, ncspair, npspair, nao,
                     max_num_klcs, num_Gkl, num_Gi);
    fflush(fp_prof);
    exit(ret);
  }

  SCF_Malloced = TRUE;
  //if(fp_prof) fprintf(fp_prof, "(%d) cuda_SCF_Malloc() done\n", CUDA_ME);
  //if(fp_prof) fflush(fp_prof); 

  return 0;
}
#undef McudaDevMalloc

#define McudaDevFree(name) \
    { ret--; \
      if ((err=cudaFree(dev->name))!=cudaSuccess) {break;};\
      dev->name = NULL;}

__host__ int cuda_SCF_Free(void)
{
  char fn[]="cuda_SCF_Free";
  cudaError_t err;
  int i,ret;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
//  cuda_FMT_Finalize();
  if (!SCF_Malloced) return 1;
  if(fp_prof) fprintf(fp_prof, "(%d) %s()\n", CUDA_ME, fn);

  for (i=0; i<NDEV; i++) {
    ret = -(i+1)*100;
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    McudaDevFree(Gi_t);
    McudaDevFree(ijcounter);
    McudaDevFree(shel_atm);
    McudaDevFree(shel_ini);
    McudaDevFree(atom_x);
    McudaDevFree(atom_y);
    McudaDevFree(atom_z);
    McudaDevFree(leading_cs);
    McudaDevFree(leading_cs_pair);
    McudaDevFree(csp_leading_ps_pair);
    McudaDevFree(csp_ics);
    McudaDevFree(csp_jcs);
    McudaDevFree(sklcs_b);
    McudaDevFree(psp_zeta);
    McudaDevFree(psp_dkps);
    McudaDevFree(psp_xiza);
    McudaDevFree(DFACT);
    McudaDevFree(csp_schwarz);
    McudaDevFree(Dcs);
    McudaDevFree(sorted_csp);
    McudaDevFree(Ds);
    McudaDevFree(G_d);
    McudaDevFree(G_b);
    McudaDevFree(Gkl_b);
    McudaDevFree(work_b);
    ret = 0;
  }
  if (ret<0 && fp_prof) {
    fprintf(fp_prof, "(%d) %s() %d: %s\n", CUDA_ME, fn, ret, cudaGetErrorString(err));
    fflush(fp_prof);
    exit(ret);
  }
  SCF_Malloced = FALSE;

  return 0;
}
#undef McudaDevFree

/* ------------------------------------- */
#define McudaSetSymbol(a) checkCudaErrors(cudaMemcpyToSymbol(a, &(dev->a), sizeof(dev->a)))
#define McudaMemcpyToSymbol2(a,b,c) checkCudaErrors(cudaMemcpyToSymbol(a, b, c))

__host__ int cuda_SCF_Init_Symbol(
    const int ncs0, const int nat0, const int maxlqn0,
    const int ncspair0, const int npspair0, const int nao0,
    const int max_num_klcs0, const int num_Gkl0, const int num_Gi0,
    const struct dev_Data *dev)
{
    cudaError_t err;

    if (dev==NULL) return -1;
    McudaMemcpyToSymbol2(ncs, &ncs0, sizeof(int));
    McudaMemcpyToSymbol2(nat, &nat0, sizeof(int));
    McudaMemcpyToSymbol2(maxlqn, &maxlqn0, sizeof(int));
    McudaMemcpyToSymbol2(ncspair, &ncspair0, sizeof(int));
    McudaMemcpyToSymbol2(npspair, &npspair0, sizeof(int));
    McudaMemcpyToSymbol2(nao, &nao0, sizeof(int));
    McudaMemcpyToSymbol2(max_num_klcs, &max_num_klcs0, sizeof(int));
    McudaMemcpyToSymbol2(num_Gkl, &num_Gkl0, sizeof(int));
    McudaMemcpyToSymbol2(num_Gi, &num_Gi0, sizeof(int));
//    McudaSetSymbol(p_ijcounter);
    McudaSetSymbol(ijcounter);
    McudaSetSymbol(shel_atm);
    McudaSetSymbol(shel_ini);
    McudaSetSymbol(atom_x);
    McudaSetSymbol(atom_y);
    McudaSetSymbol(atom_z);
    McudaSetSymbol(leading_cs);
    McudaSetSymbol(leading_cs_pair);
    McudaSetSymbol(csp_leading_ps_pair);
    McudaSetSymbol(csp_ics);
    McudaSetSymbol(csp_jcs);
    McudaSetSymbol(sklcs_b);
    McudaSetSymbol(psp_zeta);
    McudaSetSymbol(psp_dkps);
    McudaSetSymbol(psp_xiza);
    McudaSetSymbol(DFACT);
    McudaSetSymbol(csp_schwarz);
    McudaSetSymbol(Dcs);
    McudaSetSymbol(sorted_csp);
    McudaSetSymbol(Ds);
    McudaSetSymbol(G_d);
    McudaSetSymbol(G_b);
    McudaSetSymbol(Gkl_b);
    McudaSetSymbol(Gi_t);
    McudaSetSymbol(work_b);

    return 0;
}
#undef McudaSetSymbol
#undef McudaSetSymbol2

__host__ int cuda_SCF_Finalize(void)
{
  int i;
  int NDEV = cuda_get_numDevice();
  int ret;

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  ret=cuda_SCF_Free();
  if(fp_prof&&ret!=0) fprintf(fp_prof, "(%d) ERROR(%d) in cuda_SCF_Free()\n", CUDA_ME, ret);

  return ret;
}
   
__host__ int cuda_SCF_Init(const int ncs, const int nat, const int maxlqn,
    const int ncspair, const int npspair, const int nao,
    const int *shel_atm, const int *shel_ini,
    const double *atom_x, const double *atom_y, const double *atom_z,
    const int *leading_cs,
    const int *leading_cs_pair, const int *csp_leading_ps_pair,
    const int *csp_ics, const int *csp_jcs,
    const double *psp_zeta, const double *psp_dkps, const double *psp_xiza,
    const float *csp_schwarz,
    const int nblk, const int nthb
    )
{
  cudaError_t err;
  int *sorted_csp;
  double *DFACT=ofmo_getadd_dfact();
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;

  int maxlqn2 = (maxlqn+1)*(maxlqn+2)/2;
  int max_num_klcs = cuda_max_num_klcs(maxlqn, leading_cs_pair);
//  int num_Gkl = ncspair*nL[maxlqn]*nL[maxlqn];
  int num_Gkl = cuda_num_Gkl(maxlqn, leading_cs_pair);
  num_Gkl = ((num_Gkl-1)/16+1)*16+32; // 16words = 128bytes align;
  int num_Gi = nao * nL[maxlqn] * 2;
//  int num_Gi = cuda_num_Gi(maxlqn, leading_cs_pair, shel_ini);
  num_Gi = ((num_Gi-1)/16+1)*16+32; // 16words = 128bytes align;

  ret = cuda_set_BT(nblk, nthb, maxlqn);
  if (ret<0) return ret;

    checkCudaErrors(cudaDeviceSynchronize());
  if(fp_prof) fprintf(fp_prof, "(%d) cuda_SCF_Init()\n", CUDA_ME);
  if (!SCF_Malloced) {
    ret = cuda_SCF_Malloc(ncs, nat, maxlqn, ncspair, npspair, nao,
        max_num_klcs, num_Gkl, num_Gi);
    if (ret<0) return ret;
  }
#ifdef SORT_INDEX_SCHWARZ
  if ((sorted_csp=(int *)malloc(ncspair*sizeof(int)))==NULL) return -1;
  ret = cuda_sort_csp_schwarz(sorted_csp, ncspair, maxlqn, leading_cs_pair, csp_schwarz);
  if (ret<0) return ret;
#endif
  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    ret = cuda_SCF_Init_Symbol(ncs, nat, maxlqn, ncspair, npspair, nao,
       max_num_klcs, num_Gkl, num_Gi, dev);
    if (ret<0) return ret;
    McudaMemcpyH2D(dev->shel_atm, shel_atm, ncs*sizeof(int));
    McudaMemcpyH2D(dev->shel_ini, shel_ini, ncs*sizeof(int));
    McudaMemcpyH2D(dev->shel_ini+ncs, &nao, sizeof(int));
    McudaMemcpyH2D(dev->atom_x, atom_x, nat*sizeof(double));
    McudaMemcpyH2D(dev->atom_y, atom_y, nat*sizeof(double));
    McudaMemcpyH2D(dev->atom_z, atom_z, nat*sizeof(double));
    McudaMemcpyH2D(dev->leading_cs, leading_cs, (maxlqn+2)*sizeof(int));
    McudaMemcpyH2D(dev->leading_cs_pair, leading_cs_pair, (maxlqn2+2)*sizeof(int));
    McudaMemcpyH2D(dev->csp_leading_ps_pair, csp_leading_ps_pair, (ncspair+1)*sizeof(int));
    McudaMemcpyH2D(dev->csp_ics, csp_ics, ncspair*sizeof(int));
    McudaMemcpyH2D(dev->csp_jcs, csp_jcs, ncspair*sizeof(int));
    McudaMemcpyH2D(dev->psp_zeta, psp_zeta, npspair*sizeof(double));
    McudaMemcpyH2D(dev->psp_dkps, psp_dkps, npspair*sizeof(double));
    McudaMemcpyH2D(dev->psp_xiza, psp_xiza, npspair*sizeof(double));
    McudaMemcpyH2D(dev->DFACT, DFACT, 36*sizeof(double));
    McudaMemcpyH2D(dev->csp_schwarz, csp_schwarz, ncspair*sizeof(float));
#ifdef SORT_INDEX_SCHWARZ
    McudaMemcpyH2D(dev->sorted_csp, sorted_csp, ncspair*sizeof(int));
#endif
  }
  cuda_set_Device(0);
#ifdef SORT_INDEX_SCHWARZ
  free(sorted_csp);
#endif

//  printf("SCF_Ini:(%d/%d) %d\n",CUDA_ME,CUDA_NP,NDEV);
    checkCudaErrors(cudaDeviceSynchronize());
  //if(fp_prof) fprintf(fp_prof, "(%d) cuda_SCF_Init() done\n", CUDA_ME);
  //if (fp_prof) fflush(fp_prof);

  return 0;
}

/* ------------------------------------- */

__host__ int cuda_max_num_klcs(const int maxlqn, const int *leading_cs_pair)
{
  int La, Lb, Lab;
  int mincs, maxcs, nkl = 0;
  for ( La=0; La<=maxlqn; La++ ) {
    for ( Lb=0; Lb<=La; Lb++ ) {
      Lab = La*(La+1)/2 + Lb;
      mincs = leading_cs_pair[Lab];
      maxcs = leading_cs_pair[Lab+1];
      nkl = MAX2(nkl, maxcs-mincs);
    }
  }
  return nkl;
}

__host__ int cuda_num_Gkl(const int maxlqn, const int *leading_cs_pair)
{
  int La, Lb, Lab;
  int Lc, Ld, Lcd;
  int mincs, maxcs, nkl = 0;
  for ( La=0; La<=maxlqn; La++ ) {
    for ( Lb=0; Lb<=La; Lb++ ) {
      Lab = La*(La+1)/2 + Lb;
      for ( Lc=0; Lc<=La; Lc++ ) {
        for ( Ld=0; Ld<=(Lc==La? Lb : Lc ); Ld++ ) {
          Lcd = Lc*(Lc+1)/2 + Ld;
      mincs = leading_cs_pair[Lab];
      maxcs = leading_cs_pair[Lab+1];
      int nkl_t = (maxcs-mincs)*nL[Lc]*nL[Ld];
      nkl = MAX2(nkl, nkl_t);
      mincs = leading_cs_pair[Lcd];
      maxcs = leading_cs_pair[Lcd+1];
      nkl_t = (maxcs-mincs)*nL[La]*nL[Lb];
      nkl = MAX2(nkl, nkl_t);
        }
      }
    }
  }
  return nkl;
}

__host__ int cuda_num_Gi(const int maxlqn, const int *leading_cs_pair,
    const int *shel_ini)
{
  int La, Lb, Lab;
  int mincs, maxcs, ni = 0;
  int num_Gi, maxao;

  La = maxlqn;
  maxcs = leading_cs_pair[La+1];
  maxao = shel_ini[maxcs];
  num_Gi = maxao * nL[maxlqn] * 2;
  num_Gi = ((num_Gi-1)/16+1)*16; // 16words = 128bytes align;
  /*
  for ( La=0; La<=maxlqn; La++ ) {
    for ( Lb=0; Lb<=La; Lb++ ) {
    }
  }
  */
  return num_Gi;
}

/* ------------------------------------- */

const float *fschwarz; 

__host__ static int cuda_sort_csp_schwarz_cmp(const void *a, const void *b)
{
  int ret = 0;
  float f = fschwarz[*(int *)a] - fschwarz[*(int *)b];
  if (f>0) ret = 1;
  else if (f<0) ret = -1;
  return ret;
}

__host__ int cuda_sort_csp_schwarz(int *sorted_csp, const int ncspair,
    const int maxlqn, const int *leading_cs_pair, const float *csp_schwarz)
{
  int i;
  int La, Lb, Lab;
  int mincs, maxcs, ncs;
  int *csp;

  for (i=0;i<ncspair;i++) sorted_csp[i]=i;
  fschwarz = csp_schwarz;

  for ( La=0; La<=maxlqn; La++ ) {
    for ( Lb=0; Lb<=La; Lb++ ) {
      Lab = La*(La+1)/2 + Lb;
      mincs = leading_cs_pair[Lab];
      maxcs = leading_cs_pair[Lab+1];
      ncs = maxcs - mincs;
      qsort(&sorted_csp[mincs],ncs,sizeof(int),cuda_sort_csp_schwarz_cmp);
    }
  }
//  for (i=0;i<ncspair;i++) 
//    printf("%4d %4d %f\n",i, sorted_csp[i], csp_schwarz[sorted_csp[i]]);

  return 0;
}

/* ------------------------------------- */
#ifndef ZERO
#define ZERO 0.0e0
#endif

__global__ void gpu_Gmat_clr(void)
{
  int i;

  double *G   = G_b   + blockIdx.x * nao * nao;
  double *Gkl = Gkl_b + blockIdx.x * num_Gkl;

  __threadfence();
  for (i=threadIdx.x; i<nao*nao; i+=blockDim.x) G[i]=ZERO;
  for (i=threadIdx.x; i<num_Gkl; i+=blockDim.x) Gkl[i]=ZERO;
//  for (i=threadIdx.x+blockIdx.x*blockDim.x; i<nao*nao; i+=blockDim.x*gridDim.x) G_d[i]=ZERO;
  __syncthreads();
  __threadfence();
}

__global__ void gpu_Gmat_add(void)
{
  int i,j;
  __syncthreads();
  __threadfence();
  for (i=threadIdx.x+blockIdx.x*blockDim.x; i<nao*nao; i+=blockDim.x*gridDim.x){
    double *G = G_b + i;
    double Gtmp=ZERO;
    for (j=0; j<gridDim.x; j++,G+=nao*nao) {
      Gtmp += *G;
    }
    G_d[i] = Gtmp;
  }
  __syncthreads();
  __threadfence();
}

__host__ int cuda_genGmat_Init(const int ncs, const int nao,
    const float *Dcs, const double *D, const double x_coef0)
{
  cudaError_t err;
  int i;
  int NDEV = cuda_get_numDevice();
  int nblk = cuda_get_numBlocks();
  int nthb = cuda_get_numThreads();
  int c0[21];
  extern int counter_ini_type[];

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!SCF_Malloced) return -2;
  for (i=0; i<21; i++) {
    c0[i] = 0;
    if      (counter_ini_type[i] == 1) c0[i] = dim2e[i][0];
    else if (counter_ini_type[i] == 2) c0[i] = dim2e[i][0]*NIJCSW;
  }

  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    McudaMemcpyH2D(dev->Dcs, Dcs, ncs*ncs*sizeof(float));
    McudaMemcpyH2D(dev->Ds, D, nao*nao*sizeof(double));
#ifdef GPU_DLB
    McudaMemcpyH2D(dev->ijcounter, c0, 21*sizeof(int));
#endif
#define McudaMemcpyToSymbol2(a,b,c) checkCudaErrors(cudaMemcpyToSymbol(a, b, c))
    McudaMemcpyToSymbol2(x_coef, &x_coef0, sizeof(double));
#undef McudaMemcpyToSymbol2

    gpu_Gmat_clr <<< nblk, nthb >>> ();
    //cudaDeviceSynchronize();
    checkCudaErrors(cudaDeviceSynchronize());
  }
  cuda_set_Device(0);
//  printf("Ini:(%d/%d) %16.10g %16.10g\n",CUDA_ME,CUDA_NP,Dcs[0],D[0]);

  return 0;
}

__host__ int cuda_genGmat_Add(const int nao, double *G)
{
  cudaError_t err;
  int i,j;
  double *Gtmp;
  int NDEV = cuda_get_numDevice();
  int nblk = cuda_get_numBlocks();
  int nthb = cuda_get_numThreads();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!SCF_Malloced) return -2;

  Gtmp = (double *)malloc(nao*nao*sizeof(double));
  if (Gtmp==NULL) return -3;

  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    //cudaDeviceSynchronize();
    checkCudaErrors(cudaDeviceSynchronize());

    gpu_Gmat_add <<< nblk, nthb >>> ();

    cudaDeviceSynchronize();
    McudaMemcpyD2H(Gtmp, dev->G_d, nao*nao*sizeof(double));
//  printf("Add:(%d/%d) %16.10g\n",CUDA_ME,CUDA_NP,Gtmp[0]);
    for (j=0; j<nao*nao; j++) G[j] += Gtmp[j];
  }
  cuda_set_Device(0);
  free(Gtmp);

  return 0;
}

/* ------------------------------------- */
/**
 * @file fmt.c
 * 各種分子積分計算で用いる誤差関数の計算に関する関数群
 *
 * */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>

#include <cuda.h>
#include "cudalib.h"
#include "cuda-fmt.h"

#ifdef __cplusplus
extern "C" {
#endif
extern FILE* fp_prof; // from common/ofmo-prof.h
#ifdef __cplusplus
}
#endif

static int FMT_Initialized = -1;

/* ------------------------------------- */

__device__ __constant__ double *FMT_fmt_table;
__device__ __constant__ double FMT_fmt_step_size;
__device__ __constant__ double FMT_fmt_inv_step_size;
__device__ __constant__ double FMT_pi_div2;
__device__ __constant__ int FMT_fmt_max_m1;

__device__ __constant__ double *FMT_fmt_table0;
__device__ __constant__ double *FMT_fmt_table1;
__device__ __constant__ double *FMT_fmt_table2;
__device__ __constant__ double *FMT_fmt_table3;
__device__ __constant__ double *FMT_fmt_table4;
__device__ __constant__ double *FMT_fmt_table5;
__device__ __constant__ double *FMT_fmt_table6;
__device__ __constant__ double *FMT_fmt_table7;
__device__ __constant__ double *FMT_fmt_table8;

/* ------------------------------------- */
__host__ int cuda_FMT_Init(double **dtmp, size_t *mtmp,
    const double step_size, const int max_m1)
{
  cudaError_t err;
  int i;
  double inv_step_size = 1.0/step_size;
  double pi_div2 = 2.0 * atan(1.0);
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (FMT_Initialized>=max_m1) return 1;
  if(fp_prof) fprintf(fp_prof, "cuda_FMT_Init(): %d\n",max_m1);
  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev;
    cuda_set_Device(i);
    dev = cuda_SCF_get_dev_Data(i);
    if (FMT_Initialized<0) { // 1st time
      for (int m=0; m<=9; m++) {
        err = cudaMalloc((void **)&(dev->fmt_table[m]), mtmp[m]*sizeof(double));
        checkCudaErrors(err);
        if (err!=cudaSuccess) exit(1);
      }
      err = cudaMemcpyToSymbol(FMT_fmt_table0, &(dev->fmt_table[0]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table1, &(dev->fmt_table[1]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table2, &(dev->fmt_table[2]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table3, &(dev->fmt_table[3]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table4, &(dev->fmt_table[4]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table5, &(dev->fmt_table[5]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table6, &(dev->fmt_table[6]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table7, &(dev->fmt_table[7]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table8, &(dev->fmt_table[8]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table, &(dev->fmt_table[9]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);

      for (int m=0; m<=9; m++) {
        McudaMemcpyH2D(dev->fmt_table[m], dtmp[m], mtmp[m]*sizeof(double));
      }
    } else { // !(FMT_initialize<0)
    if(fp_prof) fprintf(fp_prof, "cuda_FMT_Init(): %d %d\n",FMT_Initialized, max_m1);
      if (dev->fmt_table[9]!=NULL) cudaFree(dev->fmt_table[9]);
      err = cudaMalloc((void **)&(dev->fmt_table[9]), mtmp[9]*sizeof(double));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_fmt_table, &(dev->fmt_table[9]), sizeof(double *));
      checkCudaErrors(err);
      if (err!=cudaSuccess) exit(1);
      McudaMemcpyH2D(dev->fmt_table[9], dtmp[9], mtmp[9]*sizeof(double));
    }
    err = cudaMemcpyToSymbol(FMT_fmt_step_size, &step_size, sizeof(double));
    checkCudaErrors(err);
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_fmt_inv_step_size, &inv_step_size, sizeof(double));
    checkCudaErrors(err);
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_pi_div2, &pi_div2, sizeof(double));
    checkCudaErrors(err);
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_fmt_max_m1, &max_m1, sizeof(int));
    checkCudaErrors(err);
    if (err!=cudaSuccess) exit(1);
  }
  FMT_Initialized = max_m1;

  return 0;
}

__host__ int cuda_FMT_Finalize(void)
{
  cudaError_t err;
  int i;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (FMT_Initialized<0) return 1;
  if(fp_prof) fprintf(fp_prof, "cuda_FMT_Finalize()\n");
  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
    for (int m=0; m<9; m++) { 
      err = cudaFree(dev->fmt_table[m]);
      if (err!=cudaSuccess) exit(1);
    }
  }
  FMT_Initialized = -1;

  return 0;
}

/* ------------------------------------- */

/** 誤差関数を計算する関数
 *
 * \c fmt_initialize 関数で作成された誤差関数テーブルを用いるなどして
 * 誤差関数を計算する
 *
 * @attention
 * @li 事前に初期化ルーチンを \c fmt_initialize を呼び出しておく必要がある
 *
 * @param[out] f[] 計算した誤差関数を代入する配列
 *     （\f$ \tt{f[0]}\sim \tt{f[m]} \f$
 * @param[in] m 誤差関数の次数
 * @param[in] t 誤差関数の引数
 * @param[in] coef 誤差関数に掛ける定数
 *
 * @return なし
 *
 * @ingroup integ-fmt
 * */

__device__ void gpu_fmt(double f[], const int m, const double t, const double coef){
    int i;
    const double FMT_inv2 = 1.0 / 2.0;
//    int i,ts;
//    double d,t_inv,nu;
//    int ts0;

    // main
    if (t <= (2*m+36)) {
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
	ts0 = ts * FMT_fmt_max_m1;
#pragma unroll
	for (i=0; i<=m; i++){
	    f[i] = coef * (((LDG(FMT_fmt_table[ts0 + i + 3]) * FMT_inv6   * d
			   + LDG(FMT_fmt_table[ts0 + i + 2]) * FMT_inv2 ) * d
			   + LDG(FMT_fmt_table[ts0 + i + 1])            ) * d
			   + LDG(FMT_fmt_table[ts0 + i + 0])            );
	}
    } else {
        double t_inv;
        int nu;
	t_inv = FMT_inv2 / t;
	nu = 1;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
#pragma unroll
	for (i=1; i<=m; i++){
	    f[i] = t_inv * f[i-1] * nu;
	    nu += 2;
	}
    }
}

__device__ void gpu_fmt0(double f[], const double t, const double coef){
    int i;
    const int m = 0;
    const double FMT_inv2 = 1.0 / 2.0;
//    int i,ts;
//    double d,t_inv,nu;
//    int ts0;

    // main
    if (t <= 36) {
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
        int pos;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
        pos = ts * 4;
        f[0] = coef * ((( LDG(FMT_fmt_table0[pos + 3])  * d
                        + LDG(FMT_fmt_table0[pos + 2])) * d
                        + LDG(FMT_fmt_table0[pos + 1])) * d
                        + LDG(FMT_fmt_table0[pos + 0]));
    } else {
        double t_inv;
	t_inv = FMT_inv2 / t;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
    }
}

__device__ void gpu_fmt1(double f[], const double t, const double coef){
    int i;
    const int m = 1;
    const double FMT_inv2 = 1.0 / 2.0;
//    int i,ts;
//    double d,t_inv,nu;
//    int ts0;

    // main
    if (t <= (2*m+36)) {
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
        int pos;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
	pos = ts * (1+4);
#pragma unroll
	for (i=0; i<=m; i++){
	    f[i] = coef * (((LDG(FMT_fmt_table1[pos + i + 3]) * FMT_inv6   * d
			   + LDG(FMT_fmt_table1[pos + i + 2]) * FMT_inv2 ) * d
			   + LDG(FMT_fmt_table1[pos + i + 1])            ) * d
			   + LDG(FMT_fmt_table1[pos + i + 0])            );
	}
    } else {
        double t_inv;
	t_inv = FMT_inv2 / t;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
        f[1] = t_inv * f[0];
    }
}

__device__ void gpu_fmt2(double f[], const double t, const double coef){
    int i;
    const int m = 2;
    const double FMT_inv2 = 1.0 / 2.0;
//    int i,ts;
//    double d,t_inv,nu;
//    int ts0;

    // main
    if (t <= (2*m+36)) {
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
        int pos;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
	pos = ts * (2+4);
#pragma unroll
	for (i=0; i<=m; i++){
	    f[i] = coef * (((LDG(FMT_fmt_table2[pos + i + 3]) * FMT_inv6   * d
			   + LDG(FMT_fmt_table2[pos + i + 2]) * FMT_inv2 ) * d
			   + LDG(FMT_fmt_table2[pos + i + 1])            ) * d
			   + LDG(FMT_fmt_table2[pos + i + 0])            );
	}
    } else {
        double t_inv;
        int nu;
	t_inv = FMT_inv2 / t;
	nu = 1;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
#pragma unroll
	for (i=1; i<=m; i++){
	    f[i] = t_inv * f[i-1] * nu;
	    nu += 2;
	}
    }
}

__device__ void gpu_fmt3(double f[], const double t, const double coef){
    int i;
    const int m = 3;
    const double FMT_inv2 = 1.0 / 2.0;
//    int i,ts;
//    double d,t_inv,nu;
//    int ts0;

    // main
    if (t <= (2*m+36)) {
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
        int pos;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
	pos = ts * (3+4);
#pragma unroll
	for (i=0; i<=m; i++){
	    f[i] = coef * (((LDG(FMT_fmt_table3[pos + i + 3]) * FMT_inv6   * d
			   + LDG(FMT_fmt_table3[pos + i + 2]) * FMT_inv2 ) * d
			   + LDG(FMT_fmt_table3[pos + i + 1])            ) * d
			   + LDG(FMT_fmt_table3[pos + i + 0])            );
	}
    } else {
        double t_inv;
        int nu;
	t_inv = FMT_inv2 / t;
	nu = 1;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
#pragma unroll
	for (i=1; i<=m; i++){
	    f[i] = t_inv * f[i-1] * nu;
	    nu += 2;
	}
    }
}

__device__ void gpu_fmt4(double f[], const double t, const double coef){
    int i;
    const int m = 4;
    const double FMT_inv2 = 1.0 / 2.0;
//    int i,ts;
//    double d,t_inv,nu;
//    int ts0;

    // main
    if (t <= (2*m+36)) {
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
        int pos;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
	pos = ts * (4+4);
#pragma unroll
	for (i=0; i<=m; i++){
	    f[i] = coef * (((LDG(FMT_fmt_table4[pos + i + 3]) * FMT_inv6   * d
			   + LDG(FMT_fmt_table4[pos + i + 2]) * FMT_inv2 ) * d
			   + LDG(FMT_fmt_table4[pos + i + 1])            ) * d
			   + LDG(FMT_fmt_table4[pos + i + 0])            );
	}
    } else {
        double t_inv;
        int nu;
	t_inv = FMT_inv2 / t;
	nu = 1;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
#pragma unroll
	for (i=1; i<=m; i++){
	    f[i] = t_inv * f[i-1] * nu;
	    nu += 2;
	}
    }
}

__device__ void gpu_fmt_p0(volatile double f[], const int m, const double t, const double coef,
    const int nidx, const int idx){

    const double FMT_inv2 = 1.0 / 2.0;
        const double FMT_inv6 = 1.0 / 6.0;
        double d;
        int ts,ts0;
	ts = 0.5 + t * FMT_fmt_inv_step_size;
	d = ts * FMT_fmt_step_size - t;
	ts0 = ts * FMT_fmt_max_m1;
#pragma unroll
	for (int i=idx; i<=m; i+=nidx){
	    f[i] = coef * (((LDG(FMT_fmt_table[ts0 + i + 3]) * FMT_inv6   * d
			   + LDG(FMT_fmt_table[ts0 + i + 2]) * FMT_inv2 ) * d
			   + LDG(FMT_fmt_table[ts0 + i + 1])            ) * d
			   + LDG(FMT_fmt_table[ts0 + i + 0])            );
	}
}

__device__ void gpu_fmt_p1(volatile double f[], const int m, const double t, const double coef,
    const int nidx, const int idx){

        const double FMT_inv2 = 1.0 / 2.0;
	double t_inv = FMT_inv2 / t;
	int nu = 1;

	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
#pragma unroll
	for (int i=1; i<=m; i++){
	    f[i] = t_inv * f[i-1] * nu;
	    nu += 2;
	}

/*
        double ft;
	ft = coef * sqrt(FMT_pi_div2*t_inv);
#pragma unroll
	for (int i=1; i<=MIN2(idx,m); i++){
	    ft *= t_inv * nu;
	    nu += 2;
	}
        if (idx<=m) f[idx] = ft;
*/
        
        /*
        double t_inv;
        double t_inv2;
	t_inv = FMT_inv2 / t;
        t_inv2 = t_inv*t_inv;
	f[0] = coef * sqrt(FMT_pi_div2*t_inv);
	f[1] = f[0]*t_inv;
	f[2] = f[1]*t_inv*3;
	for (int i=(3+idx); i<=m; i+=3){
	    f[i] = t_inv2 * f[i-2] * (1+(i-1)*2) * (1+(i-2)*2) * (1+(i-3)*2);
	}
        */
}

__device__ void gpu_fmt_p(double f[], const int m, const double t, const double coef,
    const int nidx, const int idx){

    if (t <= (2*m+36)) {
      volatile double *s = f;
      gpu_fmt_p0(s, m, t, coef, nidx, idx);
    } else {
      volatile double *s = f;
      gpu_fmt_p1(s, m, t, coef, nidx, idx);
    }
}
   
#include "cuda-utils.h"

#if defined(__CUDA_ARCH__) && __CUDA_ARCH__ < 600
// From cuda toolkit documentation 
// https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#atomic-functions
__device__ double atomicAdd(double* address, double val)
{
    unsigned long long int* address_as_ull =
                              (unsigned long long int*)address;
    unsigned long long int old = *address_as_ull, assumed;

    do {
        assumed = old;
        old = atomicCAS(address_as_ull, assumed,
                        __double_as_longlong(val +
                               __longlong_as_double(assumed)));

    // Note: uses integer comparison to avoid hang in case of NaN (since NaN != NaN)
    } while (assumed != old);

    return __longlong_as_double(old);
}
#endif


/* --------------------------------------------------- */
#if defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 350
//#if CUDA_ARCH >= 350

__device__ double warpReduceG(double v, const int tid)
{
  v += __shfl_down_sync(0xffffffff, v, 16, 32);
  v += __shfl_down_sync(0xffffffff, v,  8, 32);
  v += __shfl_down_sync(0xffffffff, v,  4, 32);
  v += __shfl_down_sync(0xffffffff, v,  2, 32);
  v += __shfl_down_sync(0xffffffff, v,  1, 32);
  return v;
}

#endif

__device__ void warpReduce(volatile double *sdata, const int tid)
{
#if defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 350
//#if CUDA_ARCH >= 350
  double v = sdata[tid];
  sdata[tid] = warpReduceG(v, tid);
#else
  if (tid<WARP_SIZE/2) {
//  sdata[tid] += sdata[tid+32];
  sdata[tid] += sdata[tid+16];
  __syncwarp();
  sdata[tid] += sdata[tid+8];
  __syncwarp();
  sdata[tid] += sdata[tid+4];
  __syncwarp();
  sdata[tid] += sdata[tid+2];
  __syncwarp();
  sdata[tid] += sdata[tid+1];
  __syncwarp();
  }
#endif
}

/**
 * fmt-m.c
 *
 * */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>

#include <cuda.h>
#include "cudalib.h"
#include "cuda-fmt-m.h"

#ifdef __cplusplus
extern "C" {
#endif
extern FILE* fp_prof; // from common/ofmo-prof.h
#ifdef __cplusplus
}
#endif

static int FMT_m_Initialized = -1;

/* ------------------------------------- */

__device__ __constant__ double *FMT_m_table[9];
__device__ __constant__ double *FMT_m_table0;
__device__ __constant__ double *FMT_m_table1;
__device__ __constant__ double *FMT_m_table2;
__device__ __constant__ double *FMT_m_table3;
__device__ __constant__ double *FMT_m_table4;
__device__ __constant__ double *FMT_m_table5;
__device__ __constant__ double *FMT_m_table6;
__device__ __constant__ double *FMT_m_table7;
__device__ __constant__ double *FMT_m_table8;
__device__ __constant__ size_t FMT_m_size[9];
__device__ __constant__ double FMT_m_delta[9]; // mmax+1
__device__ __constant__ double FMT_m_dinv[11]; // ??
__device__ __constant__ double FMT_m_dinv2[8+10]; // mmax+nexp

__device__ __constant__ double FMT_m_sqrt_pi_2;
__device__ __constant__ double FMT_m_sqrt_pi2;

/* ------------------------------------- */

static size_t fmt_m_size[9];

__host__ size_t cuda_FMT_m_get_size(const int m)
{
  size_t size = 0;
  int mmax = FMT_m_Initialized;
  if (m>=0 && m<=mmax) size = fmt_m_size[m];
  return size;
}

/* ------------------------------------- */
__host__ int cuda_FMT_m_Init(double **dtmp, const size_t *mtmp,
    const int *ndivs, const int mmax)
{
  cudaError_t err;
  int i;

  if (mmax>8) exit(-1);

  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (FMT_m_Initialized>mmax) return 1;
  if(fp_prof) fprintf(fp_prof, "cuda_FMT_m_Init(): %d\n",mmax);
  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev;
    cuda_set_Device(i);
    dev = cuda_SCF_get_dev_Data(i);
    dev->fmt_m_mmax = mmax;
    for (int m=0; m<=mmax; m++) {
      err = cudaMalloc((void **)&(dev->fmt_m_table[m]), mtmp[m]*sizeof(double));
      if (err!=cudaSuccess) exit(1);
      McudaMemcpyH2D(dev->fmt_m_table[m], dtmp[m], mtmp[m]*sizeof(double));
    }
    err = cudaMemcpyToSymbol(FMT_m_table, dev->fmt_m_table, (mmax+1)*sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table0, &(dev->fmt_m_table[0]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table1, &(dev->fmt_m_table[1]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table2, &(dev->fmt_m_table[2]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table3, &(dev->fmt_m_table[3]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table4, &(dev->fmt_m_table[4]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table5, &(dev->fmt_m_table[5]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table6, &(dev->fmt_m_table[6]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table7, &(dev->fmt_m_table[7]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_table8, &(dev->fmt_m_table[8]), sizeof(double *));
    if (err!=cudaSuccess) exit(1);
    err = cudaMemcpyToSymbol(FMT_m_size, mtmp, (mmax+1)*sizeof(size_t));
    if (err!=cudaSuccess) exit(1);
    {
      double *delta = (double *)malloc((mmax+1)*sizeof(double));
      for (int m=0; m<=mmax; m++) delta[m] = 1e0/(double)ndivs[m];
      err = cudaMemcpyToSymbol(FMT_m_delta, delta, (mmax+1)*sizeof(double));
      if (err!=cudaSuccess) exit(1);
      free(delta);
    }
    {
      int ndinv=11;
      double *dinv = (double *)malloc(ndinv*sizeof(double));
      dinv[0] = dinv[1] = 1.e0;
      for (int k=2; k<ndinv; k++ ) dinv[k] = 1.e0 / (double)k;
      err = cudaMemcpyToSymbol(FMT_m_dinv, dinv, ndinv*sizeof(double));
      if (err!=cudaSuccess) exit(1);
      free(dinv);
    }
    {
      int ndinv2=mmax+10;
      double *dinv2 = (double *)malloc(ndinv2*sizeof(double));
      dinv2[0] = 1.e0;
      for (int k=1; k<ndinv2; k++ ) dinv2[k] = 1.e0/ (double)(2*k+1);
      err = cudaMemcpyToSymbol(FMT_m_dinv2, dinv2, ndinv2*sizeof(double));
      if (err!=cudaSuccess) exit(1);
      free(dinv2);
    }
    {
      double sqrt_pi_2 = sqrt( atan( 1.e0 ) );
      double sqrt_pi2  = sqrt( 2.e0*atan( 1.e0 ) );
      err = cudaMemcpyToSymbol(FMT_m_sqrt_pi_2, &sqrt_pi_2, sizeof(double));
      if (err!=cudaSuccess) exit(1);
      err = cudaMemcpyToSymbol(FMT_m_sqrt_pi2, &sqrt_pi2, sizeof(double));
      if (err!=cudaSuccess) exit(1);
    }
  }
  for (int m=0; m<=mmax; m++) fmt_m_size[m] = mtmp[m];
  FMT_m_Initialized = mmax;

  return 0;
}

__host__ int cuda_FMT_m_Finalize(void)
{
  cudaError_t err;
  int i;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (FMT_m_Initialized<0) return 1;
  if(fp_prof) fprintf(fp_prof, "cuda_FMT_m_Finalize():\n");
  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = cuda_SCF_get_dev_Data(i);
    int mmax = dev->fmt_m_mmax;
    cuda_set_Device(i);
    for (int m=0; m<=mmax; m++) { 
      err = cudaFree(dev->fmt_m_table[m]);
      if (err!=cudaSuccess) exit(1);
    }
  }
  FMT_m_Initialized = -1;

  return 0;
}

/* ------------------------------------- */

#if   CUDA_FMT_M_NEXP == 6
#include "cuda-fmt-method1-8-6-12.cu"
#include "cuda-fmt-method2-8-6-12.cu"
#include "cuda-fmt-method3-8-6-12.cu"
#elif CUDA_FMT_M_NEXP == 8
#include "cuda-fmt-method1-8-8-12.cu"
#include "cuda-fmt-method2-8-8-12.cu"
#include "cuda-fmt-method3-8-8-12.cu"
#elif CUDA_FMT_M_NEXP == 10
#include "cuda-fmt-method1-8-10-12.cu"
#include "cuda-fmt-method2-8-10-12.cu"
#include "cuda-fmt-method3-8-10-12.cu"
#endif

/* ------------------------------------- */

#include <stdio.h>
#include <math.h>
#include "cuda-root.h"

#if 0
__device__ __constant__ double dinv3 = 1.e0 / 3.e0;
__device__ __constant__ double dinv5 = 1.e0 / 5.e0;
__device__ __constant__ double PIE4 = 7.85398163397448e-01;
__device__ __constant__ double R12  = 2.75255128608411e-01;
__device__ __constant__ double R13  = 1.90163509193487e-01;
__device__ __constant__ double R22  = 2.72474487139158e+00;
__device__ __constant__ double R23  = 1.78449274854325e+00;
__device__ __constant__ double R33  = 5.52534374226326e+00;
__device__ __constant__ double W22  = 9.17517095361369e-02;
__device__ __constant__ double W23  = 1.77231492083829e-01;
__device__ __constant__ double W33  = 5.11156880411248e-03;

__device__ __constant__ double R14  = 1.45303521503316e-01;
__device__ __constant__ double R24  = 1.33909728812636e+00;
__device__ __constant__ double R34  = 3.92696350135829e+00;
__device__ __constant__ double R44  = 8.58863568901199e+00;
__device__ __constant__ double W24  = 2.34479815323517e-01;
__device__ __constant__ double W34  = 1.92704402415764e-02;
__device__ __constant__ double W44  = 2.25229076750736e-04;

__device__ __constant__ double R15  = 1.17581320211778e-01;
__device__ __constant__ double R25  = 1.07456201243690e+00;
__device__ __constant__ double R35  = 3.08593744371754e+00;
__device__ __constant__ double R45  = 6.41472973366203e+00;
__device__ __constant__ double R55  = 1.18071894899717e+01;
__device__ __constant__ double W25  = 2.70967405960535e-01;
__device__ __constant__ double W35  = 3.82231610015404e-02;
__device__ __constant__ double W45  = 1.51614186862443e-03;
__device__ __constant__ double W55  = 8.62130526143657e-06;

#else

#define dinv3   (1.e0 / 3.e0)
#define dinv5   (1.e0 / 5.e0)
#define PIE4   7.85398163397448e-01
#define R12    2.75255128608411e-01
#define R13    1.90163509193487e-01
#define R22    2.72474487139158e+00
#define R23    1.78449274854325e+00
#define R33    5.52534374226326e+00
#define W22    9.17517095361369e-02
#define W23    1.77231492083829e-01
#define W33    5.11156880411248e-03

#define R14    1.45303521503316e-01
#define R24    1.33909728812636e+00
#define R34    3.92696350135829e+00
#define R44    8.58863568901199e+00
#define W24    2.34479815323517e-01
#define W34    1.92704402415764e-02
#define W44    2.25229076750736e-04

#define R15    1.17581320211778e-01
#define R25    1.07456201243690e+00
#define R35    3.08593744371754e+00
#define R45    6.41472973366203e+00
#define R55    1.18071894899717e+01
#define W25    2.70967405960535e-01
#define W35    3.82231610015404e-02
#define W45    1.51614186862443e-03
#define W55    8.62130526143657e-06

#endif

__device__ void gpu_root1( const double T, double U[], double W[] ) {
    double F1, Y, E, RT;
    if ( T <= 3.e-7 ) {
	U[0] = 0.5e0 - T * dinv5;
	W[0] = 1.e0  - T * dinv3;
    } else if ( T <= 1.e0 ) {
	F1 = ((((((((-8.36313918003957e-08*T+1.21222603512827e-06 )*T-
	    1.15662609053481e-05 )*T+9.25197374512647e-05 )*T-
	    6.40994113129432e-04 )*T+3.78787044215009e-03 )*T-
	    1.85185172458485e-02 )*T+7.14285713298222e-02 )*T-
	    1.99999999997023e-01 )*T+3.33333333333318e-01;
	W[0] = (T+T)*F1+exp(-T);
	U[0] = F1/(W[0]-F1);
    } else if ( T <= 3.e0 ) {
	Y = T-2.0e+00;
	F1 = ((((((((((-1.61702782425558e-10*Y+1.96215250865776e-09 )*Y-
	    2.14234468198419e-08 )*Y+2.17216556336318e-07 )*Y-
	    1.98850171329371e-06 )*Y+1.62429321438911e-05 )*Y-
	    1.16740298039895e-04 )*Y+7.24888732052332e-04 )*Y-
	    3.79490003707156e-03 )*Y+1.61723488664661e-02 )*Y-
	    5.29428148329736e-02 )*Y+1.15702180856167e-01;
	W[0] = (T+T)*F1+exp(-T);
	U[0] = F1/(W[0]-F1);
    } else if ( T <= 5.e0 ) {
	Y = T-4.0e+00;
	F1 = ((((((((((-2.62453564772299e-11*Y+3.24031041623823e-10 )*Y-
	    3.614965656163e-09)*Y+3.760256799971e-08)*Y-
	    3.553558319675e-07)*Y+3.022556449731e-06)*Y-
	    2.290098979647e-05)*Y+1.526537461148e-04)*Y-
	    8.81947375894379e-04 )*Y+4.33207949514611e-03 )*Y-
	    1.75257821619926e-02 )*Y+5.28406320615584e-02;
	W[0] = (T+T)*F1+exp(-T);
	U[0] = F1/(W[0]-F1);
    } else if ( T <= 10.e0 ) {
	E = exp(-T);
	RT = 1.e0/T;
	W[0] = (((((( 4.6897511375022e-01*RT-6.9955602298985e-01)*RT +
	    5.3689283271887e-01)*RT-3.2883030418398e-01)*RT +
	    2.4645596956002e-01)*RT-4.9984072848436e-01)*RT -
	    3.1501078774085e-06)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	U[0] = F1/(W[0]-F1);
    } else if ( T <= 15.e0 ) {
	E = exp(-T);
	RT = 1.e0/T;
	W[0] = (((-1.8784686463512e-01*RT+2.2991849164985e-01)*RT -
          4.9893752514047e-01)*RT-2.1916512131607e-05)*E + sqrt(PIE4*RT);
        F1 = (W[0]-E)/(T+T);
	U[0] = F1/(W[0]-F1);
    } else if ( T <= 33.e0 ) {
	E = exp(-T);
	RT = 1.e0 / T;
	W[0] = (( 1.9623264149430e-01*RT-4.9695241464490e-01)*RT -
          6.0156581186481e-05)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	U[0] = F1/(W[0]-F1);
    } else {
	W[0] = sqrt( PIE4 / T );
	U[0] = 0.5e0/(T-0.5e0);
    }
}

__device__ void gpu_root2( const double T, double U[], double W[] ) {
    double F1, Y, E, RT;
    if        ( T <= 3.e-7 ) {
	U[0] = 1.30693606237085e-01 -2.90430236082028e-02 *T;
	U[1] = 2.86930639376291e+00 -6.37623643058102e-01 *T;
	W[0] = 6.52145154862545e-01 -1.22713621927067e-01 *T;
	W[1] = 3.47854845137453e-01 -2.10619711404725e-01 *T;
    } else if ( T <= 1.e0 ) {
	F1 = ((((((((-8.36313918003957e-08*T+1.21222603512827e-06 )*T-
	    1.15662609053481e-05 )*T+9.25197374512647e-05 )*T-
	    6.40994113129432e-04 )*T+3.78787044215009e-03 )*T-
	    1.85185172458485e-02 )*T+7.14285713298222e-02 )*T-
	    1.99999999997023e-01 )*T+3.33333333333318e-01;
	W[0] = (T+T)*F1+exp(-T);
	U[0] = (((((((-2.35234358048491e-09*T+2.49173650389842e-08)*T-
            4.558315364581e-08)*T-2.447252174587e-06)*T+
            4.743292959463e-05)*T-5.33184749432408e-04 )*T+
            4.44654947116579e-03 )*T-2.90430236084697e-02 )*T+
            1.30693606237085e-01;
	U[1] = (((((((-2.47404902329170e-08*T+2.36809910635906e-07)*T+
	    1.835367736310e-06)*T-2.066168802076e-05)*T-
	    1.345693393936e-04)*T-5.88154362858038e-05 )*T+
	    5.32735082098139e-02 )*T-6.37623643056745e-01 )*T+
	    2.86930639376289e+00;
	W[1] = ((F1-W[0])*U[0]+F1)*(1.0e+00+U[1])/(U[1]-U[0]);
	W[0] -= W[1];
    } else if ( T <= 3.e0 ) {
	Y = T-2.0e+00;
	F1 = ((((((((((-1.61702782425558e-10*Y+1.96215250865776e-09 )*Y-
	    2.14234468198419e-08 )*Y+2.17216556336318e-07 )*Y-
	    1.98850171329371e-06 )*Y+1.62429321438911e-05 )*Y-
	    1.16740298039895e-04 )*Y+7.24888732052332e-04 )*Y-
	    3.79490003707156e-03 )*Y+1.61723488664661e-02 )*Y-
	    5.29428148329736e-02 )*Y+1.15702180856167e-01;
	W[0] = (T+T)*F1+exp(-T);
	U[0] = (((((((((-6.36859636616415e-12*Y+8.47417064776270e-11)*Y-
	    5.152207846962e-10)*Y-3.846389873308e-10)*Y+
	    8.472253388380e-08)*Y-1.85306035634293e-06 )*Y+
	    2.47191693238413e-05 )*Y-2.49018321709815e-04 )*Y+
	    2.19173220020161e-03 )*Y-1.63329339286794e-02 )*Y+
	    8.68085688285261e-02;
	U[1] = ((((((((( 1.45331350488343e-10*Y+2.07111465297976e-09)*Y-
	    1.878920917404e-08)*Y-1.725838516261e-07)*Y+
	    2.247389642339e-06)*Y+9.76783813082564e-06 )*Y-
	    1.93160765581969e-04 )*Y-1.58064140671893e-03 )*Y+
	    4.85928174507904e-02 )*Y-4.30761584997596e-01 )*Y+
	    1.80400974537950e+00;
	W[1] = ((F1-W[0])*U[0]+F1)*(1.0e+00+U[1])/(U[1]-U[0]);
	W[0] -= W[1];
    } else if ( T <= 5.e0 ) {
	Y = T - 4.e0;
	F1 = ((((((((((-2.62453564772299e-11*Y+3.24031041623823e-10 )*Y-
	    3.614965656163e-09)*Y+3.760256799971e-08)*Y-
	    3.553558319675e-07)*Y+3.022556449731e-06)*Y-
	    2.290098979647e-05)*Y+1.526537461148e-04)*Y-
	    8.81947375894379e-04 )*Y+4.33207949514611e-03 )*Y-
	    1.75257821619926e-02 )*Y+5.28406320615584e-02;
	W[0] = (T+T)*F1+exp(-T);
	U[0] = ((((((((-4.11560117487296e-12*Y+7.10910223886747e-11)*Y-
	    1.73508862390291e-09 )*Y+5.93066856324744e-08 )*Y-
	    9.76085576741771e-07 )*Y+1.08484384385679e-05 )*Y-
	    1.12608004981982e-04 )*Y+1.16210907653515e-03 )*Y-
	    9.89572595720351e-03 )*Y+6.12589701086408e-02;
	U[1] = (((((((((-1.80555625241001e-10*Y+5.44072475994123e-10)*Y+
	    1.603498045240e-08)*Y-1.497986283037e-07)*Y-
	    7.017002532106e-07)*Y+1.85882653064034e-05 )*Y-
	    2.04685420150802e-05 )*Y-2.49327728643089e-03 )*Y+
	    3.56550690684281e-02 )*Y-2.60417417692375e-01 )*Y+
	    1.12155283108289e+00;
	W[1] = ((F1-W[0])*U[0]+F1)*(1.0e+00+U[1])/(U[1]-U[0]);
	W[0] -= W[1];
    } else if ( T <= 10.e0 ) {
	E = exp( -T );
	RT = 1.e0/T;
	W[0] = (((((( 4.6897511375022e-01*RT-6.9955602298985e-01)*RT +
	    5.3689283271887e-01)*RT-3.2883030418398e-01)*RT +
	    2.4645596956002e-01)*RT-4.9984072848436e-01)*RT -
	    3.1501078774085e-06)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	Y  = T - 7.5e0;
	U[0] = (((((((((((((-1.43632730148572e-16*Y+2.38198922570405e-16)*
	    Y+1.358319618800e-14)*Y-7.064522786879e-14)*Y-
	    7.719300212748e-13)*Y+7.802544789997e-12)*Y+
	    6.628721099436e-11)*Y-1.775564159743e-09)*Y+
	    1.713828823990e-08)*Y-1.497500187053e-07)*Y+
	    2.283485114279e-06)*Y-3.76953869614706e-05 )*Y+
	    4.74791204651451e-04 )*Y-4.60448960876139e-03 )*Y+
	    3.72458587837249e-02;
	U[1] = (((((((((((( 2.48791622798900e-14*Y-1.36113510175724e-13)*Y-
	    2.224334349799e-12)*Y+4.190559455515e-11)*Y-
	    2.222722579924e-10)*Y-2.624183464275e-09)*Y+
	    6.128153450169e-08)*Y-4.383376014528e-07)*Y-
	    2.49952200232910e-06 )*Y+1.03236647888320e-04 )*Y-
	    1.44614664924989e-03 )*Y+1.35094294917224e-02 )*Y-
	    9.53478510453887e-02 )*Y+5.44765245686790e-01;
	W[1] = ((F1-W[0])*U[0]+F1)*(1.0e+00+U[1])/(U[1]-U[0]);
	W[0] -= W[1];
    } else if ( T <= 15.e0 ) {
	E = exp(-T);
	RT = 1.e0/T;
	W[0] = (((-1.8784686463512e-01*RT+2.2991849164985e-01)*RT -
          4.9893752514047e-01)*RT-2.1916512131607e-05)*E + sqrt(PIE4*RT);
        F1 = (W[0]-E)/(T+T);
	U[0] = ((((-1.01041157064226e-05*T+1.19483054115173e-03)*T -
	    6.73760231824074e-02)*T+1.25705571069895e+00)*T + (((-
	    8.57609422987199e+03*RT+5.91005939591842e+03)*RT -
	    1.70807677109425e+03)*RT+2.64536689959503e+02)*RT -
	    2.38570496490846e+01)*E + R12/(T-R12);
	U[1] = ((( 3.39024225137123e-04*T-9.34976436343509e-02)*T -
	    4.22216483306320e+00)*T + (((-2.08457050986847e+03*RT -
	    1.04999071905664e+03)*RT+3.39891508992661e+02)*RT -
	    1.56184800325063e+02)*RT+8.00839033297501e+00)*E + R22/(T-R22);
	W[1] = ((F1-W[0])*U[0]+F1)*(1.0e+00+U[1])/(U[1]-U[0]);
	W[0] -= W[1];
    } else if ( T <= 33.e0 ) {
	E = exp(-T);
	RT = 1.e0 / T;
	W[0] = (( 1.9623264149430e-01*RT-4.9695241464490e-01)*RT -
          6.0156581186481e-05)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	U[0] = ((((-1.14906395546354e-06*T+1.76003409708332e-04)*T -
	    1.71984023644904e-02)*T-1.37292644149838e-01)*T + (-
	    4.75742064274859e+01*RT+9.21005186542857e+00)*RT -
	    2.31080873898939e-02)*E + R12/(T-R12);
	U[1] = ((( 3.64921633404158e-04*T-9.71850973831558e-02)*T -
	    4.02886174850252e+00)*T + (-1.35831002139173e+02*RT -
	    8.66891724287962e+01)*RT+2.98011277766958e+00)*E + R22/(T-R22);
	W[1] = ((F1-W[0])*U[0]+F1)*(1.0e+00+U[1])/(U[1]-U[0]);
	W[0] -= W[1];
    } else if ( T <= 40.e0 ) {
	W[0] = sqrt( PIE4 / T );
	E = exp(-T);
	U[0] = (-8.78947307498880e-01*T+1.09243702330261e+01)*E + R12/(T-
	    R12);
	U[1] = (-9.28903924275977e+00*T+8.10642367843811e+01)*E + R22/(T-
	    R22);
	W[1] = ( 4.46857389308400e+00*T-7.79250653461045e+01)*E + W22*W[0];
	W[0] -= W[1];
    } else {
	W[0] = sqrt( PIE4 / T );
	U[0] = R12/(T-R12);
	U[1] = R22/(T-R22);
	W[1] = W22*W[0];
	W[0] -= W[1];
    }
}

__device__ void gpu_root3( const double T, double U[], double W[] ) {
    double F1, F2, Y, E, RT, T1, T2, T3, A1, A2;
    if ( T <= 3.e-7 ) {
	U[0] = 6.03769246832797e-02 -9.28875764357368e-03 *T;
	U[1] = 7.76823355931043e-01 -1.19511285527878e-01 *T;
	U[2] = 6.66279971938567e+00 -1.02504611068957e+00 *T;
	W[0] = 4.67913934572691e-01 -5.64876917232519e-02 *T;
	W[1] = 3.60761573048137e-01 -1.49077186455208e-01 *T;
	W[2] = 1.71324492379169e-01 -1.27768455150979e-01 *T;
    } else if ( T <= 1.e0 ) {
	U[0] = ((((((-5.10186691538870e-10*T+2.40134415703450e-08)*T-
	    5.01081057744427e-07 )*T+7.58291285499256e-06 )*T-
	    9.55085533670919e-05 )*T+1.02893039315878e-03 )*T-
	    9.28875764374337e-03 )*T+6.03769246832810e-02;
	U[1] = ((((((-1.29646524960555e-08*T+7.74602292865683e-08)*T+
	    1.56022811158727e-06 )*T-1.58051990661661e-05 )*T-
	    3.30447806384059e-04 )*T+9.74266885190267e-03 )*T-
	    1.19511285526388e-01 )*T+7.76823355931033e-01;
	U[2] = ((((((-9.28536484109606e-09*T-3.02786290067014e-07)*T-
	    2.50734477064200e-06 )*T-7.32728109752881e-06 )*T+
	    2.44217481700129e-04 )*T+4.94758452357327e-02 )*T-
	    1.02504611065774e+00 )*T+6.66279971938553e+00;
	F2 = ((((((((-7.60911486098850e-08*T+1.09552870123182e-06 )*T-
	    1.03463270693454e-05 )*T+8.16324851790106e-05 )*T-
	    5.55526624875562e-04 )*T+3.20512054753924e-03 )*T-
	    1.51515139838540e-02 )*T+5.55555554649585e-02 )*T-
	    1.42857142854412e-01 )*T+1.99999999999986e-01;
	E = exp(-T);
	F1 = ((T+T)*F2+E)*dinv3;
	W[0] = (T+T)*F1+E;
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T <= 3.e0 ) {
	Y = T-2.0e+00;
	U[0] = (((((((( 1.44687969563318e-12*Y+4.85300143926755e-12)*Y-
	    6.55098264095516e-10 )*Y+1.56592951656828e-08 )*Y-
	    2.60122498274734e-07 )*Y+3.86118485517386e-06 )*Y-
	    5.13430986707889e-05 )*Y+6.03194524398109e-04 )*Y-
	    6.11219349825090e-03 )*Y+4.52578254679079e-02;
	U[1] = ((((((( 6.95964248788138e-10*Y-5.35281831445517e-09)*Y-
	    6.745205954533e-08)*Y+1.502366784525e-06)*Y+
	    9.923326947376e-07)*Y-3.89147469249594e-04 )*Y+
	    7.51549330892401e-03 )*Y-8.48778120363400e-02 )*Y+
	    5.73928229597613e-01;
	U[2] = ((((((((-2.81496588401439e-10*Y+3.61058041895031e-09)*Y+
	    4.53631789436255e-08 )*Y-1.40971837780847e-07 )*Y-
	    6.05865557561067e-06 )*Y-5.15964042227127e-05 )*Y+
	    3.34761560498171e-05 )*Y+5.04871005319119e-02 )*Y-
	    8.24708946991557e-01 )*Y+4.81234667357205e+00;
	F2 = ((((((((((-1.48044231072140e-10*Y+1.78157031325097e-09 )*Y-
	    1.92514145088973e-08 )*Y+1.92804632038796e-07 )*Y-
	    1.73806555021045e-06 )*Y+1.39195169625425e-05 )*Y-
	    9.74574633246452e-05 )*Y+5.83701488646511e-04 )*Y-
	    2.89955494844975e-03 )*Y+1.13847001113810e-02 )*Y-
	    3.23446977320647e-02 )*Y+5.29428148329709e-02;
	E = exp(-T);
	F1 = ((T+T)*F2+E)*dinv3;
	W[0] = (T+T)*F1+E;
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T <= 5.e0 ) {
	Y = T - 4.e0;
	U[0] = ((((((( 1.44265709189601e-11*Y-4.66622033006074e-10)*Y+
	    7.649155832025e-09)*Y-1.229940017368e-07)*Y+
	    2.026002142457e-06)*Y-2.87048671521677e-05 )*Y+
	    3.70326938096287e-04 )*Y-4.21006346373634e-03 )*Y+
	    3.50898470729044e-02;
	U[1] = ((((((((-2.65526039155651e-11*Y+1.97549041402552e-10)*Y+
	    2.15971131403034e-09 )*Y-7.95045680685193e-08 )*Y+
	    5.15021914287057e-07 )*Y+1.11788717230514e-05 )*Y-
	    3.33739312603632e-04 )*Y+5.30601428208358e-03 )*Y-
	    5.93483267268959e-02 )*Y+4.31180523260239e-01;
	U[2] = ((((((((-3.92833750584041e-10*Y-4.16423229782280e-09)*Y+
	    4.42413039572867e-08 )*Y+6.40574545989551e-07 )*Y-
	    3.05512456576552e-06 )*Y-1.05296443527943e-04 )*Y-
	    6.14120969315617e-04 )*Y+4.89665802767005e-02 )*Y-
	    6.24498381002855e-01 )*Y+3.36412312243724e+00;
	F2 = ((((((((((-2.36788772599074e-11*Y+2.89147476459092e-10 )*Y-
	    3.18111322308846e-09 )*Y+3.25336816562485e-08 )*Y-
	    3.00873821471489e-07 )*Y+2.48749160874431e-06 )*Y-
	    1.81353179793672e-05 )*Y+1.14504948737066e-04 )*Y-
	    6.10614987696677e-04 )*Y+2.64584212770942e-03 )*Y-
	    8.66415899015349e-03 )*Y+1.75257821619922e-02;
	E = exp(-T);
	F1 = ((T+T)*F2+E)*dinv3;
	W[0] = (T+T)*F1+E;
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T <= 10.e0 ) {
	E = exp(-T);
	RT = 1.e0 / T;
	W[0] = (((((( 4.6897511375022e-01*RT-6.9955602298985e-01)*RT +
	    5.3689283271887e-01)*RT-3.2883030418398e-01)*RT +
	    2.4645596956002e-01)*RT-4.9984072848436e-01)*RT -
	    3.1501078774085e-06)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	F2 = (F1+F1+F1-E)/(T+T);
	Y = T-7.5e+00;
	U[0] = ((((((((((( 5.74429401360115e-16*Y+7.11884203790984e-16)*Y-
	    6.736701449826e-14)*Y-6.264613873998e-13)*Y+
	    1.315418927040e-11)*Y-4.23879635610964e-11 )*Y+
	    1.39032379769474e-09 )*Y-4.65449552856856e-08 )*Y+
	    7.34609900170759e-07 )*Y-1.08656008854077e-05 )*Y+
	    1.77930381549953e-04 )*Y-2.39864911618015e-03 )*Y+
	    2.39112249488821e-02;
	U[1] = ((((((((((( 1.13464096209120e-14*Y+6.99375313934242e-15)*Y-
	    8.595618132088e-13)*Y-5.293620408757e-12)*Y-
	    2.492175211635e-11)*Y+2.73681574882729e-09 )*Y-
	    1.06656985608482e-08 )*Y-4.40252529648056e-07 )*Y+
	    9.68100917793911e-06 )*Y-1.68211091755327e-04 )*Y+
	    2.69443611274173e-03 )*Y-3.23845035189063e-02 )*Y+
	    2.75969447451882e-01;
	U[2] = (((((((((((( 6.66339416996191e-15*Y+1.84955640200794e-13)*Y-
	    1.985141104444e-12)*Y-2.309293727603e-11)*Y+
	    3.917984522103e-10)*Y+1.663165279876e-09)*Y-
	    6.205591993923e-08)*Y+8.769581622041e-09)*Y+
	    8.97224398620038e-06 )*Y-3.14232666170796e-05 )*Y-
	    1.83917335649633e-03 )*Y+3.51246831672571e-02 )*Y-
	    3.22335051270860e-01 )*Y+1.73582831755430e+00;
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T <= 15.e0 ) {
	E = exp(-T);
	RT = 1.e0/T;
	W[0] = (((-1.8784686463512e-01*RT+2.2991849164985e-01)*RT -
          4.9893752514047e-01)*RT-2.1916512131607e-05)*E + sqrt(PIE4*RT);
        F1 = (W[0]-E)/(T+T);
	F2 = (F1+F1+F1-E)/(T+T);
	Y = T-12.5e+00;
	U[0] = ((((((((((( 4.42133001283090e-16*Y-2.77189767070441e-15)*Y-
	    4.084026087887e-14)*Y+5.379885121517e-13)*Y+
	    1.882093066702e-12)*Y-8.67286219861085e-11 )*Y+
	    7.11372337079797e-10 )*Y-3.55578027040563e-09 )*Y+
	    1.29454702851936e-07 )*Y-4.14222202791434e-06 )*Y+
	    8.04427643593792e-05 )*Y-1.18587782909876e-03 )*Y+
	    1.53435577063174e-02;
	U[1] = ((((((((((( 6.85146742119357e-15*Y-1.08257654410279e-14)*Y-
	    8.579165965128e-13)*Y+6.642452485783e-12)*Y+
	    4.798806828724e-11)*Y-1.13413908163831e-09 )*Y+
	    7.08558457182751e-09 )*Y-5.59678576054633e-08 )*Y+
	    2.51020389884249e-06 )*Y-6.63678914608681e-05 )*Y+
	    1.11888323089714e-03 )*Y-1.45361636398178e-02 )*Y+
	    1.65077877454402e-01;
	U[2] = (((((((((((( 3.20622388697743e-15*Y-2.73458804864628e-14)*Y-
	    3.157134329361e-13)*Y+8.654129268056e-12)*Y-
	    5.625235879301e-11)*Y-7.718080513708e-10)*Y+
	    2.064664199164e-08)*Y-1.567725007761e-07)*Y-
	    1.57938204115055e-06 )*Y+6.27436306915967e-05 )*Y-
	    1.01308723606946e-03 )*Y+1.13901881430697e-02 )*Y-
	    1.01449652899450e-01 )*Y+7.77203937334739e-01;
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T <= 20.e0 ) {
	E = exp(-T);
	RT = 1.e0 / T;
	W[0] = (( 1.9623264149430e-01*RT-4.9695241464490e-01)*RT -
          6.0156581186481e-05)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	F2 = (F1+F1+F1-E)/(T+T);
	U[0] = ((((((-2.43270989903742e-06*T+3.57901398988359e-04)*T -
	    2.34112415981143e-02)*T+7.81425144913975e-01)*T -
	    1.73209218219175e+01)*T+2.43517435690398e+02)*T + (-
	    1.97611541576986e+04*RT+9.82441363463929e+03)*RT -
	    2.07970687843258e+03)*E + R13/(T-R13);
	U[1] = (((((-2.62627010965435e-04*T+3.49187925428138e-02)*T -
	    3.09337618731880e+00)*T+1.07037141010778e+02)*T -
	    2.36659637247087e+03)*T + ((-2.91669113681020e+06*RT +
	    1.41129505262758e+06)*RT-2.91532335433779e+05)*RT +
	    3.35202872835409e+04)*E + R23/(T-R23);
	U[2] = ((((( 9.31856404738601e-05*T-2.87029400759565e-02)*T -
	    7.83503697918455e-01)*T-1.84338896480695e+01)*T +
	    4.04996712650414e+02)*T + (-1.89829509315154e+05*RT +
	    5.11498390849158e+04)*RT-6.88145821789955e+03)*E + R33/(T-R33);
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T<= 33.e0 ) {
	E = exp(-T);
	RT = 1.e0 / T;
	W[0] = (( 1.9623264149430e-01*RT-4.9695241464490e-01)*RT -
          6.0156581186481e-05)*E + sqrt(PIE4*RT);
	F1 = (W[0]-E)/(T+T);
	F2 = (F1+F1+F1-E)/(T+T);
	U[0] = ((((-4.97561537069643e-04*T-5.00929599665316e-02)*T +
	    1.31099142238996e+00)*T-1.88336409225481e+01)*T -
	    6.60344754467191e+02 *RT+1.64931462413877e+02)*E + R13/(T-R13);
	U[1] = ((((-4.48218898474906e-03*T-5.17373211334924e-01)*T +
	    1.13691058739678e+01)*T-1.65426392885291e+02)*T -
	    6.30909125686731e+03 *RT+1.52231757709236e+03)*E + R23/(T-R23);
	U[2] = ((((-1.38368602394293e-02*T-1.77293428863008e+00)*T +
	    1.73639054044562e+01)*T-3.57615122086961e+02)*T -
	    1.45734701095912e+04 *RT+2.69831813951849e+03)*E + R33/(T-R33);
	T1 = U[0]/(U[0]+1.0e+00);
	T2 = U[1]/(U[1]+1.0e+00);
	T3 = U[2]/(U[2]+1.0e+00);
	A2 = F2-T1*F1;
	A1 = F1-T1*W[0];
	W[2] = (A2-T2*A1)/((T3-T2)*(T3-T1));
	W[1] = (T3*A1-A2)/((T3-T2)*(T2-T1));
	W[0] = W[0] - W[1] - W[2];
    } else if ( T <= 47.e0 ) {
	W[0] = sqrt(PIE4/T);
	E = exp(-T);
	U[0] = ((-7.39058467995275e+00*T+3.21318352526305e+02)*T -
	    3.99433696473658e+03)*E + R13/(T-R13);
	U[1] = ((-7.38726243906513e+01*T+3.13569966333873e+03)*T -
	    3.86862867311321e+04)*E + R23/(T-R23);
	U[2] = ((-2.63750565461336e+02*T+1.04412168692352e+04)*T -
	    1.28094577915394e+05)*E + R33/(T-R33);
	W[2] = ((( 1.52258947224714e-01*T-8.30661900042651e+00)*T +
	    1.92977367967984e+02)*T-1.67787926005344e+03)*E + W33*W[0];
	W[1] = (( 6.15072615497811e+01*T-2.91980647450269e+03)*T +
	    3.80794303087338e+04)*E + W23*W[0];
	W[0] = W[0] - W[1] - W[2];
    } else {
	W[0] = sqrt(PIE4/T);
	U[0] = R13/(T-R13);
	U[1] = R23/(T-R23);
	U[2] = R33/(T-R33);
	W[1] = W23*W[0];
	W[2] = W33*W[0];
	W[0] = W[0] - W[1] - W[2];
    }
}

__device__ void gpu_root4( const double T, double U[], double W[] ) {
    double E, RT, Y;
    if ( T <= 3.0e-07 ) {
        U[0] = 3.48198973061471e-02 -4.09645850660395e-03 *T;
        U[1] = 3.81567185080042e-01 -4.48902570656719e-02 *T;
        U[2] = 1.73730726945891e+00 -2.04389090547327e-01 *T;
        U[3] = 1.18463056481549e+01 -1.39368301742312e+00 *T;
        W[0] = 3.62683783378362e-01 -3.13844305713928e-02 *T;
        W[1] = 3.13706645877886e-01 -8.98046242557724e-02 *T;
        W[2] = 2.22381034453372e-01 -1.29314370958973e-01 *T;
        W[3] = 1.01228536290376e-01 -8.28299075414321e-02 *T;;
    } else if ( T <= 1.e0 ) {
        U[0] = ((((((-1.95309614628539e-10*T+5.19765728707592e-09)*T-
            1.01756452250573e-07 )*T+1.72365935872131e-06 )*T-
            2.61203523522184e-05 )*T+3.52921308769880e-04 )*T-
            4.09645850658433e-03 )*T+3.48198973061469e-02;
        U[1] = (((((-1.89554881382342e-08*T+3.07583114342365e-07)*T+
            1.270981734393e-06)*T-1.417298563884e-04)*T+
            3.226979163176e-03)*T-4.48902570678178e-02 )*T+
            3.81567185080039e-01;
        U[2] = (((((( 1.77280535300416e-09*T+3.36524958870615e-08)*T-
            2.58341529013893e-07 )*T-1.13644895662320e-05 )*T-
            7.91549618884063e-05 )*T+1.03825827346828e-02 )*T-
            2.04389090525137e-01 )*T+1.73730726945889e+00;
        U[3] = (((((-5.61188882415248e-08*T-2.49480733072460e-07)*T+
            3.428685057114e-06)*T+1.679007454539e-04)*T+
            4.722855585715e-02)*T-1.39368301737828e+00 )*T+
            1.18463056481543e+01;
        W[0] = ((((((-1.14649303201279e-08*T+1.88015570196787e-07)*T-
            2.33305875372323e-06 )*T+2.68880044371597e-05 )*T-
            2.94268428977387e-04 )*T+3.06548909776613e-03 )*T-
            3.13844305680096e-02 )*T+3.62683783378335e-01;
        W[1] = ((((((((-4.11720483772634e-09*T+6.54963481852134e-08)*T-
            7.20045285129626e-07 )*T+6.93779646721723e-06 )*T-
            6.05367572016373e-05 )*T+4.74241566251899e-04 )*T-
            3.26956188125316e-03 )*T+1.91883866626681e-02 )*T-
            8.98046242565811e-02 )*T+3.13706645877886e-01;
        W[2] = ((((((((-3.41688436990215e-08*T+5.07238960340773e-07)*T-
            5.01675628408220e-06 )*T+4.20363420922845e-05 )*T-
            3.08040221166823e-04 )*T+1.94431864731239e-03 )*T-
            1.02477820460278e-02 )*T+4.28670143840073e-02 )*T-
            1.29314370962569e-01 )*T+2.22381034453369e-01;
        W[3] = ((((((((( 4.99660550769508e-09*T-7.94585963310120e-08)*T+
            8.359072409485e-07)*T-7.422369210610e-06)*T+
            5.763374308160e-05)*T-3.86645606718233e-04 )*T+
            2.18417516259781e-03 )*T-9.99791027771119e-03 )*T+
            3.48791097377370e-02 )*T-8.28299075413889e-02 )*T+
            1.01228536290376e-01;
    } else if ( T <= 5.e0 ) {
        Y = T-3.0e+00;
        U[0] = (((((((((-1.48570633747284e-15*Y-1.33273068108777e-13)*Y+
            4.068543696670e-12)*Y-9.163164161821e-11)*Y+
            2.046819017845e-09)*Y-4.03076426299031e-08 )*Y+
            7.29407420660149e-07 )*Y-1.23118059980833e-05 )*Y+
            1.88796581246938e-04 )*Y-2.53262912046853e-03 )*Y+
            2.51198234505021e-02;
        U[1] = ((((((((( 1.35830583483312e-13*Y-2.29772605964836e-12)*Y-
            3.821500128045e-12)*Y+6.844424214735e-10)*Y-
            1.048063352259e-08)*Y+1.50083186233363e-08 )*Y+
            3.48848942324454e-06 )*Y-1.08694174399193e-04 )*Y+
            2.08048885251999e-03 )*Y-2.91205805373793e-02 )*Y+
            2.72276489515713e-01;
        U[2] = ((((((((( 5.02799392850289e-13*Y+1.07461812944084e-11)*Y-
            1.482277886411e-10)*Y-2.153585661215e-09)*Y+
            3.654087802817e-08)*Y+5.15929575830120e-07 )*Y-
            9.52388379435709e-06 )*Y-2.16552440036426e-04 )*Y+
            9.03551469568320e-03 )*Y-1.45505469175613e-01 )*Y+
            1.21449092319186e+00;
        U[3] = (((((((((-1.08510370291979e-12*Y+6.41492397277798e-11)*Y+
            7.542387436125e-10)*Y-2.213111836647e-09)*Y-
            1.448228963549e-07)*Y-1.95670833237101e-06 )*Y-
            1.07481314670844e-05 )*Y+1.49335941252765e-04 )*Y+
            4.87791531990593e-02 )*Y-1.10559909038653e+00 )*Y+
            8.09502028611780e+00;
        W[0] = ((((((((((-4.65801912689961e-14*Y+7.58669507106800e-13)*Y-
            1.186387548048e-11)*Y+1.862334710665e-10)*Y-
            2.799399389539e-09)*Y+4.148972684255e-08)*Y-
            5.933568079600e-07)*Y+8.168349266115e-06)*Y-
            1.08989176177409e-04 )*Y+1.41357961729531e-03 )*Y-
            1.87588361833659e-02 )*Y+2.89898651436026e-01;
        W[1] = ((((((((((((-1.46345073267549e-14*Y+2.25644205432182e-13)*Y-
            3.116258693847e-12)*Y+4.321908756610e-11)*Y-
            5.673270062669e-10)*Y+7.006295962960e-09)*Y-
            8.120186517000e-08)*Y+8.775294645770e-07)*Y-
            8.77829235749024e-06 )*Y+8.04372147732379e-05 )*Y-
            6.64149238804153e-04 )*Y+4.81181506827225e-03 )*Y-
            2.88982669486183e-02 )*Y+1.56247249979288e-01;
        W[2] = ((((((((((((( 9.06812118895365e-15*Y-1.40541322766087e-13)*
            Y+1.919270015269e-12)*Y-2.605135739010e-11)*Y+
            3.299685839012e-10)*Y-3.86354139348735e-09 )*Y+
            4.16265847927498e-08 )*Y-4.09462835471470e-07 )*Y+
            3.64018881086111e-06 )*Y-2.88665153269386e-05 )*Y+
            2.00515819789028e-04 )*Y-1.18791896897934e-03 )*Y+
            5.75223633388589e-03 )*Y-2.09400418772687e-02 )*Y+
            4.85368861938873e-02;
        W[3] = ((((((((((((((-9.74835552342257e-16*Y+1.57857099317175e-14)*
            Y-2.249993780112e-13)*Y+3.173422008953e-12)*Y-
            4.161159459680e-11)*Y+5.021343560166e-10)*Y-
            5.545047534808e-09)*Y+5.554146993491e-08)*Y-
            4.99048696190133e-07 )*Y+3.96650392371311e-06 )*Y-
            2.73816413291214e-05 )*Y+1.60106988333186e-04 )*Y-
            7.64560567879592e-04 )*Y+2.81330044426892e-03 )*Y-
            7.16227030134947e-03 )*Y+9.66077262223353e-03;
    } else if ( T <= 10.e0 ) {
        Y = T-7.5e+00;
        U[0] = ((((((((( 4.64217329776215e-15*Y-6.27892383644164e-15)*Y+
            3.462236347446e-13)*Y-2.927229355350e-11)*Y+
            5.090355371676e-10)*Y-9.97272656345253e-09 )*Y+
            2.37835295639281e-07 )*Y-4.60301761310921e-06 )*Y+
            8.42824204233222e-05 )*Y-1.37983082233081e-03 )*Y+
            1.66630865869375e-02;
        U[1] = ((((((((( 2.93981127919047e-14*Y+8.47635639065744e-13)*Y-
            1.446314544774e-11)*Y-6.149155555753e-12)*Y+
            8.484275604612e-10)*Y-6.10898827887652e-08 )*Y+
            2.39156093611106e-06 )*Y-5.35837089462592e-05 )*Y+
            1.00967602595557e-03 )*Y-1.57769317127372e-02 )*Y+
            1.74853819464285e-01;
        U[2] = (((((((((( 2.93523563363000e-14*Y-6.40041776667020e-14)*Y-
            2.695740446312e-12)*Y+1.027082960169e-10)*Y-
            5.822038656780e-10)*Y-3.159991002539e-08)*Y+
            4.327249251331e-07)*Y+4.856768455119e-06)*Y-
            2.54617989427762e-04 )*Y+5.54843378106589e-03 )*Y-
            7.95013029486684e-02 )*Y+7.20206142703162e-01;
        U[3] = (((((((((((-1.62212382394553e-14*Y+7.68943641360593e-13)*Y+
            5.764015756615e-12)*Y-1.380635298784e-10)*Y-
            1.476849808675e-09)*Y+1.84347052385605e-08 )*Y+
            3.34382940759405e-07 )*Y-1.39428366421645e-06 )*Y-
            7.50249313713996e-05 )*Y-6.26495899187507e-04 )*Y+
            4.69716410901162e-02 )*Y-6.66871297428209e-01 )*Y+
            4.11207530217806e+00;
        W[0] = ((((((((((-1.65995045235997e-15*Y+6.91838935879598e-14)*Y-
            9.131223418888e-13)*Y+1.403341829454e-11)*Y-
            3.672235069444e-10)*Y+6.366962546990e-09)*Y-
            1.039220021671e-07)*Y+1.959098751715e-06)*Y-
            3.33474893152939e-05 )*Y+5.72164211151013e-04 )*Y-
            1.05583210553392e-02 )*Y+2.26696066029591e-01;
        W[1] = ((((((((((((-3.57248951192047e-16*Y+6.25708409149331e-15)*Y-
            9.657033089714e-14)*Y+1.507864898748e-12)*Y-
            2.332522256110e-11)*Y+3.428545616603e-10)*Y-
            4.698730937661e-09)*Y+6.219977635130e-08)*Y-
            7.83008889613661e-07 )*Y+9.08621687041567e-06 )*Y-
            9.86368311253873e-05 )*Y+9.69632496710088e-04 )*Y-
            8.14594214284187e-03 )*Y+8.50218447733457e-02;
        W[2] = ((((((((((((( 1.64742458534277e-16*Y-2.68512265928410e-15)*
            Y+3.788890667676e-14)*Y-5.508918529823e-13)*Y+
            7.555896810069e-12)*Y-9.69039768312637e-11 )*Y+
            1.16034263529672e-09 )*Y-1.28771698573873e-08 )*Y+
            1.31949431805798e-07 )*Y-1.23673915616005e-06 )*Y+
            1.04189803544936e-05 )*Y-7.79566003744742e-05 )*Y+
            5.03162624754434e-04 )*Y-2.55138844587555e-03 )*Y+
            1.13250730954014e-02;
        W[3] = ((((((((((((((-1.55714130075679e-17*Y+2.57193722698891e-16)*
            Y-3.626606654097e-15)*Y+5.234734676175e-14)*Y-
            7.067105402134e-13)*Y+8.793512664890e-12)*Y-
            1.006088923498e-10)*Y+1.050565098393e-09)*Y-
            9.91517881772662e-09 )*Y+8.35835975882941e-08 )*Y-
            6.19785782240693e-07 )*Y+3.95841149373135e-06 )*Y-
            2.11366761402403e-05 )*Y+9.00474771229507e-05 )*Y-
            2.78777909813289e-04 )*Y+5.26543779837487e-04;
    } else if ( T <=15.e0 ) {
        Y = T-12.5e+00;
        RT = 1.e0 / T;
        U[0] = ((((((((((( 4.94869622744119e-17*Y+8.03568805739160e-16)*Y-
            5.599125915431e-15)*Y-1.378685560217e-13)*Y+
            7.006511663249e-13)*Y+1.30391406991118e-11 )*Y+
            8.06987313467541e-11 )*Y-5.20644072732933e-09 )*Y+
            7.72794187755457e-08 )*Y-1.61512612564194e-06 )*Y+
            4.15083811185831e-05 )*Y-7.87855975560199e-04 )*Y+
            1.14189319050009e-02;
        U[1] = ((((((((((( 4.89224285522336e-16*Y+1.06390248099712e-14)*Y-
            5.446260182933e-14)*Y-1.613630106295e-12)*Y+
            3.910179118937e-12)*Y+1.90712434258806e-10 )*Y+
            8.78470199094761e-10 )*Y-5.97332993206797e-08 )*Y+
            9.25750831481589e-07 )*Y-2.02362185197088e-05 )*Y+
            4.92341968336776e-04 )*Y-8.68438439874703e-03 )*Y+
            1.15825965127958e-01;
        U[2] = (((((((((( 6.12419396208408e-14*Y+1.12328861406073e-13)*Y-
            9.051094103059e-12)*Y-4.781797525341e-11)*Y+
            1.660828868694e-09)*Y+4.499058798868e-10)*Y-
            2.519549641933e-07)*Y+4.977444040180e-06)*Y-
            1.25858350034589e-04 )*Y+2.70279176970044e-03 )*Y-
            3.99327850801083e-02 )*Y+4.33467200855434e-01;
        U[3] = ((((((((((( 4.63414725924048e-14*Y-4.72757262693062e-14)*Y-
            1.001926833832e-11)*Y+6.074107718414e-11)*Y+
            1.576976911942e-09)*Y-2.01186401974027e-08 )*Y-
            1.84530195217118e-07 )*Y+5.02333087806827e-06 )*Y+
            9.66961790843006e-06 )*Y-1.58522208889528e-03 )*Y+
            2.80539673938339e-02 )*Y-2.78953904330072e-01 )*Y+
            1.82835655238235e+00;
        W[3] = ((((((((((((( 2.90401781000996e-18*Y-4.63389683098251e-17)*
            Y+6.274018198326e-16)*Y-8.936002188168e-15)*Y+
            1.194719074934e-13)*Y-1.45501321259466e-12 )*Y+
            1.64090830181013e-11 )*Y-1.71987745310181e-10 )*Y+
            1.63738403295718e-09 )*Y-1.39237504892842e-08 )*Y+
            1.06527318142151e-07 )*Y-7.27634957230524e-07 )*Y+
            4.12159381310339e-06 )*Y-1.74648169719173e-05 )*Y+
            8.50290130067818e-05;
        W[2] = ((((((((((((-4.19569145459480e-17*Y+5.94344180261644e-16)*Y-
            1.148797566469e-14)*Y+1.881303962576e-13)*Y-
            2.413554618391e-12)*Y+3.372127423047e-11)*Y-
            4.933988617784e-10)*Y+6.116545396281e-09)*Y-
            6.69965691739299e-08 )*Y+7.52380085447161e-07 )*Y-
            8.08708393262321e-06 )*Y+6.88603417296672e-05 )*Y-
            4.67067112993427e-04 )*Y+5.42313365864597e-03;
        W[1] = ((((((((((-6.22272689880615e-15*Y+1.04126809657554e-13)*Y-
            6.842418230913e-13)*Y+1.576841731919e-11)*Y-
            4.203948834175e-10)*Y+6.287255934781e-09)*Y-
            8.307159819228e-08)*Y+1.356478091922e-06)*Y-
            2.08065576105639e-05 )*Y+2.52396730332340e-04 )*Y-
            2.94484050194539e-03 )*Y+6.01396183129168e-02;
        W[0] = (((-1.8784686463512e-01*RT+2.2991849164985e-01)*RT -
            4.9893752514047e-01)*RT-2.1916512131607e-05)*exp(-T) +
            sqrt(PIE4*RT)-W[3]-W[2]-W[1];
    } else if ( T <= 20.e0 ) {
	RT = 1.e0 / T;
        W[0] = sqrt(PIE4*RT);
        Y = T-17.5e+00;
        U[0] = ((((((((((( 4.36701759531398e-17*Y-1.12860600219889e-16)*Y-
            6.149849164164e-15)*Y+5.820231579541e-14)*Y+
            4.396602872143e-13)*Y-1.24330365320172e-11 )*Y+
            6.71083474044549e-11 )*Y+2.43865205376067e-10 )*Y+
            1.67559587099969e-08 )*Y-9.32738632357572e-07 )*Y+
            2.39030487004977e-05 )*Y-4.68648206591515e-04 )*Y+
            8.34977776583956e-03;
        U[1] = ((((((((((( 4.98913142288158e-16*Y-2.60732537093612e-16)*Y-
            7.775156445127e-14)*Y+5.766105220086e-13)*Y+
            6.432696729600e-12)*Y-1.39571683725792e-10 )*Y+
            5.95451479522191e-10 )*Y+2.42471442836205e-09 )*Y+
            2.47485710143120e-07 )*Y-1.14710398652091e-05 )*Y+
            2.71252453754519e-04 )*Y-4.96812745851408e-03 )*Y+
            8.26020602026780e-02;
        U[2] = ((((((((((( 1.91498302509009e-15*Y+1.48840394311115e-14)*Y-
            4.316925145767e-13)*Y+1.186495793471e-12)*Y+
            4.615806713055e-11)*Y-5.54336148667141e-10 )*Y+
            3.48789978951367e-10 )*Y-2.79188977451042e-09 )*Y+
            2.09563208958551e-06 )*Y-6.76512715080324e-05 )*Y+
            1.32129867629062e-03 )*Y-2.05062147771513e-02 )*Y+
            2.88068671894324e-01;
        U[3] = (((((((((((-5.43697691672942e-15*Y-1.12483395714468e-13)*Y+
            2.826607936174e-12)*Y-1.266734493280e-11)*Y-
            4.258722866437e-10)*Y+9.45486578503261e-09 )*Y-
            5.86635622821309e-08 )*Y-1.28835028104639e-06 )*Y+
            4.41413815691885e-05 )*Y-7.61738385590776e-04 )*Y+
            9.66090902985550e-03 )*Y-1.01410568057649e-01 )*Y+
            9.54714798156712e-01;
        W[3] = ((((((((((((-7.56882223582704e-19*Y+7.53541779268175e-18)*Y-
            1.157318032236e-16)*Y+2.411195002314e-15)*Y-
            3.601794386996e-14)*Y+4.082150659615e-13)*Y-
            4.289542980767e-12)*Y+5.086829642731e-11)*Y-
            6.35435561050807e-10 )*Y+6.82309323251123e-09 )*Y-
            5.63374555753167e-08 )*Y+3.57005361100431e-07 )*Y-
            2.40050045173721e-06 )*Y+4.94171300536397e-05;
        W[2] = (((((((((((-5.54451040921657e-17*Y+2.68748367250999e-16)*Y+
            1.349020069254e-14)*Y-2.507452792892e-13)*Y+
            1.944339743818e-12)*Y-1.29816917658823e-11 )*Y+
            3.49977768819641e-10 )*Y-8.67270669346398e-09 )*Y+
            1.31381116840118e-07 )*Y-1.36790720600822e-06 )*Y+
            1.19210697673160e-05 )*Y-1.42181943986587e-04 )*Y+
            4.12615396191829e-03;
        W[1] = (((((((((((-1.86506057729700e-16*Y+1.16661114435809e-15)*Y+
            2.563712856363e-14)*Y-4.498350984631e-13)*Y+
            1.765194089338e-12)*Y+9.04483676345625e-12 )*Y+
            4.98930345609785e-10 )*Y-2.11964170928181e-08 )*Y+
            3.98295476005614e-07 )*Y-5.49390160829409e-06 )*Y+
            7.74065155353262e-05 )*Y-1.48201933009105e-03 )*Y+
            4.97836392625268e-02;
        W[0] = (( 1.9623264149430e-01*RT-4.9695241464490e-01)*RT -
            6.0156581186481e-05)*exp(-T)+W[0]-W[1]-W[2]-W[3];
    } else if ( T <= 35.e0 ) {
	RT = 1.e0 / T;
        W[0] = sqrt(PIE4*RT);
        E = exp(-T);
        U[0] = ((((((-4.45711399441838e-05*T+1.27267770241379e-03)*T -
            2.36954961381262e-01)*T+1.54330657903756e+01)*T -
            5.22799159267808e+02)*T+1.05951216669313e+04)*T + (-
            2.51177235556236e+06*RT+8.72975373557709e+05)*RT -
            1.29194382386499e+05)*E + R14/(T-R14);
        U[1] = (((((-7.85617372254488e-02*T+6.35653573484868e+00)*T -
            3.38296938763990e+02)*T+1.25120495802096e+04)*T -
            3.16847570511637e+05)*T + ((-1.02427466127427e+09*RT +
            3.70104713293016e+08)*RT-5.87119005093822e+07)*RT +
            5.38614211391604e+06)*E + R24/(T-R24);
        U[2] = (((((-2.37900485051067e-01*T+1.84122184400896e+01)*T -
            1.00200731304146e+03)*T+3.75151841595736e+04)*T -
            9.50626663390130e+05)*T + ((-2.88139014651985e+09*RT +
            1.06625915044526e+09)*RT-1.72465289687396e+08)*RT +
            1.60419390230055e+07)*E + R34/(T-R34);
        U[3] = ((((((-6.00691586407385e-04*T-3.64479545338439e-01)*T +
            1.57496131755179e+01)*T-6.54944248734901e+02)*T +
            1.70830039597097e+04)*T-2.90517939780207e+05)*T + (+
            3.49059698304732e+07*RT-1.64944522586065e+07)*RT +
            2.96817940164703e+06)*E + R44/(T-R44);
        if ( T <= 25.0e+00 ) {
	    W[3] = ((((((( 2.33766206773151e-07*T-
            3.81542906607063e-05)*T +3.51416601267000e-03)*T-
            1.66538571864728e-01)*T +4.80006136831847e+00)*T-
            8.73165934223603e+01)*T +9.77683627474638e+02)*T +
            1.66000945117640e+04*RT -6.14479071209961e+03)*E + W44*W[0];
	} else {
	    W[3] = (((((( 5.74245945342286e-06*T-
            7.58735928102351e-05)*T +2.35072857922892e-04)*T-
            3.78812134013125e-03)*T +3.09871652785805e-01)*T-
            7.11108633061306e+00)*T +5.55297573149528e+01)*E + W44*W[0];
	}
        W[2] = (((((( 2.36392855180768e-04*T-9.16785337967013e-03)*T +
            4.62186525041313e-01)*T-1.96943786006540e+01)*T +
            4.99169195295559e+02)*T-6.21419845845090e+03)*T + ((+
            5.21445053212414e+07*RT-1.34113464389309e+07)*RT +
            1.13673298305631e+06)*RT-2.81501182042707e+03)*E + W34*W[0];
        W[1] = (((((( 7.29841848989391e-04*T-3.53899555749875e-02)*T +
            2.07797425718513e+00)*T-1.00464709786287e+02)*T +
            3.15206108877819e+03)*T-6.27054715090012e+04)*T + (+
            1.54721246264919e+07*RT-5.26074391316381e+06)*RT +
            7.67135400969617e+05)*E + W24*W[0];
        W[0] = (( 1.9623264149430e-01*RT-4.9695241464490e-01)*RT -
            6.0156581186481e-05)*E + W[0]-W[1]-W[2]-W[3];
    } else if ( T <= 53.e0 ) {
        W[0] = sqrt(PIE4/T);
        E = exp(-T)*(T*T*T*T);
        U[3] = ((-2.19135070169653e-03*T-1.19108256987623e-01)*T -
            7.50238795695573e-01)*E + R44/(T-R44);
        U[2] = ((-9.65842534508637e-04*T-4.49822013469279e-02)*T +
            6.08784033347757e-01)*E + R34/(T-R34);
        U[1] = ((-3.62569791162153e-04*T-9.09231717268466e-03)*T +
            1.84336760556262e-01)*E + R24/(T-R24);
        U[0] = ((-4.07557525914600e-05*T-6.88846864931685e-04)*T +
            1.74725309199384e-02)*E + R14/(T-R14);
        W[3] = (( 5.76631982000990e-06*T-7.89187283804890e-05)*T +
            3.28297971853126e-04)*E + W44*W[0];
        W[2] = (( 2.08294969857230e-04*T-3.77489954837361e-03)*T +
            2.09857151617436e-02)*E + W34*W[0];
        W[1] = (( 6.16374517326469e-04*T-1.26711744680092e-02)*T +
            8.14504890732155e-02)*E + W24*W[0];
        W[0] = W[0]-W[1]-W[2]-W[3];
    } else {
        W[0] = sqrt(PIE4/T);
        U[0] = R14/(T-R14);
        U[1] = R24/(T-R24);
        U[2] = R34/(T-R34);
        U[3] = R44/(T-R44);
        W[3] = W44*W[0];
        W[2] = W34*W[0];
        W[1] = W24*W[0];
        W[0] = W[0]-W[1]-W[2]-W[3];
    }
}

__device__ void gpu_root5( const double T, double U[], double W[] ) {
    double Y, E, TTT;
    if ( T <= 3.e-7 ) {
        U[0] = 2.26659266316985e-02 -2.15865967920897e-03 *T;
        U[1] = 2.31271692140903e-01 -2.20258754389745e-02 *T;
        U[2] = 8.57346024118836e-01 -8.16520023025515e-02 *T;
        U[3] = 2.97353038120346e+00 -2.83193369647137e-01 *T;
        U[4] = 1.84151859759051e+01 -1.75382723579439e+00 *T;
        W[0] = 2.95524224714752e-01 -1.96867576909777e-02 *T;
        W[1] = 2.69266719309995e-01 -5.61737590184721e-02 *T;
        W[2] = 2.19086362515981e-01 -9.71152726793658e-02 *T;
        W[3] = 1.49451349150580e-01 -1.02979262193565e-01 *T;
        W[4] = 6.66713443086877e-02 -5.73782817488315e-02 *T;
    } else if ( T <= 1.e0 ) {
        U[0] = ((((((-4.46679165328413e-11*T+1.21879111988031e-09)*T-
            2.62975022612104e-08 )*T+5.15106194905897e-07 )*T-
            9.27933625824749e-06 )*T+1.51794097682482e-04 )*T-
            2.15865967920301e-03 )*T+2.26659266316985e-02;
        U[1] = (((((( 1.93117331714174e-10*T-4.57267589660699e-09)*T+
            2.48339908218932e-08 )*T+1.50716729438474e-06 )*T-
            6.07268757707381e-05 )*T+1.37506939145643e-03 )*T-
            2.20258754419939e-02 )*T+2.31271692140905e-01;
        U[2] = ((((( 4.84989776180094e-09*T+1.31538893944284e-07)*T-
            2.766753852879e-06)*T-7.651163510626e-05)*T+
            4.033058545972e-03)*T-8.16520022916145e-02 )*T+
            8.57346024118779e-01;
        U[3] = ((((-2.48581772214623e-07*T-4.34482635782585e-06)*T-
            7.46018257987630e-07 )*T+1.01210776517279e-02 )*T-
            2.83193369640005e-01 )*T+2.97353038120345e+00;
        U[4] = (((((-8.92432153868554e-09*T+1.77288899268988e-08)*T+
            3.040754680666e-06)*T+1.058229325071e-04)*T+
            4.596379534985e-02)*T-1.75382723579114e+00 )*T+
            1.84151859759049e+01;
        W[0] = ((((((-2.03822632771791e-09*T+3.89110229133810e-08)*T-
            5.84914787904823e-07 )*T+8.30316168666696e-06 )*T-
            1.13218402310546e-04 )*T+1.49128888586790e-03 )*T-
            1.96867576904816e-02 )*T+2.95524224714749e-01;
        W[1] = ((((((( 8.62848118397570e-09*T-1.38975551148989e-07)*T+
            1.602894068228e-06)*T-1.646364300836e-05)*T+
            1.538445806778e-04)*T-1.28848868034502e-03 )*T+
            9.38866933338584e-03 )*T-5.61737590178812e-02 )*T+
            2.69266719309991e-01;
        W[2] = ((((((((-9.41953204205665e-09*T+1.47452251067755e-07)*T-
            1.57456991199322e-06 )*T+1.45098401798393e-05 )*T-
            1.18858834181513e-04 )*T+8.53697675984210e-04 )*T-
            5.22877807397165e-03 )*T+2.60854524809786e-02 )*T-
            9.71152726809059e-02 )*T+2.19086362515979e-01;
        W[3] = ((((((((-3.84961617022042e-08*T+5.66595396544470e-07)*T-
            5.52351805403748e-06 )*T+4.53160377546073e-05 )*T-
            3.22542784865557e-04 )*T+1.95682017370967e-03 )*T-
            9.77232537679229e-03 )*T+3.79455945268632e-02 )*T-
            1.02979262192227e-01 )*T+1.49451349150573e-01;
        W[4] = ((((((((( 4.09594812521430e-09*T-6.47097874264417e-08)*T+
            6.743541482689e-07)*T-5.917993920224e-06)*T+
            4.531969237381e-05)*T-2.99102856679638e-04 )*T+
            1.65695765202643e-03 )*T-7.40671222520653e-03 )*T+
            2.50889946832192e-02 )*T-5.73782817487958e-02 )*T+
            6.66713443086877e-02;
    } else if ( T <= 5.e0 ) {
        Y = T-3.0e+00;
        U[0] = ((((((((-2.58163897135138e-14*Y+8.14127461488273e-13)*Y-
            2.11414838976129e-11 )*Y+5.09822003260014e-10 )*Y-
            1.16002134438663e-08 )*Y+2.46810694414540e-07 )*Y-
            4.92556826124502e-06 )*Y+9.02580687971053e-05 )*Y-
            1.45190025120726e-03 )*Y+1.73416786387475e-02;
        U[1] = ((((((((( 1.04525287289788e-14*Y+5.44611782010773e-14)*Y-
            4.831059411392e-12)*Y+1.136643908832e-10)*Y-
            1.104373076913e-09)*Y-2.35346740649916e-08 )*Y+
            1.43772622028764e-06 )*Y-4.23405023015273e-05 )*Y+
            9.12034574793379e-04 )*Y-1.52479441718739e-02 )*Y+
            1.76055265928744e-01;
        U[2] = (((((((((-6.89693150857911e-14*Y+5.92064260918861e-13)*Y+
            1.847170956043e-11)*Y-3.390752744265e-10)*Y-
            2.995532064116e-09)*Y+1.57456141058535e-07 )*Y-
            3.95859409711346e-07 )*Y-9.58924580919747e-05 )*Y+
            3.23551502557785e-03 )*Y-5.97587007636479e-02 )*Y+
            6.46432853383057e-01;
        U[3] = ((((((((-3.61293809667763e-12*Y-2.70803518291085e-11)*Y+
            8.83758848468769e-10 )*Y+1.59166632851267e-08 )*Y-
            1.32581997983422e-07 )*Y-7.60223407443995e-06 )*Y-
            7.41019244900952e-05 )*Y+9.81432631743423e-03 )*Y-
            2.23055570487771e-01 )*Y+2.21460798080643e+00;
        U[4] = ((((((((( 7.12332088345321e-13*Y+3.16578501501894e-12)*Y-
            8.776668218053e-11)*Y-2.342817613343e-09)*Y-
            3.496962018025e-08)*Y-3.03172870136802e-07 )*Y+
            1.50511293969805e-06 )*Y+1.37704919387696e-04 )*Y+
            4.70723869619745e-02 )*Y-1.47486623003693e+00 )*Y+
            1.35704792175847e+01;
        W[0] = ((((((((( 1.04348658616398e-13*Y-1.94147461891055e-12)*Y+
            3.485512360993e-11)*Y-6.277497362235e-10)*Y+
            1.100758247388e-08)*Y-1.88329804969573e-07 )*Y+
            3.12338120839468e-06 )*Y-5.04404167403568e-05 )*Y+
            8.00338056610995e-04 )*Y-1.30892406559521e-02 )*Y+
            2.47383140241103e-01;
        W[1] = ((((((((((( 3.23496149760478e-14*Y-5.24314473469311e-13)*Y+
            7.743219385056e-12)*Y-1.146022750992e-10)*Y+
            1.615238462197e-09)*Y-2.15479017572233e-08 )*Y+
            2.70933462557631e-07 )*Y-3.18750295288531e-06 )*Y+
            3.47425221210099e-05 )*Y-3.45558237388223e-04 )*Y+
            3.05779768191621e-03 )*Y-2.29118251223003e-02 )*Y+
            1.59834227924213e-01;
        W[2] = ((((((((((((-3.42790561802876e-14*Y+5.26475736681542e-13)*Y-
            7.184330797139e-12)*Y+9.763932908544e-11)*Y-
            1.244014559219e-09)*Y+1.472744068942e-08)*Y-
            1.611749975234e-07)*Y+1.616487851917e-06)*Y-
            1.46852359124154e-05 )*Y+1.18900349101069e-04 )*Y-
            8.37562373221756e-04 )*Y+4.93752683045845e-03 )*Y-
            2.25514728915673e-02 )*Y+6.95211812453929e-02;
        W[3] = ((((((((((((( 1.04072340345039e-14*Y-1.60808044529211e-13)*
            Y+2.183534866798e-12)*Y-2.939403008391e-11)*Y+
            3.679254029085e-10)*Y-4.23775673047899e-09 )*Y+
            4.46559231067006e-08 )*Y-4.26488836563267e-07 )*Y+
            3.64721335274973e-06 )*Y-2.74868382777722e-05 )*Y+
            1.78586118867488e-04 )*Y-9.68428981886534e-04 )*Y+
            4.16002324339929e-03 )*Y-1.28290192663141e-02 )*Y+
            2.22353727685016e-02;
        W[4] = ((((((((((((((-8.16770412525963e-16*Y+1.31376515047977e-14)*
            Y-1.856950818865e-13)*Y+2.596836515749e-12)*Y-
            3.372639523006e-11)*Y+4.025371849467e-10)*Y-
            4.389453269417e-09)*Y+4.332753856271e-08)*Y-
            3.82673275931962e-07 )*Y+2.98006900751543e-06 )*Y-
            2.00718990300052e-05 )*Y+1.13876001386361e-04 )*Y-
            5.23627942443563e-04 )*Y+1.83524565118203e-03 )*Y-
            4.37785737450783e-03 )*Y+5.36963805223095e-03;
    } else if ( T <= 10.e0 ) {
        Y = T-7.5e+00;
        U[0] = ((((((((-1.13825201010775e-14*Y+1.89737681670375e-13)*Y-
            4.81561201185876e-12 )*Y+1.56666512163407e-10 )*Y-
            3.73782213255083e-09 )*Y+9.15858355075147e-08 )*Y-
            2.13775073585629e-06 )*Y+4.56547356365536e-05 )*Y-
            8.68003909323740e-04 )*Y+1.22703754069176e-02;
        U[1] = (((((((((-3.67160504428358e-15*Y+1.27876280158297e-14)*Y-
            1.296476623788e-12)*Y+1.477175434354e-11)*Y+
            5.464102147892e-10)*Y-2.42538340602723e-08 )*Y+
            8.20460740637617e-07 )*Y-2.20379304598661e-05 )*Y+
            4.90295372978785e-04 )*Y-9.14294111576119e-03 )*Y+
            1.22590403403690e-01;
        U[2] = ((((((((( 1.39017367502123e-14*Y-6.96391385426890e-13)*Y+
            1.176946020731e-12)*Y+1.725627235645e-10)*Y-
            3.686383856300e-09)*Y+2.87495324207095e-08 )*Y+
            1.71307311000282e-06 )*Y-7.94273603184629e-05 )*Y+
            2.00938064965897e-03 )*Y-3.63329491677178e-02 )*Y+
            4.34393683888443e-01;
        U[3] = ((((((((((-1.27815158195209e-14*Y+1.99910415869821e-14)*Y+
            3.753542914426e-12)*Y-2.708018219579e-11)*Y-
            1.190574776587e-09)*Y+1.106696436509e-08)*Y+
            3.954955671326e-07)*Y-4.398596059588e-06)*Y-
            2.01087998907735e-04 )*Y+7.89092425542937e-03 )*Y-
            1.42056749162695e-01 )*Y+1.39964149420683e+00;
        U[4] = ((((((((((-1.19442341030461e-13*Y-2.34074833275956e-12)*Y+
            6.861649627426e-12)*Y+6.082671496226e-10)*Y+
            5.381160105420e-09)*Y-6.253297138700e-08)*Y-
            2.135966835050e-06)*Y-2.373394341886e-05)*Y+
            2.88711171412814e-06 )*Y+4.85221195290753e-02 )*Y-
            1.04346091985269e+00 )*Y+7.89901551676692e+00;
        W[0] = ((((((((( 7.95526040108997e-15*Y-2.48593096128045e-13)*Y+
            4.761246208720e-12)*Y-9.535763686605e-11)*Y+
            2.225273630974e-09)*Y-4.49796778054865e-08 )*Y+
            9.17812870287386e-07 )*Y-1.86764236490502e-05 )*Y+
            3.76807779068053e-04 )*Y-8.10456360143408e-03 )*Y+
            2.01097936411496e-01;
        W[1] = ((((((((((( 1.25678686624734e-15*Y-2.34266248891173e-14)*Y+
            3.973252415832e-13)*Y-6.830539401049e-12)*Y+
            1.140771033372e-10)*Y-1.82546185762009e-09 )*Y+
            2.77209637550134e-08 )*Y-4.01726946190383e-07 )*Y+
            5.48227244014763e-06 )*Y-6.95676245982121e-05 )*Y+
            8.05193921815776e-04 )*Y-8.15528438784469e-03 )*Y+
            9.71769901268114e-02;
        W[2] = ((((((((((((-8.20929494859896e-16*Y+1.37356038393016e-14)*Y-
            2.022863065220e-13)*Y+3.058055403795e-12)*Y-
            4.387890955243e-11)*Y+5.923946274445e-10)*Y-
            7.503659964159e-09)*Y+8.851599803902e-08)*Y-
            9.65561998415038e-07 )*Y+9.60884622778092e-06 )*Y-
            8.56551787594404e-05 )*Y+6.66057194311179e-04 )*Y-
            4.17753183902198e-03 )*Y+2.25443826852447e-02;
        W[3] = ((((((((((((((-1.08764612488790e-17*Y+1.85299909689937e-16)*
            Y-2.730195628655e-15)*Y+4.127368817265e-14)*Y-
            5.881379088074e-13)*Y+7.805245193391e-12)*Y-
            9.632707991704e-11)*Y+1.099047050624e-09)*Y-
            1.15042731790748e-08 )*Y+1.09415155268932e-07 )*Y-
            9.33687124875935e-07 )*Y+7.02338477986218e-06 )*Y-
            4.53759748787756e-05 )*Y+2.41722511389146e-04 )*Y-
            9.75935943447037e-04 )*Y+2.57520532789644e-03;
        W[4] = ((((((((((((((( 7.28996979748849e-19*Y-1.26518146195173e-17)
            *Y+1.886145834486e-16)*Y-2.876728287383e-15)*Y+
            4.114588668138e-14)*Y-5.44436631413933e-13 )*Y+
            6.64976446790959e-12 )*Y-7.44560069974940e-11 )*Y+
            7.57553198166848e-10 )*Y-6.92956101109829e-09 )*Y+
            5.62222859033624e-08 )*Y-3.97500114084351e-07 )*Y+
            2.39039126138140e-06 )*Y-1.18023950002105e-05 )*Y+
            4.52254031046244e-05 )*Y-1.21113782150370e-04 )*Y+
            1.75013126731224e-04;
    } else if ( T <= 15.e0 ) {
        Y = T-12.5e+00;
        U[0] = ((((((((((-4.16387977337393e-17*Y+7.20872997373860e-16)*Y+
            1.395993802064e-14)*Y+3.660484641252e-14)*Y-
            4.154857548139e-12)*Y+2.301379846544e-11)*Y-
            1.033307012866e-09)*Y+3.997777641049e-08)*Y-
            9.35118186333939e-07 )*Y+2.38589932752937e-05 )*Y-
            5.35185183652937e-04 )*Y+8.85218988709735e-03;
        U[1] = ((((((((((-4.56279214732217e-16*Y+6.24941647247927e-15)*Y+
            1.737896339191e-13)*Y+8.964205979517e-14)*Y-
            3.538906780633e-11)*Y+9.561341254948e-11)*Y-
            9.772831891310e-09)*Y+4.240340194620e-07)*Y-
            1.02384302866534e-05 )*Y+2.57987709704822e-04 )*Y-
            5.54735977651677e-03 )*Y+8.68245143991948e-02;
        U[2] = ((((((((((-2.52879337929239e-15*Y+2.13925810087833e-14)*Y+
            7.884307667104e-13)*Y-9.023398159510e-13)*Y-
            5.814101544957e-11)*Y-1.333480437968e-09)*Y-
            2.217064940373e-08)*Y+1.643290788086e-06)*Y-
            4.39602147345028e-05 )*Y+1.08648982748911e-03 )*Y-
            2.13014521653498e-02 )*Y+2.94150684465425e-01;
        U[3] = ((((((((((-6.42391438038888e-15*Y+5.37848223438815e-15)*Y+
            8.960828117859e-13)*Y+5.214153461337e-11)*Y-
            1.106601744067e-10)*Y-2.007890743962e-08)*Y+
            1.543764346501e-07)*Y+4.520749076914e-06)*Y-
            1.88893338587047e-04 )*Y+4.73264487389288e-03 )*Y-
            7.91197893350253e-02 )*Y+8.60057928514554e-01;
        U[4] = (((((((((((-2.24366166957225e-14*Y+4.87224967526081e-14)*Y+
            5.587369053655e-12)*Y-3.045253104617e-12)*Y-
            1.223983883080e-09)*Y-2.05603889396319e-09 )*Y+
            2.58604071603561e-07 )*Y+1.34240904266268e-06 )*Y-
            5.72877569731162e-05 )*Y-9.56275105032191e-04 )*Y+
            4.23367010370921e-02 )*Y-5.76800927133412e-01 )*Y+
            3.87328263873381e+00;
        W[0] = ((((((((( 8.98007931950169e-15*Y+7.25673623859497e-14)*Y+
            5.851494250405e-14)*Y-4.234204823846e-11)*Y+
            3.911507312679e-10)*Y-9.65094802088511e-09 )*Y+
            3.42197444235714e-07 )*Y-7.51821178144509e-06 )*Y+
            1.94218051498662e-04 )*Y-5.38533819142287e-03 )*Y+
            1.68122596736809e-01;
        W[1] = ((((((((((-1.05490525395105e-15*Y+1.96855386549388e-14)*Y-
            5.500330153548e-13)*Y+1.003849567976e-11)*Y-
            1.720997242621e-10)*Y+3.533277061402e-09)*Y-
            6.389171736029e-08)*Y+1.046236652393e-06)*Y-
            1.73148206795827e-05 )*Y+2.57820531617185e-04 )*Y-
            3.46188265338350e-03 )*Y+7.03302497508176e-02;
        W[2] = ((((((((((( 3.60020423754545e-16*Y-6.24245825017148e-15)*Y+
            9.945311467434e-14)*Y-1.749051512721e-12)*Y+
            2.768503957853e-11)*Y-4.08688551136506e-10 )*Y+
            6.04189063303610e-09 )*Y-8.23540111024147e-08 )*Y+
            1.01503783870262e-06 )*Y-1.20490761741576e-05 )*Y+
            1.26928442448148e-04 )*Y-1.05539461930597e-03 )*Y+
            1.15543698537013e-02;
        W[3] = ((((((((((((( 2.51163533058925e-18*Y-4.31723745510697e-17)*
            Y+6.557620865832e-16)*Y-1.016528519495e-14)*Y+
            1.491302084832e-13)*Y-2.06638666222265e-12 )*Y+
            2.67958697789258e-11 )*Y-3.23322654638336e-10 )*Y+
            3.63722952167779e-09 )*Y-3.75484943783021e-08 )*Y+
            3.49164261987184e-07 )*Y-2.92658670674908e-06 )*Y+
            2.12937256719543e-05 )*Y-1.19434130620929e-04 )*Y+
            6.45524336158384e-04;
        W[4] = ((((((((((((((-1.29043630202811e-19*Y+2.16234952241296e-18)*
            Y-3.107631557965e-17)*Y+4.570804313173e-16)*Y-
            6.301348858104e-15)*Y+8.031304476153e-14)*Y-
            9.446196472547e-13)*Y+1.018245804339e-11)*Y-
            9.96995451348129e-11 )*Y+8.77489010276305e-10 )*Y-
            6.84655877575364e-09 )*Y+4.64460857084983e-08 )*Y-
            2.66924538268397e-07 )*Y+1.24621276265907e-06 )*Y-
            4.30868944351523e-06 )*Y+9.94307982432868e-06;
    } else if ( T <= 20.e0 ) {
        Y = T-17.5e+00;
        U[0] = (((((((((( 1.91875764545740e-16*Y+7.8357401095707e-16)*Y-
            3.260875931644e-14)*Y-1.186752035569e-13)*Y+
            4.275180095653e-12)*Y+3.357056136731e-11)*Y-
            1.123776903884e-09)*Y+1.231203269887e-08)*Y-
            3.99851421361031e-07 )*Y+1.45418822817771e-05 )*Y-
            3.49912254976317e-04 )*Y+6.67768703938812e-03;
        U[1] = (((((((((( 2.02778478673555e-15*Y+1.01640716785099e-14)*Y-
            3.385363492036e-13)*Y-1.615655871159e-12)*Y+
            4.527419140333e-11)*Y+3.853670706486e-10)*Y-
            1.184607130107e-08)*Y+1.347873288827e-07)*Y-
            4.47788241748377e-06 )*Y+1.54942754358273e-04 )*Y-
            3.55524254280266e-03 )*Y+6.44912219301603e-02;
        U[2] = (((((((((( 7.79850771456444e-15*Y+6.00464406395001e-14)*Y-
            1.249779730869e-12)*Y-1.020720636353e-11)*Y+
            1.814709816693e-10)*Y+1.766397336977e-09)*Y-
            4.603559449010e-08)*Y+5.863956443581e-07)*Y-
            2.03797212506691e-05 )*Y+6.31405161185185e-04 )*Y-
            1.30102750145071e-02 )*Y+2.10244289044705e-01;
        U[3] = (((((((((((-2.92397030777912e-15*Y+1.94152129078465e-14)*Y+
            4.859447665850e-13)*Y-3.217227223463e-12)*Y-
            7.484522135512e-11)*Y+7.19101516047753e-10 )*Y+
            6.88409355245582e-09 )*Y-1.44374545515769e-07 )*Y+
            2.74941013315834e-06 )*Y-1.02790452049013e-04 )*Y+
            2.59924221372643e-03 )*Y-4.35712368303551e-02 )*Y+
            5.62170709585029e-01;
        U[4] = ((((((((((( 1.17976126840060e-14*Y+1.24156229350669e-13)*Y-
            3.892741622280e-12)*Y-7.755793199043e-12)*Y+
            9.492190032313e-10)*Y-4.98680128123353e-09 )*Y-
            1.81502268782664e-07 )*Y+2.69463269394888e-06 )*Y+
            2.50032154421640e-05 )*Y-1.33684303917681e-03 )*Y+
            2.29121951862538e-02 )*Y-2.45653725061323e-01 )*Y+
            1.89999883453047e+00;
        W[0] = (((((((((( 1.74841995087592e-15*Y-6.95671892641256e-16)*Y-
            3.000659497257e-13)*Y+2.021279817961e-13)*Y+
            3.853596935400e-11)*Y+1.461418533652e-10)*Y-
            1.014517563435e-08)*Y+1.132736008979e-07)*Y-
            2.86605475073259e-06 )*Y+1.21958354908768e-04 )*Y-
            3.86293751153466e-03 )*Y+1.45298342081522e-01;
        W[1] = ((((((((((-1.11199320525573e-15*Y+1.85007587796671e-15)*Y+
            1.220613939709e-13)*Y+1.275068098526e-12)*Y-
            5.341838883262e-11)*Y+6.161037256669e-10)*Y-
            1.009147879750e-08)*Y+2.907862965346e-07)*Y-
            6.12300038720919e-06 )*Y+1.00104454489518e-04 )*Y-
            1.80677298502757e-03 )*Y+5.78009914536630e-02;
        W[2] = ((((((((((-9.49816486853687e-16*Y+6.67922080354234e-15)*Y+
            2.606163540537e-15)*Y+1.983799950150e-12)*Y-
            5.400548574357e-11)*Y+6.638043374114e-10)*Y-
            8.799518866802e-09)*Y+1.791418482685e-07)*Y-
            2.96075397351101e-06 )*Y+3.38028206156144e-05 )*Y-
            3.58426847857878e-04 )*Y+8.39213709428516e-03;
        W[3] = ((((((((((( 1.33829971060180e-17*Y-3.44841877844140e-16)*Y+
            4.745009557656e-15)*Y-6.033814209875e-14)*Y+
            1.049256040808e-12)*Y-1.70859789556117e-11 )*Y+
            2.15219425727959e-10 )*Y-2.52746574206884e-09 )*Y+
            3.27761714422960e-08 )*Y-3.90387662925193e-07 )*Y+
            3.46340204593870e-06 )*Y-2.43236345136782e-05 )*Y+
            3.54846978585226e-04;
        W[4] = ((((((((((((( 2.69412277020887e-20*Y-4.24837886165685e-19)*
            Y+6.030500065438e-18)*Y-9.069722758289e-17)*Y+
            1.246599177672e-15)*Y-1.56872999797549e-14 )*Y+
            1.87305099552692e-13 )*Y-2.09498886675861e-12 )*Y+
            2.11630022068394e-11 )*Y-1.92566242323525e-10 )*Y+
            1.62012436344069e-09 )*Y-1.23621614171556e-08 )*Y+
            7.72165684563049e-08 )*Y-3.59858901591047e-07 )*Y+
            2.43682618601000e-06;
    } else if ( T <= 25.e0 ) {
        Y = T-22.5e+00;
        U[0] = (((((((((-1.13927848238726e-15*Y+7.39404133595713e-15)*Y+
            1.445982921243e-13)*Y-2.676703245252e-12)*Y+
            5.823521627177e-12)*Y+2.17264723874381e-10 )*Y+
            3.56242145897468e-09 )*Y-3.03763737404491e-07 )*Y+
            9.46859114120901e-06 )*Y-2.30896753853196e-04 )*Y+
            5.24663913001114e-03;
        U[1] = (((((((((( 2.89872355524581e-16*Y-1.22296292045864e-14)*Y+
            6.184065097200e-14)*Y+1.649846591230e-12)*Y-
            2.729713905266e-11)*Y+3.709913790650e-11)*Y+
            2.216486288382e-09)*Y+4.616160236414e-08)*Y-
            3.32380270861364e-06 )*Y+9.84635072633776e-05 )*Y-
            2.30092118015697e-03 )*Y+5.00845183695073e-02;
        U[2] = (((((((((( 1.97068646590923e-15*Y-4.89419270626800e-14)*Y+
            1.136466605916e-13)*Y+7.546203883874e-12)*Y-
            9.635646767455e-11)*Y-8.295965491209e-11)*Y+
            7.534109114453e-09)*Y+2.699970652707e-07)*Y-
            1.42982334217081e-05 )*Y+3.78290946669264e-04 )*Y-
            8.03133015084373e-03 )*Y+1.58689469640791e-01;
        U[3] = (((((((((( 1.33642069941389e-14*Y-1.55850612605745e-13)*Y-
            7.522712577474e-13)*Y+3.209520801187e-11)*Y-
            2.075594313618e-10)*Y-2.070575894402e-09)*Y+
            7.323046997451e-09)*Y+1.851491550417e-06)*Y-
            6.37524802411383e-05 )*Y+1.36795464918785e-03 )*Y-
            2.42051126993146e-02 )*Y+3.97847167557815e-01;
        U[4] = ((((((((((-6.07053986130526e-14*Y+1.04447493138843e-12)*Y-
            4.286617818951e-13)*Y-2.632066100073e-10)*Y+
            4.804518986559e-09)*Y-1.835675889421e-08)*Y-
            1.068175391334e-06)*Y+3.292234974141e-05)*Y-
            5.94805357558251e-04 )*Y+8.29382168612791e-03 )*Y-
            9.93122509049447e-02 )*Y+1.09857804755042e+00;
        W[0] = (((((((((-9.10338640266542e-15*Y+1.00438927627833e-13)*Y+
            7.817349237071e-13)*Y-2.547619474232e-11)*Y+
            1.479321506529e-10)*Y+1.52314028857627e-09 )*Y+
            9.20072040917242e-09 )*Y-2.19427111221848e-06 )*Y+
            8.65797782880311e-05 )*Y-2.82718629312875e-03 )*Y+
            1.28718310443295e-01;
        W[1] = ((((((((( 5.52380927618760e-15*Y-6.43424400204124e-14)*Y-
            2.358734508092e-13)*Y+8.261326648131e-12)*Y+
            9.229645304956e-11)*Y-5.68108973828949e-09 )*Y+
            1.22477891136278e-07 )*Y-2.11919643127927e-06 )*Y+
            4.23605032368922e-05 )*Y-1.14423444576221e-03 )*Y+
            5.06607252890186e-02;
        W[2] = ((((((((( 3.99457454087556e-15*Y-5.11826702824182e-14)*Y-
            4.157593182747e-14)*Y+4.214670817758e-12)*Y+
            6.705582751532e-11)*Y-3.36086411698418e-09 )*Y+
            6.07453633298986e-08 )*Y-7.40736211041247e-07 )*Y+
            8.84176371665149e-06 )*Y-1.72559275066834e-04 )*Y+
            7.16639814253567e-03;
        W[3] = (((((((((((-2.14649508112234e-18*Y-2.45525846412281e-18)*Y+
            6.126212599772e-16)*Y-8.526651626939e-15)*Y+
            4.826636065733e-14)*Y-3.39554163649740e-13 )*Y+
            1.67070784862985e-11 )*Y-4.42671979311163e-10 )*Y+
            6.77368055908400e-09 )*Y-7.03520999708859e-08 )*Y+
            6.04993294708874e-07 )*Y-7.80555094280483e-06 )*Y+
            2.85954806605017e-04;
        W[4] = ((((((((((((-5.63938733073804e-21*Y+6.92182516324628e-20)*Y-
            1.586937691507e-18)*Y+3.357639744582e-17)*Y-
            4.810285046442e-16)*Y+5.386312669975e-15)*Y-
            6.117895297439e-14)*Y+8.441808227634e-13)*Y-
            1.18527596836592e-11 )*Y+1.36296870441445e-10 )*Y-
            1.17842611094141e-09 )*Y+7.80430641995926e-09 )*Y-
            5.97767417400540e-08 )*Y+1.65186146094969e-06;
    } else if ( T <= 40.e0 ) {
	W[0] = sqrt(PIE4/T);
        E = exp(-T);
        U[0] = ((((((((-1.73363958895356e-06*T+1.19921331441483e-04)*T -
            1.59437614121125e-02)*T+1.13467897349442e+00)*T -
            4.47216460864586e+01)*T+1.06251216612604e+03)*T -
            1.52073917378512e+04)*T+1.20662887111273e+05)*T -
            4.07186366852475e+05)*E + R15/(T-R15);
        U[1] = ((((((((-1.60102542621710e-05*T+1.10331262112395e-03)*T -
            1.50043662589017e-01)*T+1.05563640866077e+01)*T -
            4.10468817024806e+02)*T+9.62604416506819e+03)*T -
            1.35888069838270e+05)*T+1.06107577038340e+06)*T -
            3.51190792816119e+06)*E + R25/(T-R25);
        U[2] = ((((((((-4.48880032128422e-05*T+2.69025112122177e-03)*T -
            4.01048115525954e-01)*T+2.78360021977405e+01)*T -
            1.04891729356965e+03)*T+2.36985942687423e+04)*T -
            3.19504627257548e+05)*T+2.34879693563358e+06)*T -
            7.16341568174085e+06)*E + R35/(T-R35);
        U[3] = ((((((((-6.38526371092582e-05*T-2.29263585792626e-03)*T -
            7.65735935499627e-02)*T+9.12692349152792e+00)*T -
            2.32077034386717e+02)*T+2.81839578728845e+02)*T +
            9.59529683876419e+04)*T-1.77638956809518e+06)*T +
            1.02489759645410e+07)*E + R45/(T-R45);
        U[4] = ((((((((-3.59049364231569e-05*T-2.25963977930044e-02)*T +
            1.12594870794668e+00)*T-4.56752462103909e+01)*T +
            1.05804526830637e+03)*T-1.16003199605875e+04)*T -
            4.07297627297272e+04)*T+2.22215528319857e+06)*T -
            1.61196455032613e+07)*E + R55/(T-R55);
        W[4] = (((((((((-4.61100906133970e-10*T+1.43069932644286e-07)*T -
            1.63960915431080e-05)*T+1.15791154612838e-03)*T -
            5.30573476742071e-02)*T+1.61156533367153e+00)*T -
            3.23248143316007e+01)*T+4.12007318109157e+02)*T -
            3.02260070158372e+03)*T+9.71575094154768e+03)*E + W55*W[0];
        W[3] = (((((((((-2.40799435809950e-08*T+8.12621667601546e-06)*T -
            9.04491430884113e-04)*T+6.37686375770059e-02)*T -
            2.96135703135647e+00)*T+9.15142356996330e+01)*T -
            1.86971865249111e+03)*T+2.42945528916947e+04)*T -
            1.81852473229081e+05)*T+5.96854758661427e+05)*E + W45*W[0];
        W[2] = (((((((( 1.83574464457207e-05*T-1.54837969489927e-03)*T +
            1.18520453711586e-01)*T-6.69649981309161e+00)*T +
            2.44789386487321e+02)*T-5.68832664556359e+03)*T +
            8.14507604229357e+04)*T-6.55181056671474e+05)*T +
            2.26410896607237e+06)*E + W35*W[0];
        W[1] = (((((((( 2.77778345870650e-05*T-2.22835017655890e-03)*T +
            1.61077633475573e-01)*T-8.96743743396132e+00)*T +
            3.28062687293374e+02)*T-7.65722701219557e+03)*T +
            1.10255055017664e+05)*T-8.92528122219324e+05)*T +
            3.10638627744347e+06)*E + W25*W[0];
        W[0] = W[0]-0.01962e+00*E-W[1]-W[2]-W[3]-W[4];
    } else if ( T <= 59.e0 ) {
	W[0] = sqrt(PIE4/T);
        TTT = T*T*T;
	E = TTT*exp(-T);
        U[0] = (((-2.43758528330205e-02*T+2.07301567989771e+00)*T -
            6.45964225381113e+01)*T+7.14160088655470e+02)*E + R15/(T-R15);
        U[1] = (((-2.28861955413636e-01*T+1.93190784733691e+01)*T -
            5.99774730340912e+02)*T+6.61844165304871e+03)*E + R25/(T-R25);
        U[2] = (((-6.95053039285586e-01*T+5.76874090316016e+01)*T -
            1.77704143225520e+03)*T+1.95366082947811e+04)*E + R35/(T-R35);
        U[3] = (((-1.58072809087018e+00*T+1.27050801091948e+02)*T -
            3.86687350914280e+03)*T+4.23024828121420e+04)*E + R45/(T-R45);
        U[4] = (((-3.33963830405396e+00*T+2.51830424600204e+02)*T -
            7.57728527654961e+03)*T+8.21966816595690e+04)*E + R55/(T-R55);
        E = TTT * E;
        W[4] = (( 1.35482430510942e-08*T-3.27722199212781e-07)*T +
            2.41522703684296e-06)*E + W55*W[0];
        W[3] = (( 1.23464092261605e-06*T-3.55224564275590e-05)*T +
            3.03274662192286e-04)*E + W45*W[0];
        W[2] = (( 1.34547929260279e-05*T-4.19389884772726e-04)*T +
            3.87706687610809e-03)*E + W35*W[0];
        W[1] = (( 2.09539509123135e-05*T-6.87646614786982e-04)*T +
            6.68743788585688e-03)*E + W25*W[0];
        W[0] = W[0]-W[1]-W[2]-W[3]-W[4];
    } else {
	W[0] = sqrt(PIE4/T);
        U[0] = R15/(T-R15);
        U[1] = R25/(T-R25);
        U[2] = R35/(T-R35);
        U[3] = R45/(T-R45);
        U[4] = R55/(T-R55);
        W[1] = W25*W[0];
        W[2] = W35*W[0];
        W[3] = W45*W[0];
        W[4] = W55*W[0];
        W[0] = W[0]-W[1]-W[2]-W[3]-W[4];
    }
}

/*__device__ void gpu_root6( const int nroot, const double T,
	double U[], double W[] ) {
    double C[14*14], S[14*14], A[14], RT[14], R[13*13];
    double W[13*13], FF[27];
    int nn, n1, n;
    int i, j;
    if ( T >= 64.e0 ) rootsa( nroot, T, U, W );
    else {
	n  = ( nroot<2 ? 2 : nroot );
	n1 = n + 1;
	nn = n + n;
	rysfun( T, nn, FF );
	for ( i=1; i<=n1; i++ ) {
	    for ( j=1; j<=n1; j++ ) {
		S[(i-1)*n1+(j-1)] = FF[i+j-2];
	    }
	}
	ryssmt( C, S, n1 );
}*/

__device__ void gpu_calc_root( const int nroot, const double T,
	double U[], double W[] ) {
    if      ( nroot == 1 ) gpu_root1( T, U, W );
    else if ( nroot == 2 ) gpu_root2( T, U, W );
    else if ( nroot == 3 ) gpu_root3( T, U, W );
    else if ( nroot == 4 ) gpu_root4( T, U, W );
    else if ( nroot == 5 ) gpu_root5( T, U, W );
    //else                   gpu_root6( nroot, T, U, W );
}
#include <stdio.h>
#include <math.h>

#include "cuda-twoint-core.h"
#include "cuda-fmt.h"

#ifndef ZERO
#define ZERO 0.e0
#endif
#ifndef HALF
#define HALF .5e0
#endif
    
/** １つのCS４重対に対して(ss,ss)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_ssss_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double SSSS[1] ) {
//    int ijps, klps, i;
//    double ssss, cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double sqrho, rho, PQ2, T;
//    double PC[3], PQ[3];
    SSSS[0] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
      double zeta, dkab, xiza;
      double PC[3];
	zeta = LDG(vzeta[ijps]);
	dkab = LDG(vdkab[ijps]);
	xiza = LDG(vxiza[ijps]);
#pragma unroll
	for (int i=0; i<3; i++ ) PC[i] = AC[i] + xiza*BA[i];

	for (int klps=0; klps<(*nklps); klps++ ) {
          double eta, dk, xizc;
          double ssss, cssss;
          double sqrho, rho, PQ2, T;
	    eta  = veta[klps];
	    dk   = dkab * LDG(vdkcd[klps]);
	    sqrho = sqrt(1.e0/(zeta+eta));
	    cssss = sqrho * dk;
	    rho   = sqrho*sqrho;
	    xizc = LDG(vxizc[klps]);
//#pragma unroll
//	    for ( i=0; i<3; i++ ) PQ[i] = PC[i] - xizc*DC[i];
//	    PQ2   = PQ[0]*PQ[0] + PQ[1]*PQ[1] + PQ[2]*PQ[2];
//	    T     = rho * PQ2;
	    T = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
              double PQ = PC[i] - xizc*DC[i];
	      T   += PQ*PQ;
            }
	    T     *= rho;
	    gpu_fmt( &ssss, 0, T, cssss );
#if 0
#if   CUDA_FMT_M == 3
	    gpu_fmt0_method3( T, cssss, &ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt0_method2( T, cssss, &ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt0_method1( T, cssss, &ssss );
#else
	    gpu_fmt0( &ssss, T, cssss );
#endif
#endif
	    SSSS[0] += ssss;
	}
    }
}

/** １つのCS４重対に対して(ps,ss)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_psss_(
	 const int *nijps,  const double vzeta[],  const double vdkab[],
	 const double vxiza[],  const double BA[3],
	 const int *nklps,  const double veta[],  const double vdkcd[],
	 const double vxizc[],  const double DC[3],  const double AC[3],
	 double PSSS[3] ) {
    int ijps, klps;
//    double ssss[1+1], cssss, zeta, dkab, xiza, eta, xizc, dk;
    double zeta, dkab, xiza;
//    double rz;
//    double sqrho, rho, PQ2, T;
//    double PC[3], PA[3], WP[3], QP[3];
    double PC[3], PA[3];

#pragma unroll
    for (int i=0; i<3; i++ ) PSSS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
	zeta = LDG(vzeta[ijps]);
	dkab = LDG(vdkab[ijps]);
	xiza = LDG(vxiza[ijps]);
#pragma unroll
	for (int i=0; i<3; i++ ) {
	    PA[i] = xiza * BA[i];
	    PC[i] = AC[i] + PA[i];
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
          double WP[3];
//          double ssss[1+1], cssss, eta, xizc, dk;
          double cssss, eta, xizc, dk;
          double sqrho, rho, T;
          double rz;
	    eta  = LDG(veta[klps]);
	    dk   = dkab * LDG(vdkcd[klps]);
	    xizc = LDG(vxizc[klps]);
	    sqrho = sqrt(1.e0/(zeta+eta));
	    cssss = sqrho * dk;
	    rho   = sqrho*sqrho;
	    rz    = rho * zeta;
            T=ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		double qp = xizc*DC[i] - PC[i];
		WP[i] = rz * qp;
		T  += qp*qp;
	    }
	    T     *= rho;
            {
            double ssss[1+1];
	    //gpu_fmt( ssss, 1, T, cssss );
#if defined(CUDA_FMT_M_K1) && CUDA_ARCH >= 350 && CUDA_FMT_M_NEXP == 6
                        gpu_fmt1_method3( T, cssss, ssss );
#else
#if   CUDA_FMT_M == 3
	    gpu_fmt1_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt1_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt1_method1( T, cssss, ssss );
#else
	    gpu_fmt1( ssss, T, cssss );
#endif
#endif
#pragma unroll
	    for (int i=0; i<3; i++ ) PSSS[i] += PA[i]*ssss[0]+WP[i]*ssss[1];
            }
	}
    }
}

/** １つのCS４重対に対して(ps,ps)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_psps_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double PSPS[3*3]) {
//    int ijps, klps, i, m;
//    double cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double rz, ze2;
//    double sqrho, rho, PQ2, T;
//    double PC[3], PA[3], WP[3], QP[3], QC[3], WQ[3];
    double PC[3], PA[3];
//    double ssss[1+2], psss[1+1][3];
#pragma unroll
    for (int i=0; i<3*3; i++ ) PSPS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
	double zeta = LDG(vzeta[ijps]);
	double dkab = LDG(vdkab[ijps]);
	double xiza = LDG(vxiza[ijps]);
#pragma unroll
	for (int i=0; i<3; i++ ) {
	    PA[i] = xiza * BA[i];
	    PC[i] = AC[i] + PA[i];
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
          double eta, dk, xizc;
          double PQ2;
          double sqrho, rho, rz, ze2;
          double T, cssss;
          double WP[3], QP[3], QC[3], WQ[3];
//          double ssss[1+2], psss[1+1][3];
          double ssss[1+2];
	    eta  = LDG(veta[klps]);
	    dk   = dkab * LDG(vdkcd[klps]);
	    xizc = LDG(vxizc[klps]);
	    sqrho = sqrt(1.e0/(zeta+eta));
	    rho   = sqrho*sqrho;
	    cssss = sqrho * dk;
	    rz    = rho * zeta;
	    ze2   = HALF * rz * eta;
	    T  = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		QC[i] = xizc*DC[i];
		QP[i] = QC[i] - PC[i];
		T  += QP[i]*QP[i];
	    }
	    T     *= rho;
	    //gpu_fmt( ssss, 2, T, cssss );
#if   CUDA_FMT_M == 3
	    gpu_fmt2_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt2_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt2_method1( T, cssss, ssss );
#else
	    gpu_fmt2( ssss, T, cssss );
#endif
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		WP[i]=rz*QP[i];
		WQ[i] = WP[i] - QP[i];
	    }
	    // psss
            /*
#pragma unroll
	    for ( m=0; m<=1; m++ ) {
#pragma unroll
		for ( i=0; i<3; i++ )
		    psss[m][i] = PA[i]*ssss[m]+WP[i]*ssss[m+1];
	    }
	    // psps
	    PSPS[0*3+0] += QC[0]*psss[0][0]+WQ[0]*psss[1][0]+ze2*ssss[1];
	    PSPS[0*3+1] += QC[1]*psss[0][0]+WQ[1]*psss[1][0];
	    PSPS[0*3+2] += QC[2]*psss[0][0]+WQ[2]*psss[1][0];
	    PSPS[1*3+0] += QC[0]*psss[0][1]+WQ[0]*psss[1][1];
	    PSPS[1*3+1] += QC[1]*psss[0][1]+WQ[1]*psss[1][1]+ze2*ssss[1];;
	    PSPS[1*3+2] += QC[2]*psss[0][1]+WQ[2]*psss[1][1];
	    PSPS[2*3+0] += QC[0]*psss[0][2]+WQ[0]*psss[1][2];
	    PSPS[2*3+1] += QC[1]*psss[0][2]+WQ[1]*psss[1][2];
	    PSPS[2*3+2] += QC[2]*psss[0][2]+WQ[2]*psss[1][2]+ze2*ssss[1];;;
            */
            /*
            {
            double d2;
            double d0, d1;
	    d0 = PA[0]*ssss[0]+WP[0]*ssss[1];
	    d1 = PA[0]*ssss[1]+WP[0]*ssss[2];
            d2 = ze2*ssss[1];
	    PSPS[0*3+0] += QC[0]*d0+WQ[0]*d1+d2;
	    PSPS[0*3+1] += QC[1]*d0+WQ[1]*d1;
	    PSPS[0*3+2] += QC[2]*d0+WQ[2]*d1;
	    d0 = PA[1]*ssss[0]+WP[1]*ssss[1];
	    d1 = PA[1]*ssss[1]+WP[1]*ssss[2];
	    PSPS[1*3+0] += QC[0]*d0+WQ[0]*d1;
	    PSPS[1*3+1] += QC[1]*d0+WQ[1]*d1+d2;
	    PSPS[1*3+2] += QC[2]*d0+WQ[2]*d1;
	    d0 = PA[2]*ssss[0]+WP[2]*ssss[1];
	    d1 = PA[2]*ssss[1]+WP[2]*ssss[2];
	    PSPS[2*3+0] += QC[0]*d0+WQ[0]*d1;
	    PSPS[2*3+1] += QC[1]*d0+WQ[1]*d1;
	    PSPS[2*3+2] += QC[2]*d0+WQ[2]*d1+d2;
            }
            */
            {
            double d2 = ze2*ssss[1];
#pragma unroll
            for (int i=0; i<3; i++) {
	      double d0 = PA[i]*ssss[0]+WP[i]*ssss[1];
	      double d1 = PA[i]*ssss[1]+WP[i]*ssss[2];
	      PSPS[i*3+0] += QC[0]*d0+WQ[0]*d1;
	      PSPS[i*3+1] += QC[1]*d0+WQ[1]*d1;
	      PSPS[i*3+2] += QC[2]*d0+WQ[2]*d1;
	      PSPS[i*3+i] += d2;
            }
            }
	}
    }
}

/** １つのCS４重対に対して(pp,ss)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_ppss_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double PPSS[3*3] ) {
//    int ijps, klps, i, m;
//    double cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double rz, zeta2, tmp;
//    double sqrho, rho, PQ2, T;
//    double PC[3], PA[3], WP[3], QP[3];
//    double ssss[1+2], psss[1+1][3];
    double PSSS[3], DSSS[6];
#pragma unroll
    for (int i=0; i<3; i++ ) PSSS[i] = ZERO;
#pragma unroll
    for (int i=0; i<6; i++ ) DSSS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
        double PC[3], PA[3];
	double zeta = LDG(vzeta[ijps]);
	double dkab = LDG(vdkab[ijps]);
	double xiza = LDG(vxiza[ijps]);
	double zeta2 = HALF * zeta;
#pragma unroll
	for (int i=0; i<3; i++ ) {
//	    PC[i] = AC[i] + xiza*BA[i];
//	    PA[i] = xiza * BA[i];
	    PC[i] = AC[i] + (PA[i] = xiza * BA[i]);
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
            double WP[3], QP[3];
            double ssss[1+2];
            double cssss, T;
            double sqrho, rho, rz;
            double PQ2 = ZERO;
	    double eta  = LDG(veta[klps]);
	    double xizc = LDG(vxizc[klps]);
	    double dk   = dkab * LDG(vdkcd[klps]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		QP[i] = xizc*DC[i] - PC[i];
		PQ2  += QP[i]*QP[i];
	    }
	    sqrho = sqrt(1.e0/(zeta+eta));
	    rho   = sqrho*sqrho;
	    rz    = rho * zeta;
#pragma unroll
	    for (int i=0; i<3; i++ ) WP[i]=rz*QP[i];
	    T = rho * PQ2;
	    cssss = sqrho * dk;
	    //gpu_fmt( ssss, 2, T, cssss );
#if   CUDA_FMT_M == 3
	    gpu_fmt2_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt2_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt2_method1( T, cssss, ssss );
#else
	    gpu_fmt2( ssss, T, cssss );
#endif
            /*
	    // psss
#pragma unroll
	    for ( m=0; m<=1; m++ ) {
#pragma unroll
		for ( i=0; i<3; i++ )
		    psss[m][i] = PA[i]*ssss[m]+WP[i]*ssss[m+1];
	    }
#pragma unroll
	    for (i=0; i<3; i++ ) PSSS[i] += psss[0][i];
	    // dsss
	    tmp = ssss[0] - rz*ssss[1];
	    DSSS[0] += PA[0]*psss[0][0] + WP[0]*psss[1][0] + zeta2*tmp;
	    DSSS[1] += PA[1]*psss[0][1] + WP[1]*psss[1][1] + zeta2*tmp;
	    DSSS[2] += PA[2]*psss[0][2] + WP[2]*psss[1][2] + zeta2*tmp;
	    DSSS[3] += PA[0]*psss[0][1] + WP[0]*psss[1][1];
	    DSSS[4] += PA[1]*psss[0][2] + WP[1]*psss[1][2];
	    DSSS[5] += PA[2]*psss[0][0] + WP[2]*psss[1][0];
            */
            /*
            {
	    double tmp = (ssss[0] - rz*ssss[1])*zeta2;
            double d0, d1;
            d0 = PA[0]*ssss[0]+WP[0]*ssss[0+1];
            d1 = PA[0]*ssss[1]+WP[0]*ssss[1+1];
            PSSS[0] += d0;
	    DSSS[0] += PA[0]*d0 + WP[0]*d1 + tmp;
	    DSSS[5] += PA[2]*d0 + WP[2]*d1;
            d0 = PA[1]*ssss[0]+WP[1]*ssss[0+1];
            d1 = PA[1]*ssss[1]+WP[1]*ssss[1+1];
            PSSS[1] += d0;
	    DSSS[1] += PA[1]*d0 + WP[1]*d1 + tmp;
	    DSSS[3] += PA[0]*d0 + WP[0]*d1;
            d0 = PA[2]*ssss[0]+WP[2]*ssss[0+1];
            d1 = PA[2]*ssss[1]+WP[2]*ssss[1+1];
            PSSS[2] += d0;
	    DSSS[2] += PA[2]*d0 + WP[2]*d1 + tmp;
	    DSSS[4] += PA[1]*d0 + WP[1]*d1;
            }
            */
            {
	    double tmp = (ssss[0] - rz*ssss[1])*zeta2;
#pragma unroll
            for (int i=0; i<3; i++) {
            int j;
            double d0, d1;
            d0 = PA[i]*ssss[0]+WP[i]*ssss[0+1];
            d1 = PA[i]*ssss[1]+WP[i]*ssss[1+1];
            PSSS[i] += d0;
	    DSSS[i] += PA[i]*d0 + WP[i]*d1 + tmp;
            j=(i+2)%3;
	    DSSS[j+3] += PA[j]*d0 + WP[j]*d1;
            }
            }
	}	// klps
    }	// ijps
    // (P,P|S,S)
    /*
    PPSS[0*3+0] = DSSS[0] - BA[0]*PSSS[0];
    PPSS[0*3+1] = DSSS[3] - BA[1]*PSSS[0];
    PPSS[0*3+2] = DSSS[5] - BA[2]*PSSS[0];
    PPSS[1*3+0] = DSSS[3] - BA[0]*PSSS[1];
    PPSS[1*3+1] = DSSS[1] - BA[1]*PSSS[1];
    PPSS[1*3+2] = DSSS[4] - BA[2]*PSSS[1];
    PPSS[2*3+0] = DSSS[5] - BA[0]*PSSS[2];
    PPSS[2*3+1] = DSSS[4] - BA[1]*PSSS[2];
    PPSS[2*3+2] = DSSS[2] - BA[2]*PSSS[2];
    */
    // 035
    // 314
    // 542
    {
    int ix3[9]={0,3,5,3,1,4,5,4,2};
#pragma unroll
    for (int i=0; i<3; i++) {
#pragma unroll
      for (int j=0; j<3; j++) {
        int ix=i*3+j;
        PPSS[ix] = DSSS[ix3[ix]] - BA[j]*PSSS[i];
      }
    }
    }
}

/** １つのCS４重対に対して(pp,ps)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_ppps_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double PPPS[3*3*3] ) {
//    int ijps, klps, i, m, m1, c0;
//    int ijps, klps, i;
//    double cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double rz, re, ze2, ze22, zeta2, tmp;
//    double sqrho, rho, PQ2, T;
//    double PC[3], PA[3], WP[3], QP[3], QC[3], WQ[3];
//    double ssss[3+1], psss[2+1][3], dsss[1+1][6];
    double PSPS[3*3], DSPS[6*3];
#pragma unroll
    for (int i=0; i<3*3; i++ ) PSPS[i] = ZERO;
#pragma unroll
    for (int i=0; i<6*3; i++ ) DSPS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
        double PC[3], PA[3];
//	double zeta = vzeta[ijps];
	double dkab = LDG(vdkab[ijps]);
//	double xiza = vxiza[ijps];
	double xiza = LDG(vxiza[ijps]);
//	double zeta2 = HALF * zeta;
	double zeta2 = HALF * LDG(vzeta[ijps]);
#pragma unroll
	for (int i=0; i<3; i++ ) {
//	    PC[i] = AC[i] + xiza*BA[i];
//	    PA[i] = xiza * BA[i];
	    PC[i] = AC[i] + (PA[i] = xiza * BA[i]);
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
            double ze2, ze22;
            double WP[3], QC[3], WQ[3];
            double ssss[3+1];
            //double cssss, T;
            double zs0, zs1;
            {
            double rz;
            double QP[3];
            //double re;
	    double eta  = LDG(veta[klps]);
	    //double dk   = dkab * vdkcd[klps];
	    double xizc = LDG(vxizc[klps]);
            //double sqrho, rho;
            double rho;
	    //double PQ2  = ZERO;
            double dtmp;
            dtmp = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
//		QC[i] = xizc*DC[i];
//		QP[i] = xizc*DC[i] - PC[i];
		QP[i] = (QC[i] = xizc*DC[i]) - PC[i];
		//PQ2  += QP[i]*QP[i];
		dtmp  += QP[i]*QP[i];
	    }
            zs0 = dtmp;
            dtmp = zeta2 * 2;
	    //sqrho = sqrt(1.e0/(zeta+eta));
	    //sqrho = sqrt(1.e0/(dtmp+eta));
	    zs1 = sqrt(1.e0/(dtmp+eta));
	    rho   = zs1*zs1;
	    //zs1 = sqrho * dkab * vdkcd[klps];
	    zs1 *= dkab * LDG(vdkcd[klps]);
	    //rho   = sqrho*sqrho;
            zs0 *= rho;
	    //zs0 = rho * PQ2;
//	    rz    = rho * zeta;
//	    re    = rho * eta;
//	    ze2   = re  * zeta2;
//	    ze22  = re  * zeta;
	    dtmp *= rho;
	    ze22  = dtmp * eta;
	    ze2   = ze22 * HALF;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
//		WP[i] = rz*QP[i];
//		WQ[i] = rz*QP[i] - QP[i];
//		WQ[i] = (WP[i] = rz*QP[i]) - QP[i];
		WQ[i] = (WP[i] = dtmp*QP[i]) - QP[i];
	    }
	    //T     = rho * PQ2;
	    //cssss = sqrho * dk;
	    //cssss = sqrho * dkab * vdkcd[klps];
	    //gpu_fmt( ssss, 3, T, cssss );
	    //zs0 = rho * PQ2;
	    //zs1 = sqrho * dkab * vdkcd[klps];
	    //gpu_fmt( ssss, 3, zs0, zs1 );
#if   CUDA_FMT_M == 3
	    gpu_fmt3_method3( zs0, zs1, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt3_method2( zs0, zs1, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt3_method1( zs0, zs1, ssss );
#else
	    gpu_fmt3( ssss, zs0, zs1 );
#endif
            //zs0 = zeta2*(ssss[0] - rz*ssss[1]);
            //zs1 = zeta2*(ssss[1] - rz*ssss[2]);
            zs0 = zeta2*(ssss[0] - dtmp*ssss[1]);
            zs1 = zeta2*(ssss[1] - dtmp*ssss[2]);
            }
            /*
	    // psss
#pragma unroll
	    for ( m=0; m<=2; m++ ) {
		m1 = m+1;
#pragma unroll
		for ( i=0; i<3; i++ )
		    psss[m][i] = PA[i]*ssss[m]+WP[i]*ssss[m1];
	    }
            */
            /*
	    // dsss
#pragma unroll
	    for ( m=0; m<=1; m++) {
		m1 = m+1;
		tmp = ssss[m] - rz*ssss[m1];

		dsss[m][0] = PA[0]*psss[m][0] + WP[0]*psss[m1][0]
		    + zeta2*tmp;
		dsss[m][1] = PA[1]*psss[m][1] + WP[1]*psss[m1][1]
			   + zeta2*tmp;
		dsss[m][2] = PA[2]*psss[m][2] + WP[2]*psss[m1][2]
			   + zeta2*tmp;
		dsss[m][3] = PA[0]*psss[m][1] + WP[0]*psss[m1][1];
		dsss[m][4] = PA[1]*psss[m][2] + WP[1]*psss[m1][2];
		dsss[m][5] = PA[2]*psss[m][0] + WP[2]*psss[m1][0];
	    }
            */

            /*
	    // psps
	    PSPS[0*3+0] += QC[0]*psss[0][0] + WQ[0]*psss[1][0]
			+ ze2*ssss[1];
	    PSPS[0*3+1] += QC[1]*psss[0][0] + WQ[1]*psss[1][0];
	    PSPS[0*3+2] += QC[2]*psss[0][0] + WQ[2]*psss[1][0];
	    PSPS[1*3+0] += QC[0]*psss[0][1] + WQ[0]*psss[1][1];
	    PSPS[1*3+1] += QC[1]*psss[0][1] + WQ[1]*psss[1][1]
			+ ze2*ssss[1];
	    PSPS[1*3+2] += QC[2]*psss[0][1] + WQ[2]*psss[1][1];
	    PSPS[2*3+0] += QC[0]*psss[0][2] + WQ[0]*psss[1][2];
	    PSPS[2*3+1] += QC[1]*psss[0][2] + WQ[1]*psss[1][2];
	    PSPS[2*3+2] += QC[2]*psss[0][2] + WQ[2]*psss[1][2]
			+ ze2*ssss[1];
            */
            /*
	    // dsps
	    DSPS[0*3+0] += QC[0]*dsss[0][0] + WQ[0]*dsss[1][0]
			+ ze22*psss[1][0];
	    DSPS[0*3+1] += QC[1]*dsss[0][0] + WQ[1]*dsss[1][0];
	    DSPS[0*3+2] += QC[2]*dsss[0][0] + WQ[2]*dsss[1][0];
	    DSPS[1*3+0] += QC[0]*dsss[0][1] + WQ[0]*dsss[1][1];
	    DSPS[1*3+1] += QC[1]*dsss[0][1] + WQ[1]*dsss[1][1]
			+ ze22*psss[1][1];
	    DSPS[1*3+2] += QC[2]*dsss[0][1] + WQ[2]*dsss[1][1];
	    DSPS[2*3+0] += QC[0]*dsss[0][2] + WQ[0]*dsss[1][2];
	    DSPS[2*3+1] += QC[1]*dsss[0][2] + WQ[1]*dsss[1][2];
	    DSPS[2*3+2] += QC[2]*dsss[0][2] + WQ[2]*dsss[1][2]
			+ ze22*psss[1][2];
	    DSPS[3*3+0] += QC[0]*dsss[0][3] + WQ[0]*dsss[1][3]
			+ ze2*psss[1][1];
	    DSPS[3*3+1] += QC[1]*dsss[0][3] + WQ[1]*dsss[1][3]
			+ ze2*psss[1][0];
	    DSPS[3*3+2] += QC[2]*dsss[0][3] + WQ[2]*dsss[1][3];
	    DSPS[4*3+0] += QC[0]*dsss[0][4] + WQ[0]*dsss[1][4];
	    DSPS[4*3+1] += QC[1]*dsss[0][4] + WQ[1]*dsss[1][4]
			+ ze2*psss[1][2];
	    DSPS[4*3+2] += QC[2]*dsss[0][4] + WQ[2]*dsss[1][4]
			+ ze2*psss[1][1];
	    DSPS[5*3+0] += QC[0]*dsss[0][5] + WQ[0]*dsss[1][5]
			+ ze2*psss[1][2];
	    DSPS[5*3+1] += QC[1]*dsss[0][5] + WQ[1]*dsss[1][5];
	    DSPS[5*3+2] += QC[2]*dsss[0][5] + WQ[2]*dsss[1][5]
			+ ze2*psss[1][0];
            */
//#pragma unroll
            for (int j=0; j<3; j++)
            {
              double d0, d1;
              double p[3];
              int j2;
              //int jid[]={0,1,2,0,1,2};

#pragma unroll
              for (int i=0; i<3; i++)
                p[i] = PA[j]*ssss[i]+WP[j]*ssss[i+1];
#pragma unroll
              for (int i=0; i<3; i++)
                PSPS[j*3+i] += QC[i]*p[0] + WQ[i]*p[1];
              PSPS[j*3+j] += ze2*ssss[1];

              d0 = PA[j]*p[0] + WP[j]*p[1] + zs0;
              d1 = PA[j]*p[1] + WP[j]*p[2] + zs1;
#pragma unroll
              for (int i=0; i<3; i++)
                DSPS[j*3+i] += QC[i]*d0 + WQ[i]*d1;
	      DSPS[j*3+j] += ze22*p[1];

              j2 = (j+2)%3;
              //j2 = jid[j+2];
              d0 = PA[j2]*p[0] + WP[j2]*p[1];
              d1 = PA[j2]*p[1] + WP[j2]*p[2];
#pragma unroll
              for (int i=0; i<3; i++)
                DSPS[(j2+3)*3+i] += QC[i]*d0 + WQ[i]*d1;
	      DSPS[(j2+3)*3+j2] += ze2*p[1];

              j2 = (j+1)%3;
              //j2 = jid[j+1];
	      DSPS[(j+3)*3+j2] += ze2*p[1];
            }
	}	// klps
    }	// ijps
    // ppps
    /*
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[0*3*3+0*3+i] = DSPS[0*3+i] - BA[0]*PSPS[0*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[0*3*3+1*3+i] = DSPS[3*3+i] - BA[1]*PSPS[0*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[0*3*3+2*3+i] = DSPS[5*3+i] - BA[2]*PSPS[0*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[1*3*3+0*3+i] = DSPS[3*3+i] - BA[0]*PSPS[1*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[1*3*3+1*3+i] = DSPS[1*3+i] - BA[1]*PSPS[1*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[1*3*3+2*3+i] = DSPS[4*3+i] - BA[2]*PSPS[1*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[2*3*3+0*3+i] = DSPS[5*3+i] - BA[0]*PSPS[2*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[2*3*3+1*3+i] = DSPS[4*3+i] - BA[1]*PSPS[2*3+i];
#pragma unroll
    for (int i=0; i<3; i++)
        PPPS[2*3*3+2*3+i] = DSPS[2*3+i] - BA[2]*PSPS[2*3+i];
    */
    {
    int ix3[9]={0,3,5,3,1,4,5,4,2};
#pragma unroll
    for (int k=0; k<3; k++)
#pragma unroll
    for (int j=0; j<3; j++)
    {
      int ix=ix3[k*3+j];
#pragma unroll
      for (int i=0; i<3; i++)
        PPPS[(k*3+j)*3+i] = DSPS[ix*3+i] - BA[j]*PSPS[k*3+i];
    }
    }
}

/** １つのCS４重対に対して(pp,pp)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_pppp_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double PPPP[3*3*3*3] ) {
//    int ijps, klps, i, m, m1, c0;
//    int ab, ab01, ab10, ab00;
//    double cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double rz, re, ze2, ze22, zeta2, eta2;
//    double tmp, tmp3[3], tmp6[6];
//    double sqrho, rho, PQ2, T;
//    double PC[3], PA[3], WP[3], QP[3], QC[3], WQ[3];
//    double ssss[4+1], psss[3+1][3], dsss[2+1][6];
//    double ssps[3], psps[1+1][3*3], dsps[1+1][6*3];
    double PSPS[3*3], DSPS[6*3], PSDS[3*6], DSDS[6*6];
    double PPPS[3*3*3], PPDS[3*3*6];
#pragma unroll
    for (int i=0; i<3*3; i++ ) PSPS[i] = ZERO;
#pragma unroll
    for (int i=0; i<6*3; i++ ) DSPS[i] = ZERO;
#pragma unroll
    for (int i=0; i<3*6; i++ ) PSDS[i] = ZERO;
#pragma unroll
    for (int i=0; i<6*6; i++ ) DSDS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
        double PC[3], PA[3];
        double zeta, dkab, xiza, zeta2;
	zeta = LDG(vzeta[ijps]);
	dkab = LDG(vdkab[ijps]);
	xiza = LDG(vxiza[ijps]);
	zeta2 = HALF * zeta;
#pragma unroll
	for (int i=0; i<3; i++ ) {
	    PC[i] = AC[i] + xiza*BA[i];
	    PA[i] = xiza * BA[i];
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
            double ssss[4+1], psss[3+1][3];
            double psps[1+1][3*3];
            double WP[3], QP[3], QC[3], WQ[3];
            double cssss, eta, xizc, dk;
            double sqrho, rho, PQ2, T;
            double rz, re, ze2, ze22, eta2;
	    eta  = LDG(veta[klps]);
	    dk   = dkab * LDG(vdkcd[klps]);
	    xizc = LDG(vxizc[klps]);
	    eta2 = eta * HALF;
	    PQ2  = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		QC[i] = xizc*DC[i];
		QP[i] = xizc*DC[i] - PC[i];
		PQ2  += QP[i]*QP[i];
	    }
	    sqrho = sqrt(1.e0/(zeta+eta));
	    rho   = sqrho*sqrho;
	    rz    = rho * zeta;
	    re    = rho * eta;
	    ze2   = re  * zeta2;
	    ze22  = re  * zeta;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		WP[i] = rz*QP[i];
		WQ[i] = rz*QP[i] - QP[i];
	    }
	    T     = rho * PQ2;
	    cssss = sqrho * dk;
#if   CUDA_FMT_M == 3
	    gpu_fmt4_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt4_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt4_method1( T, cssss, ssss );
#else
	    gpu_fmt( ssss, 4, T, cssss );
#endif
	    // (P,S|S,S)
#pragma unroll
	    for (int m=0, m1=1; m<=3; m++, m1++) {
		psss[m][0] = PA[0]*ssss[m] + WP[0]*ssss[m1];
		psss[m][1] = PA[1]*ssss[m] + WP[1]*ssss[m1];
		psss[m][2] = PA[2]*ssss[m] + WP[2]*ssss[m1];
	    }	// end m loop
	    // (D,S|S,S)
            /*
#pragma unroll
	    for (int m=0, m1=1; m<=2; m++, m1++) {
		double tmp = zeta2*(ssss[m] - rz*ssss[m1]);
		dsss[m][0] = PA[0]*psss[m][0] + WP[0]*psss[m1][0]
			   + tmp;
		dsss[m][1] = PA[1]*psss[m][1] + WP[1]*psss[m1][1]
			   + tmp;
		dsss[m][2] = PA[2]*psss[m][2] + WP[2]*psss[m1][2]
			   + tmp;
		dsss[m][3] = PA[0]*psss[m][1] + WP[0]*psss[m1][1];
		dsss[m][4] = PA[1]*psss[m][2] + WP[1]*psss[m1][2];
		dsss[m][5] = PA[2]*psss[m][0] + WP[2]*psss[m1][0];
	    }	// end m loop
            */
/*
	    // (S,S|P,S)
	    ssps[0] = QC[0]*ssss[1] + WQ[0]*ssss[2];
	    ssps[1] = QC[1]*ssss[1] + WQ[1]*ssss[2];
	    ssps[2] = QC[2]*ssss[1] + WQ[2]*ssss[2];
*/
	    // (P,S|P,S)
            /*
#pragma unroll
	    for (int m=0, m1=1; m<=1; m++, m1++) {
              double tmp = ze2*ssss[m1];
		psps[m][0*3+0] = QC[0]*psss[m][0] + WQ[0]*psss[m1][0]
			       + tmp;
//			       + ze2*ssss[m1];
		psps[m][0*3+1] = QC[1]*psss[m][0] + WQ[1]*psss[m1][0];
		psps[m][0*3+2] = QC[2]*psss[m][0] + WQ[2]*psss[m1][0];
		psps[m][1*3+0] = QC[0]*psss[m][1] + WQ[0]*psss[m1][1];
		psps[m][1*3+1] = QC[1]*psss[m][1] + WQ[1]*psss[m1][1]
			       + tmp;
//			       + ze2*ssss[m1];
		psps[m][1*3+2] = QC[2]*psss[m][1] + WQ[2]*psss[m1][1];
		psps[m][2*3+0] = QC[0]*psss[m][2] + WQ[0]*psss[m1][2];
		psps[m][2*3+1] = QC[1]*psss[m][2] + WQ[1]*psss[m1][2];
		psps[m][2*3+2] = QC[2]*psss[m][2] + WQ[2]*psss[m1][2]
			       + tmp;
//			       + ze2*ssss[m1];
	    }	// end m loop
#pragma unroll
	    for (int i=0; i<3*3; i++) PSPS[i] += psps[0][i];
            */
#pragma unroll
            for (int i=0; i<3; i++) {
#pragma unroll
              for (int j=0; j<3; j++) {
                psps[0][i*3+j] = QC[j]*psss[0][i] + WQ[j]*psss[1][i];
                psps[1][i*3+j] = QC[j]*psss[1][i] + WQ[j]*psss[2][i];
              }
              psps[0][i*3+i] += ze2*ssss[1];
              psps[1][i*3+i] += ze2*ssss[2];
#pragma unroll
              for (int j=0; j<3; j++)
                PSPS[i*3+j] += psps[0][i*3+j];
            }
/*
	    // (D,S|P,S)
#pragma unroll
	    for (int m=0; m<=1; m++) {
		int m1 = m+1;
		dsps[m][0*3+0] = QC[0]*dsss[m][0] + WQ[0]*dsss[m1][0]
			       + ze22*psss[m1][0];
		dsps[m][0*3+1] = QC[1]*dsss[m][0] + WQ[1]*dsss[m1][0];
		dsps[m][0*3+2] = QC[2]*dsss[m][0] + WQ[2]*dsss[m1][0];
		dsps[m][1*3+0] = QC[0]*dsss[m][1] + WQ[0]*dsss[m1][1];
		dsps[m][1*3+1] = QC[1]*dsss[m][1] + WQ[1]*dsss[m1][1]
			       + ze22*psss[m1][1];
		dsps[m][1*3+2] = QC[2]*dsss[m][1] + WQ[2]*dsss[m1][1];
		dsps[m][2*3+0] = QC[0]*dsss[m][2] + WQ[0]*dsss[m1][2];
		dsps[m][2*3+1] = QC[1]*dsss[m][2] + WQ[1]*dsss[m1][2];
		dsps[m][2*3+2] = QC[2]*dsss[m][2] + WQ[2]*dsss[m1][2]
			       + ze22*psss[m1][2];
		dsps[m][3*3+0] = QC[0]*dsss[m][3] + WQ[0]*dsss[m1][3]
			       + ze2*psss[m1][1];
		dsps[m][3*3+1] = QC[1]*dsss[m][3] + WQ[1]*dsss[m1][3]
			       + ze2*psss[m1][0];
		dsps[m][3*3+2] = QC[2]*dsss[m][3] + WQ[2]*dsss[m1][3];
		dsps[m][4*3+0] = QC[0]*dsss[m][4] + WQ[0]*dsss[m1][4];
		dsps[m][4*3+1] = QC[1]*dsss[m][4] + WQ[1]*dsss[m1][4]
			       + ze2*psss[m1][2];
		dsps[m][4*3+2] = QC[2]*dsss[m][4] + WQ[2]*dsss[m1][4]
			       + ze2*psss[m1][1];
		dsps[m][5*3+0] = QC[0]*dsss[m][5] + WQ[0]*dsss[m1][5]
			       + ze2*psss[m1][2];
		dsps[m][5*3+1] = QC[1]*dsss[m][5] + WQ[1]*dsss[m1][5];
		dsps[m][5*3+2] = QC[2]*dsss[m][5] + WQ[2]*dsss[m1][5]
			       + ze2*psss[m1][0];
	    }	// end m loop
#pragma unroll
	    for (int i=0; i<6*3; i++) DSPS[i] += dsps[0][i];
*/
	    // (P,S|D,S)
/*
#pragma unroll
	    for (int i=0; i<3; i++) tmp3[i] = psss[0][i] - re*psss[1][i];

	    PSDS[0*6+0] += QC[0]*psps[0][0*3+0] + WQ[0]*psps[1][0*3+0]
			+   eta2*tmp3[0] + ze2*ssps[0];
	    PSDS[0*6+1] += QC[1]*psps[0][0*3+1] + WQ[1]*psps[1][0*3+1]
			+   eta2*tmp3[0];
	    PSDS[0*6+2] += QC[2]*psps[0][0*3+2] + WQ[2]*psps[1][0*3+2]
			+   eta2*tmp3[0];
	    PSDS[0*6+3] += QC[0]*psps[0][0*3+1] + WQ[0]*psps[1][0*3+1]
			+ ze2*ssps[1];
	    PSDS[0*6+4] += QC[1]*psps[0][0*3+2] + WQ[1]*psps[1][0*3+2];
	    PSDS[0*6+5] += QC[2]*psps[0][0*3+0] + WQ[2]*psps[1][0*3+0];
	    PSDS[1*6+0] += QC[0]*psps[0][1*3+0] + WQ[0]*psps[1][1*3+0]
			+   eta2*tmp3[1];
	    PSDS[1*6+1] += QC[1]*psps[0][1*3+1] + WQ[1]*psps[1][1*3+1]
			+   eta2*tmp3[1] + ze2*ssps[1];
	    PSDS[1*6+2] += QC[2]*psps[0][1*3+2] + WQ[2]*psps[1][1*3+2]
			+   eta2*tmp3[1];
	    PSDS[1*6+3] += QC[0]*psps[0][1*3+1] + WQ[0]*psps[1][1*3+1];
	    PSDS[1*6+4] += QC[1]*psps[0][1*3+2] + WQ[1]*psps[1][1*3+2]
			+ ze2*ssps[2];
	    PSDS[1*6+5] += QC[2]*psps[0][1*3+0] + WQ[2]*psps[1][1*3+0];
	    PSDS[2*6+0] += QC[0]*psps[0][2*3+0] + WQ[0]*psps[1][2*3+0]
			+   eta2*tmp3[2];
	    PSDS[2*6+1] += QC[1]*psps[0][2*3+1] + WQ[1]*psps[1][2*3+1]
			+   eta2*tmp3[2];
	    PSDS[2*6+2] += QC[2]*psps[0][2*3+2] + WQ[2]*psps[1][2*3+2]
			+   eta2*tmp3[2] + ze2*ssps[2];
	    PSDS[2*6+3] += QC[0]*psps[0][2*3+1] + WQ[0]*psps[1][2*3+1];
	    PSDS[2*6+4] += QC[1]*psps[0][2*3+2] + WQ[1]*psps[1][2*3+2];
	    PSDS[2*6+5] += QC[2]*psps[0][2*3+0] + WQ[2]*psps[1][2*3+0]
			+ ze2*ssps[0];
*/
#pragma unroll
            for (int i=0; i<3; i++) {
	      double tmp;
#pragma unroll
              for (int j=0; j<6; j++) {
                int j0 = j%3;
                int j1 = (j<3)? j: (j+1)%3;
                PSDS[i*6+j] += QC[j0]*psps[0][i*3+j1] + WQ[j0]*psps[1][i*3+j1];
              }
              tmp = eta2*(psss[0][i] - re*psss[1][i]);
#pragma unroll
              for (int j=0; j<3; j++)
                PSDS[i*6+j] += tmp;
              //PSDS[i*6+i  ] += ze2*ssps[i];
              //PSDS[i*6+i+3] += ze2*ssps[(i+1)%3];
            }
            {
              double ssps[3];
              ssps[0] = QC[0]*ssss[1] + WQ[0]*ssss[2];
              ssps[1] = QC[1]*ssss[1] + WQ[1]*ssss[2];
              ssps[2] = QC[2]*ssss[1] + WQ[2]*ssss[2];
#pragma unroll
              for (int i=0; i<3; i++) {
              PSDS[i*6+i  ] += ze2*ssps[i];
              PSDS[i*6+i+3] += ze2*ssps[(i+1)%3];
              }
            }
	    // (D,S|D,S)
/*
#pragma unroll
	    for (int i=0; i<6; i++) tmp6[i] = dsss[0][i] - re*dsss[1][i];

	    DSDS[0*6+0] += QC[0]*dsps[0][0*3+0] + WQ[0]*dsps[1][0*3+0]
			+   eta2*tmp6[0] + ze22*psps[1][0*3+0];
	    DSDS[0*6+1] += QC[1]*dsps[0][0*3+1] + WQ[1]*dsps[1][0*3+1]
			+   eta2*tmp6[0];
	    DSDS[0*6+2] += QC[2]*dsps[0][0*3+2] + WQ[2]*dsps[1][0*3+2]
			+   eta2*tmp6[0];
	    DSDS[0*6+3] += QC[0]*dsps[0][0*3+1] + WQ[0]*dsps[1][0*3+1]
			+ ze22*psps[1][0*3+1];
	    DSDS[0*6+4] += QC[1]*dsps[0][0*3+2] + WQ[1]*dsps[1][0*3+2];
	    DSDS[0*6+5] += QC[2]*dsps[0][0*3+0] + WQ[2]*dsps[1][0*3+0];
	    DSDS[1*6+0] += QC[0]*dsps[0][1*3+0] + WQ[0]*dsps[1][1*3+0]
			+   eta2*tmp6[1];
	    DSDS[1*6+1] += QC[1]*dsps[0][1*3+1] + WQ[1]*dsps[1][1*3+1]
			+   eta2*tmp6[1] + ze22*psps[1][1*3+1];
	    DSDS[1*6+2] += QC[2]*dsps[0][1*3+2] + WQ[2]*dsps[1][1*3+2]
			+   eta2*tmp6[1];
	    DSDS[1*6+3] += QC[0]*dsps[0][1*3+1] + WQ[0]*dsps[1][1*3+1];
	    DSDS[1*6+4] += QC[1]*dsps[0][1*3+2] + WQ[1]*dsps[1][1*3+2]
			+ ze22*psps[1][1*3+2];
	    DSDS[1*6+5] += QC[2]*dsps[0][1*3+0] + WQ[2]*dsps[1][1*3+0];
	    DSDS[2*6+0] += QC[0]*dsps[0][2*3+0] + WQ[0]*dsps[1][2*3+0]
			+   eta2*tmp6[2];
	    DSDS[2*6+1] += QC[1]*dsps[0][2*3+1] + WQ[1]*dsps[1][2*3+1]
			+   eta2*tmp6[2];
	    DSDS[2*6+2] += QC[2]*dsps[0][2*3+2] + WQ[2]*dsps[1][2*3+2]
			+   eta2*tmp6[2] + ze22*psps[1][2*3+2];
	    DSDS[2*6+3] += QC[0]*dsps[0][2*3+1] + WQ[0]*dsps[1][2*3+1];
	    DSDS[2*6+4] += QC[1]*dsps[0][2*3+2] + WQ[1]*dsps[1][2*3+2];
	    DSDS[2*6+5] += QC[2]*dsps[0][2*3+0] + WQ[2]*dsps[1][2*3+0]
			+ ze22*psps[1][2*3+0];
	    DSDS[3*6+0] += QC[0]*dsps[0][3*3+0] + WQ[0]*dsps[1][3*3+0]
			+   eta2*tmp6[3] + ze2*psps[1][1*3+0];
	    DSDS[3*6+1] += QC[1]*dsps[0][3*3+1] + WQ[1]*dsps[1][3*3+1]
			+   eta2*tmp6[3] + ze2*psps[1][0*3+1];
	    DSDS[3*6+2] += QC[2]*dsps[0][3*3+2] + WQ[2]*dsps[1][3*3+2]
			+   eta2*tmp6[3];
	    DSDS[3*6+3] += QC[0]*dsps[0][3*3+1] + WQ[0]*dsps[1][3*3+1]
			+ ze2*psps[1][1*3+1];
	    DSDS[3*6+4] += QC[1]*dsps[0][3*3+2] + WQ[1]*dsps[1][3*3+2]
			+ ze2*psps[1][0*3+2];
	    DSDS[3*6+5] += QC[2]*dsps[0][3*3+0] + WQ[2]*dsps[1][3*3+0];
	    DSDS[4*6+0] += QC[0]*dsps[0][4*3+0] + WQ[0]*dsps[1][4*3+0]
			+   eta2*tmp6[4];
	    DSDS[4*6+1] += QC[1]*dsps[0][4*3+1] + WQ[1]*dsps[1][4*3+1]
			+   eta2*tmp6[4] + ze2*psps[1][2*3+1];
	    DSDS[4*6+2] += QC[2]*dsps[0][4*3+2] + WQ[2]*dsps[1][4*3+2]
			+   eta2*tmp6[4] + ze2*psps[1][1*3+2];
	    DSDS[4*6+3] += QC[0]*dsps[0][4*3+1] + WQ[0]*dsps[1][4*3+1];
	    DSDS[4*6+4] += QC[1]*dsps[0][4*3+2] + WQ[1]*dsps[1][4*3+2]
			+ ze2*psps[1][2*3+2];
	    DSDS[4*6+5] += QC[2]*dsps[0][4*3+0] + WQ[2]*dsps[1][4*3+0]
			+ ze2*psps[1][1*3+0];
	    DSDS[5*6+0] += QC[0]*dsps[0][5*3+0] + WQ[0]*dsps[1][5*3+0]
			+   eta2*tmp6[5] + ze2*psps[1][2*3+0];
	    DSDS[5*6+1] += QC[1]*dsps[0][5*3+1] + WQ[1]*dsps[1][5*3+1]
			+   eta2*tmp6[5];
	    DSDS[5*6+2] += QC[2]*dsps[0][5*3+2] + WQ[2]*dsps[1][5*3+2]
			+   eta2*tmp6[5] + ze2*psps[1][0*3+2];
	    DSDS[5*6+3] += QC[0]*dsps[0][5*3+1] + WQ[0]*dsps[1][5*3+1]
			+ ze2*psps[1][2*3+1];
	    DSDS[5*6+4] += QC[1]*dsps[0][5*3+2] + WQ[1]*dsps[1][5*3+2];
	    DSDS[5*6+5] += QC[2]*dsps[0][5*3+0] + WQ[2]*dsps[1][5*3+0]
			+ ze2*psps[1][0*3+0];
*/
	    // (D,S|P,S)
            /*
#pragma unroll
	    for (int m=0; m<=1; m++) {
		int m1 = m+1;
		dsps[m][0*3+0] = QC[0]*dsss[m][0] + WQ[0]*dsss[m1][0]
			       + ze22*psss[m1][0];
		dsps[m][0*3+1] = QC[1]*dsss[m][0] + WQ[1]*dsss[m1][0];
		dsps[m][0*3+2] = QC[2]*dsss[m][0] + WQ[2]*dsss[m1][0];
		dsps[m][1*3+0] = QC[0]*dsss[m][1] + WQ[0]*dsss[m1][1];
		dsps[m][1*3+1] = QC[1]*dsss[m][1] + WQ[1]*dsss[m1][1]
			       + ze22*psss[m1][1];
		dsps[m][1*3+2] = QC[2]*dsss[m][1] + WQ[2]*dsss[m1][1];
		dsps[m][2*3+0] = QC[0]*dsss[m][2] + WQ[0]*dsss[m1][2];
		dsps[m][2*3+1] = QC[1]*dsss[m][2] + WQ[1]*dsss[m1][2];
		dsps[m][2*3+2] = QC[2]*dsss[m][2] + WQ[2]*dsss[m1][2]
			       + ze22*psss[m1][2];
		dsps[m][3*3+0] = QC[0]*dsss[m][3] + WQ[0]*dsss[m1][3]
			       + ze2*psss[m1][1];
		dsps[m][3*3+1] = QC[1]*dsss[m][3] + WQ[1]*dsss[m1][3]
			       + ze2*psss[m1][0];
		dsps[m][3*3+2] = QC[2]*dsss[m][3] + WQ[2]*dsss[m1][3];
		dsps[m][4*3+0] = QC[0]*dsss[m][4] + WQ[0]*dsss[m1][4];
		dsps[m][4*3+1] = QC[1]*dsss[m][4] + WQ[1]*dsss[m1][4]
			       + ze2*psss[m1][2];
		dsps[m][4*3+2] = QC[2]*dsss[m][4] + WQ[2]*dsss[m1][4]
			       + ze2*psss[m1][1];
		dsps[m][5*3+0] = QC[0]*dsss[m][5] + WQ[0]*dsss[m1][5]
			       + ze2*psss[m1][2];
		dsps[m][5*3+1] = QC[1]*dsss[m][5] + WQ[1]*dsss[m1][5];
		dsps[m][5*3+2] = QC[2]*dsss[m][5] + WQ[2]*dsss[m1][5]
			       + ze2*psss[m1][0];
	    }	// end m loop
#pragma unroll
	    for (int i=0; i<6*3; i++) DSPS[i] += dsps[0][i];
            */
#pragma unroll
            for (int i=0; i<6; i++) {
              double dsps[3][1+1];
              double dsss[2+1];
              double zt;
              int i0 = i%3;
              int i1 = (i<3)? i: (i+1)%3;
              int i2 = (i+2)%3;

              zt = (i<3)? zeta2: 0;
              dsss[0] = PA[i0]*psss[0][i1] + WP[i0]*psss[1][i1] + zt*(ssss[0] - rz*ssss[1]);
              dsss[1] = PA[i0]*psss[1][i1] + WP[i0]*psss[2][i1] + zt*(ssss[1] - rz*ssss[2]);
              dsss[2] = PA[i0]*psss[2][i1] + WP[i0]*psss[3][i1] + zt*(ssss[2] - rz*ssss[3]);

#pragma unroll
              for (int j=0; j<3; j++) {
                dsps[j][0] = QC[j]*dsss[0] + WQ[j]*dsss[1];
                dsps[j][1] = QC[j]*dsss[1] + WQ[j]*dsss[2];
              }
              zt = (i<3)? ze22: ze2;
		dsps[i0][0] += zt*psss[1][i1];
		dsps[i0][1] += zt*psss[2][i1];
              if (i>=3) {
		dsps[i1][0] += zt*psss[1][i0];
		dsps[i1][1] += zt*psss[2][i0];
              }
#pragma unroll
              for (int j=0; j<3; j++) 
                DSPS[i*3+j] += dsps[j][0];
#pragma unroll
              for (int j=0; j<6; j++) {
                int j0 = j%3;
                int j1 = (j<3)? j: (j+1)%3;
                DSDS[i*6+j] += QC[j0]*dsps[j1][0] + WQ[j0]*dsps[j1][1];
              }
              {
                double tmp;
                tmp = eta2*(dsss[0] - re*dsss[1]);
#pragma unroll
                for (int j=0; j<3; j++) DSDS[i*6+j] += tmp;
              }
                DSDS[i*6+i0  ] += zt*psps[1][i1*3+i0];
              if (i<3) {
                //DSDS[i*6+i  ] += ze22*psps[1][i*3+i];
                DSDS[i*6+i+3] += ze22*psps[1][i*3+(i+1)%3];
              } else {
                //DSDS[i*6+i0  ] += ze2*psps[1][i1*3+i0];
                DSDS[i*6+i1  ] += ze2*psps[1][i0*3+i1];
                DSDS[i*6+i   ] += ze2*psps[1][i1*3+i1];
                DSDS[i*6+i1+3] += ze2*psps[1][i0*3+i2];
              }
            }
//#pragma unroll
//	    for (int i=0; i<3*3; i++) PSPS[i] += psps[0][i];
//#pragma unroll
//	    for (int i=0; i<6*3; i++) DSPS[i] += dsps[0][i];
	}	// klps
    }	// ijps
    // (P,P|P,S)
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[0*3*3+0*3+c0] = DSPS[0*3+c0] - BA[0]*PSPS[0*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[0*3*3+1*3+c0] = DSPS[3*3+c0] - BA[1]*PSPS[0*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[0*3*3+2*3+c0] = DSPS[5*3+c0] - BA[2]*PSPS[0*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[1*3*3+0*3+c0] = DSPS[3*3+c0] - BA[0]*PSPS[1*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[1*3*3+1*3+c0] = DSPS[1*3+c0] - BA[1]*PSPS[1*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[1*3*3+2*3+c0] = DSPS[4*3+c0] - BA[2]*PSPS[1*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[2*3*3+0*3+c0] = DSPS[5*3+c0] - BA[0]*PSPS[2*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[2*3*3+1*3+c0] = DSPS[4*3+c0] - BA[1]*PSPS[2*3+c0];
#pragma unroll
    for (int c0=0; c0<3; c0++)
        PPPS[2*3*3+2*3+c0] = DSPS[2*3+c0] - BA[2]*PSPS[2*3+c0];
    // (P,P|D,S)
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[0*3*6+0*6+c0] = DSDS[0*6+c0] - BA[0]*PSDS[0*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[0*3*6+1*6+c0] = DSDS[3*6+c0] - BA[1]*PSDS[0*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[0*3*6+2*6+c0] = DSDS[5*6+c0] - BA[2]*PSDS[0*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[1*3*6+0*6+c0] = DSDS[3*6+c0] - BA[0]*PSDS[1*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[1*3*6+1*6+c0] = DSDS[1*6+c0] - BA[1]*PSDS[1*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[1*3*6+2*6+c0] = DSDS[4*6+c0] - BA[2]*PSDS[1*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[2*3*6+0*6+c0] = DSDS[5*6+c0] - BA[0]*PSDS[2*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[2*3*6+1*6+c0] = DSDS[4*6+c0] - BA[1]*PSDS[2*6+c0];
#pragma unroll
    for (int c0=0; c0<6; c0++)
        PPDS[2*3*6+2*6+c0] = DSDS[2*6+c0] - BA[2]*PSDS[2*6+c0];
    // (a,b|c,d+1) = (a,b|c+1,d) - DC(a,b|c,d)
    // (P,P|P,P)
#pragma unroll
    for (int ab=0, ab01=0, ab10=0, ab00=0;
            ab<3*3; ab++, ab01 += 3*3, ab10 += 6, ab00 += 3) {
        PPPP[ab01+0*3+0] = PPDS[ab10+0] - DC[0]*PPPS[ab00+0];
        PPPP[ab01+0*3+1] = PPDS[ab10+3] - DC[1]*PPPS[ab00+0];
        PPPP[ab01+0*3+2] = PPDS[ab10+5] - DC[2]*PPPS[ab00+0];
        PPPP[ab01+1*3+0] = PPDS[ab10+3] - DC[0]*PPPS[ab00+1];
        PPPP[ab01+1*3+1] = PPDS[ab10+1] - DC[1]*PPPS[ab00+1];
        PPPP[ab01+1*3+2] = PPDS[ab10+4] - DC[2]*PPPS[ab00+1];
        PPPP[ab01+2*3+0] = PPDS[ab10+5] - DC[0]*PPPS[ab00+2];
        PPPP[ab01+2*3+1] = PPDS[ab10+4] - DC[1]*PPPS[ab00+2];
        PPPP[ab01+2*3+2] = PPDS[ab10+2] - DC[2]*PPPS[ab00+2];
    }
}

/** １つのCS４重対に対して(ds,ss)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_dsss_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double DSSS[6] ) {
//    int ijps, klps, i, m;
//    double cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double zeta, dkab, xiza;
    double zeta, dkab, xiza;
//    double rz, zeta2, tmp;
    double zeta2;
//    double PC[3], PA[3], WP[3], QP[3];
    double PC[3], PA[3];
//    double ssss[1+2], psss[1+1][3];
    double dsss[6];

#pragma unroll
    for (int i=0; i<6; i++ ) dsss[i] = ZERO;
//    for (int i=0; i<6; i++ ) DSSS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
	zeta = LDG(vzeta[ijps]);
	dkab = LDG(vdkab[ijps]);
	xiza = LDG(vxiza[ijps]);
	zeta2 = HALF * zeta;
#pragma unroll
	for (int i=0; i<3; i++ ) {
//	    PC[i] = AC[i] + xiza*BA[i];
//	    PA[i] = xiza * BA[i];
	    PC[i] = AC[i] + (PA[i] = xiza * BA[i]);
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
//          double WP[3],QP[3];
          double WP[3];
//          double ssss[1+2], psss[1+1][3];
          double ssss[1+2];
          double rz;
          {
          double cssss, eta, xizc, dk;
          double sqrho, rho, PQ2, T;
	    eta  = LDG(veta[klps]);
	    dk   = dkab * LDG(vdkcd[klps]);
	    xizc = LDG(vxizc[klps]);
	    PQ2  = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		//QP[i] = xizc*DC[i] - PC[i];
		//PQ2  += QP[i]*QP[i];
		WP[i] = xizc*DC[i] - PC[i];
		PQ2  += WP[i]*WP[i];
	    }
	    sqrho = sqrt(1.e0/(zeta+eta));
	    rho   = sqrho*sqrho;
	    rz    = rho * zeta;
#pragma unroll
	    for (int i=0; i<3; i++ ) WP[i] *= rz;
//	    for (i=0; i<3; i++ ) WP[i]=rz*QP[i];
	    T     = rho * PQ2;
	    cssss = sqrho * dk;
	    //gpu_fmt( ssss, 2, T, cssss );
#if   CUDA_FMT_M == 3
	    gpu_fmt2_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt2_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt2_method1( T, cssss, ssss );
#else
	    gpu_fmt2( ssss, T, cssss );
#endif
          }
          /*
	    // psss
#pragma unroll
	    for (int m=0; m<=1; m++ ) {
#pragma unroll
		for (int i=0; i<3; i++ )
		    psss[m][i] = PA[i]*ssss[m]+WP[i]*ssss[m+1];
	    }
	    // dsss
            {
            double tmp;
	    tmp = ssss[0] - rz*ssss[1];
	    DSSS[0] += PA[0]*psss[0][0] + WP[0]*psss[1][0] + zeta2*tmp;
	    DSSS[1] += PA[1]*psss[0][1] + WP[1]*psss[1][1] + zeta2*tmp;
	    DSSS[2] += PA[2]*psss[0][2] + WP[2]*psss[1][2] + zeta2*tmp;
	    DSSS[3] += PA[0]*psss[0][1] + WP[0]*psss[1][1];
	    DSSS[5] += PA[1]*psss[0][2] + WP[1]*psss[1][2];
	    DSSS[4] += PA[2]*psss[0][0] + WP[2]*psss[1][0];
            }
          */
          {
	    double tmp = zeta2 * (ssss[0] - rz*ssss[1]);
            /*
#pragma unroll
          for (int i=0; i<3; i++)
          {
            double psss0,psss1;
            int i2 = (i+2)%3;

	    psss0 = PA[i]*ssss[0]+WP[i]*ssss[1];
            psss1 = PA[i]*ssss[1]+WP[i]*ssss[2];
//	    DSSS[i   ] += PA[i ]*psss0 + WP[i ]*psss1 + tmp;
//	    DSSS[i2+3] += PA[i2]*psss0 + WP[i2]*psss1;
	    dsss[i   ] += PA[i ]*psss0 + WP[i ]*psss1 + tmp;
	    dsss[i2+3] += PA[i2]*psss0 + WP[i2]*psss1;

          }
          */
          {
            double psss0,psss1;
	    psss0 = PA[0]*ssss[0]+WP[0]*ssss[1];
            psss1 = PA[0]*ssss[1]+WP[0]*ssss[2];
	    dsss[0] += PA[0]*psss0 + WP[0]*psss1 + tmp;
	    dsss[4] += PA[2]*psss0 + WP[2]*psss1;
	    //DSSS[0] += PA[0]*psss0 + WP[0]*psss1 + tmp;
	    //DSSS[4] += PA[2]*psss0 + WP[2]*psss1;

	    psss0 = PA[1]*ssss[0]+WP[1]*ssss[1];
            psss1 = PA[1]*ssss[1]+WP[1]*ssss[2];
	    dsss[1] += PA[1]*psss0 + WP[1]*psss1 + tmp;
	    dsss[3] += PA[0]*psss0 + WP[0]*psss1;
	    //DSSS[1] += PA[1]*psss0 + WP[1]*psss1 + tmp;
	    //DSSS[3] += PA[0]*psss0 + WP[0]*psss1;

	    psss0 = PA[2]*ssss[0]+WP[2]*ssss[1];
            psss1 = PA[2]*ssss[1]+WP[2]*ssss[2];
	    dsss[2] += PA[2]*psss0 + WP[2]*psss1 + tmp;
	    dsss[5] += PA[1]*psss0 + WP[1]*psss1;
	    //DSSS[2] += PA[2]*psss0 + WP[2]*psss1 + tmp;
	    //DSSS[5] += PA[1]*psss0 + WP[1]*psss1;
          }
          }
	}	// klps
    }	// ijps
    {
    double sqr3 = sqrt(3.e0);
#pragma unroll
//    for (int i=3; i<6; i++ ) DSSS[i] *= sqr3;
    for (int i=0; i<3; i++ ) DSSS[i] = dsss[i];
#pragma unroll
    for (int i=3; i<6; i++ ) DSSS[i] = dsss[i] * sqr3;
    }
}

#if 0
/** １つのCS４重対に対して(ds,ps)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_dsps_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double DSPS[6*3] ) {
//    int ijps, klps, i, m, m1;
    double cssss, zeta, dkab, xiza, eta, xizc, dk;
    double rz, re, ze2, ze22, zeta2, tmp;
    double sqrho, rho, PQ2, T;
    double PC[3], PA[3], WP[3], QP[3], QC[3], WQ[3];
    double ssss[3+1], psss[2+1][3], dsss[1+1][6];
    double sqr3;
    sqr3 = sqrt(3.e0);
#pragma unroll
    for (int i=0; i<6*3; i++ ) DSPS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
	zeta = vzeta[ijps];
	dkab = vdkab[ijps];
	xiza = vxiza[ijps];
	zeta2 = HALF * zeta;
#pragma unroll
	for (int i=0; i<3; i++ ) {
	    PC[i] = AC[i] + xiza*BA[i];
	    PA[i] = xiza * BA[i];
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
	    eta  = veta[klps];
	    dk   = dkab * vdkcd[klps];
	    xizc = vxizc[klps];
	    PQ2  = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		QC[i] = xizc*DC[i];
		QP[i] = xizc*DC[i] - PC[i];
		PQ2  += QP[i]*QP[i];
	    }
	    sqrho = sqrt(1.e0/(zeta+eta));
	    rho   = sqrho*sqrho;
	    rz    = rho * zeta;
	    re    = rho * eta;
	    ze2   = re  * zeta2;
	    ze22  = re  * zeta;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		WP[i] = rz*QP[i];
		WQ[i] = rz*QP[i] - QP[i];
	    }
	    T     = rho * PQ2;
	    cssss = sqrho * dk;
	    //gpu_fmt( ssss, 3, T, cssss );
#if   CUDA_FMT_M == 3
	    gpu_fmt3_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt3_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt3_method1( T, cssss, ssss );
#else
	    gpu_fmt3( ssss, T, cssss );
#endif
/*
	    // psss
#pragma unroll
	    for (int m=0; m<=2; m++ ) {
		m1 = m+1;
#pragma unroll
		for ( i=0; i<3; i++ )
		    psss[m][i] = PA[i]*ssss[m]+WP[i]*ssss[m1];
	    }
	    // dsss
#pragma unroll
	    for (int m=0; m<=1; m++) {
		m1 = m+1;
		tmp = ssss[m] - rz*ssss[m1];

		dsss[m][0] = PA[0]*psss[m][0] + WP[0]*psss[m1][0]
		    + zeta2*tmp;
		dsss[m][1] = PA[1]*psss[m][1] + WP[1]*psss[m1][1]
			   + zeta2*tmp;
		dsss[m][2] = PA[2]*psss[m][2] + WP[2]*psss[m1][2]
			   + zeta2*tmp;
		dsss[m][3] = PA[0]*psss[m][1] + WP[0]*psss[m1][1];
		dsss[m][4] = PA[1]*psss[m][2] + WP[1]*psss[m1][2];
		dsss[m][5] = PA[2]*psss[m][0] + WP[2]*psss[m1][0];
	    }
	    // dsps
	    DSPS[0*3+0] += QC[0]*dsss[0][0] + WQ[0]*dsss[1][0]
			+ ze22*psss[1][0];
	    DSPS[0*3+1] += QC[1]*dsss[0][0] + WQ[1]*dsss[1][0];
	    DSPS[0*3+2] += QC[2]*dsss[0][0] + WQ[2]*dsss[1][0];
	    DSPS[1*3+0] += QC[0]*dsss[0][1] + WQ[0]*dsss[1][1];
	    DSPS[1*3+1] += QC[1]*dsss[0][1] + WQ[1]*dsss[1][1]
			+ ze22*psss[1][1];
	    DSPS[1*3+2] += QC[2]*dsss[0][1] + WQ[2]*dsss[1][1];
	    DSPS[2*3+0] += QC[0]*dsss[0][2] + WQ[0]*dsss[1][2];
	    DSPS[2*3+1] += QC[1]*dsss[0][2] + WQ[1]*dsss[1][2];
	    DSPS[2*3+2] += QC[2]*dsss[0][2] + WQ[2]*dsss[1][2]
			+ ze22*psss[1][2];
	    DSPS[3*3+0] += QC[0]*dsss[0][3] + WQ[0]*dsss[1][3]
			+ ze2*psss[1][1];
	    DSPS[3*3+1] += QC[1]*dsss[0][3] + WQ[1]*dsss[1][3]
			+ ze2*psss[1][0];
	    DSPS[3*3+2] += QC[2]*dsss[0][3] + WQ[2]*dsss[1][3];
	    DSPS[4*3+0] += QC[0]*dsss[0][4] + WQ[0]*dsss[1][4];
	    DSPS[4*3+1] += QC[1]*dsss[0][4] + WQ[1]*dsss[1][4]
			+ ze2*psss[1][2];
	    DSPS[4*3+2] += QC[2]*dsss[0][4] + WQ[2]*dsss[1][4]
			+ ze2*psss[1][1];
	    DSPS[5*3+0] += QC[0]*dsss[0][5] + WQ[0]*dsss[1][5]
			+ ze2*psss[1][2];
	    DSPS[5*3+1] += QC[1]*dsss[0][5] + WQ[1]*dsss[1][5];
	    DSPS[5*3+2] += QC[2]*dsss[0][5] + WQ[2]*dsss[1][5]
			+ ze2*psss[1][0];
*/
            {
              double z0, z1;
              rz = -rz;
              z0 = zeta2*(ssss[0] + rz*ssss[1]);
              z1 = zeta2*(ssss[1] + rz*ssss[2]);
#pragma unroll
            for (int j=0; j<3; j++)
            {
              double dsss0, dsss1;
              double psss[3];
              int j2,j3;
	    // dsps
#pragma unroll
            for (int i=0; i<3; i++) 
              psss[i] = PA[j]*ssss[i]+WP[j]*ssss[i+1];
            dsss0 = PA[j]*psss[0] + WP[j]*psss[1] + z0;
            dsss1 = PA[j]*psss[1] + WP[j]*psss[2] + z1;
#pragma unroll
            for (int i=0; i<3; i++) 
              DSPS[j*3+i] += QC[i]*dsss0 + WQ[i]*dsss1;
	    DSPS[j*3+j] += ze22*psss[1];

            j2 = (j+2)%3;
            j3 = (j2+3)*3;
            dsss0 = PA[j2]*psss[0] + WP[j2]*psss[1];
            dsss1 = PA[j2]*psss[1] + WP[j2]*psss[2];
#pragma unroll
            for (int i=0; i<3; i++) 
              DSPS[j3+i] += QC[i]*dsss0 + WQ[i]*dsss1;
	    DSPS[j3+j2] += ze2*psss[1];

            j2 = (j+1)%3;
	    DSPS[(j+3)*3+j2] += ze2*psss[1];
            }
            }
	}	// klps
    }	// ijps
#pragma unroll
    for (int  i=3*3; i<6*3; i++) DSPS[i] *= sqr3;
}

/** １つのCS４重対に対して(ds,pp)タイプの２電子積分を計算する関数
 * @ingroup core-twoint
 * */
__device__ void gpu_twoint_core_dspp_(
	const int *nijps, const double vzeta[], const double vdkab[],
	const double vxiza[], const double BA[3],
	const int *nklps, const double veta[], const double vdkcd[],
	const double vxizc[], const double DC[3], const double AC[3],
	double DSPP[6*3*3] ) {
//    int ijps, klps, i, m, m1;
//    int ab, ab01, ab10, ab00;
//    double cssss, zeta, dkab, xiza, eta, xizc, dk;
//    double rz, re, ze2, ze22, zeta2, eta2;
//    double tmp, tmp6[6];
//    double sqrho, rho, PQ2, T;
//    double PC[3], PA[3], WP[3], QP[3], QC[3], WQ[3];
//    double ssss[4+1], psss[3+1][3], dsss[2+1][6];
//    double psps[3*3], dsps[1+1][6*3];
    double DSPS[6*3], DSDS[6*6];
#pragma unroll
    for (int i=0; i<6*3; i++ ) DSPS[i] = ZERO;
#pragma unroll
    for (int i=0; i<6*6; i++ ) DSDS[i] = ZERO;
    for (int ijps=0; ijps<(*nijps); ijps++ ) {
      double zeta, dkab, xiza, zeta2;
      double PC[3], PA[3];
	zeta = vzeta[ijps];
	dkab = vdkab[ijps];
	xiza = vxiza[ijps];
	zeta2 = HALF * zeta;
#pragma unroll
	for (int i=0; i<3; i++ ) {
	    PC[i] = AC[i] + xiza*BA[i];
	    PA[i] = xiza * BA[i];
	}
	for (int klps=0; klps<(*nklps); klps++ ) {
          double cssss, eta, xizc, dk;
          double rz, re, ze2, ze22, eta2;
          double sqrho, rho, PQ2, T;
          double ssss[4+1];
          double WP[3], QP[3], QC[3], WQ[3];
	    eta  = veta[klps];
	    dk   = dkab * vdkcd[klps];
	    xizc = vxizc[klps];
	    eta2 = HALF * eta;
	    PQ2  = ZERO;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		QC[i] = xizc*DC[i];
		QP[i] = xizc*DC[i] - PC[i];
		PQ2  += QP[i]*QP[i];
	    }
	    sqrho = sqrt(1.e0/(zeta+eta));
	    rho   = sqrho*sqrho;
	    rz    = rho * zeta;
	    re    = rho * eta;
	    ze2   = rz  * eta2;
	    ze22  = rz  * eta;
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		WP[i] = rz*QP[i];
		WQ[i] = rz*QP[i] - QP[i];
	    }
	    T     = rho * PQ2;
	    cssss = sqrho * dk;
	    //gpu_fmt( ssss, 4, T, cssss );
#if   CUDA_FMT_M == 3
	    gpu_fmt4_method3( T, cssss, ssss );
#elif CUDA_FMT_M == 2
	    gpu_fmt4_method2( T, cssss, ssss );
#elif CUDA_FMT_M == 1
	    gpu_fmt4_method1( T, cssss, ssss );
#else
	    gpu_fmt3( ssss, T, cssss );
#endif
            {
            //  double psss[3+1][3], dsss[2+1][6];
              double psss[3+1][3];
            //  double psps[3*3], dsps[1+1][6*3];
	    // (P,S|S,S)
#pragma unroll
	    for (int m=0; m<=3; m++) {
		int m1 = m+1;
		psss[m][0] = PA[0]*ssss[m] + WP[0]*ssss[m1];
		psss[m][1] = PA[1]*ssss[m] + WP[1]*ssss[m1];
		psss[m][2] = PA[2]*ssss[m] + WP[2]*ssss[m1];
	    }	// end m loop
	    // (D,S|S,S)
            /*
#pragma unroll
	    for (int m=0; m<=2; m++) {
              double tmp;
		int m1 = m+1;
		tmp = ssss[m] - rz*ssss[m1];

		dsss[m][0] = PA[0]*psss[m][0] + WP[0]*psss[m1][0]
			   + zeta2*tmp;
		dsss[m][1] = PA[1]*psss[m][1] + WP[1]*psss[m1][1]
			   + zeta2*tmp;
		dsss[m][2] = PA[2]*psss[m][2] + WP[2]*psss[m1][2]
			   + zeta2*tmp;
		dsss[m][3] = PA[0]*psss[m][1] + WP[0]*psss[m1][1];
		dsss[m][4] = PA[1]*psss[m][2] + WP[1]*psss[m1][2];
		dsss[m][5] = PA[2]*psss[m][0] + WP[2]*psss[m1][0];
	    }	// end m loop
#pragma unroll
	    for (int i=0; i<6; i++) {
              double tmp = dsss[0][i] - re*dsss[1][i];
	      DSDS[i*6+0] += eta2*tmp;
	      DSDS[i*6+1] += eta2*tmp;
	      DSDS[i*6+2] += eta2*tmp;
            }
            */
	    // (P,S|P,S)
            /*
	    psps[0*3+0] = QC[0]*psss[1][0] + WQ[0]*psss[2][0]
			+ ze2*ssss[2];
	    psps[0*3+1] = QC[1]*psss[1][0] + WQ[1]*psss[2][0];
	    psps[0*3+2] = QC[2]*psss[1][0] + WQ[2]*psss[2][0];
	    psps[1*3+0] = QC[0]*psss[1][1] + WQ[0]*psss[2][1];
	    psps[1*3+1] = QC[1]*psss[1][1] + WQ[1]*psss[2][1]
			+ ze2*ssss[2];
	    psps[1*3+2] = QC[2]*psss[1][1] + WQ[2]*psss[2][1];
	    psps[2*3+0] = QC[0]*psss[1][2] + WQ[0]*psss[2][2];
	    psps[2*3+1] = QC[1]*psss[1][2] + WQ[1]*psss[2][2];
	    psps[2*3+2] = QC[2]*psss[1][2] + WQ[2]*psss[2][2]
			+ ze2*ssss[2];
            */
	    // (D,S|P,S)
            /*
#pragma unroll
	    for (int m=0; m<=1; m++) {
		int m1 = m+1;
		dsps[m][0*3+0] = QC[0]*dsss[m][0] + WQ[0]*dsss[m1][0]
			       + ze22*psss[m1][0];
		dsps[m][0*3+1] = QC[1]*dsss[m][0] + WQ[1]*dsss[m1][0];
		dsps[m][0*3+2] = QC[2]*dsss[m][0] + WQ[2]*dsss[m1][0];
		dsps[m][1*3+0] = QC[0]*dsss[m][1] + WQ[0]*dsss[m1][1];
		dsps[m][1*3+1] = QC[1]*dsss[m][1] + WQ[1]*dsss[m1][1]
			       + ze22*psss[m1][1];
		dsps[m][1*3+2] = QC[2]*dsss[m][1] + WQ[2]*dsss[m1][1];
		dsps[m][2*3+0] = QC[0]*dsss[m][2] + WQ[0]*dsss[m1][2];
		dsps[m][2*3+1] = QC[1]*dsss[m][2] + WQ[1]*dsss[m1][2];
		dsps[m][2*3+2] = QC[2]*dsss[m][2] + WQ[2]*dsss[m1][2]
			       + ze22*psss[m1][2];
		dsps[m][3*3+0] = QC[0]*dsss[m][3] + WQ[0]*dsss[m1][3]
			       + ze2*psss[m1][1];
		dsps[m][3*3+1] = QC[1]*dsss[m][3] + WQ[1]*dsss[m1][3]
			       + ze2*psss[m1][0];
		dsps[m][3*3+2] = QC[2]*dsss[m][3] + WQ[2]*dsss[m1][3];
		dsps[m][4*3+0] = QC[0]*dsss[m][4] + WQ[0]*dsss[m1][4];
		dsps[m][4*3+1] = QC[1]*dsss[m][4] + WQ[1]*dsss[m1][4]
			       + ze2*psss[m1][2];
		dsps[m][4*3+2] = QC[2]*dsss[m][4] + WQ[2]*dsss[m1][4]
			       + ze2*psss[m1][1];
		dsps[m][5*3+0] = QC[0]*dsss[m][5] + WQ[0]*dsss[m1][5]
			       + ze2*psss[m1][2];
		dsps[m][5*3+1] = QC[1]*dsss[m][5] + WQ[1]*dsss[m1][5];
		dsps[m][5*3+2] = QC[2]*dsss[m][5] + WQ[2]*dsss[m1][5]
			       + ze2*psss[m1][0];
	    }	// end m loop
            */

            /*
#pragma unroll
	    for (int i=0; i<6*3; i++ ) DSPS[i] += dsps[0][i];
            */
	    // (D,S|D,S)
            /*
#pragma unroll
//	    for (int i=0; i<6; i++) tmp6[i] = dsss[0][i] - re*dsss[1][i];
	    for (int i=0; i<6; i++) {
              double tmp = dsss[0][i] - re*dsss[1][i];
	      DSDS[i*6+0] += eta2*tmp;
	      DSDS[i*6+1] += eta2*tmp;
	      DSDS[i*6+2] += eta2*tmp;
            }
            */

            /*
	    DSDS[0*6+0] += QC[0]*dsps[0][0*3+0] + WQ[0]*dsps[1][0*3+0]
			+   eta2*tmp6[0] + ze22*psps[0*3+0];
	    DSDS[0*6+1] += QC[1]*dsps[0][0*3+1] + WQ[1]*dsps[1][0*3+1]
			+   eta2*tmp6[0];
	    DSDS[0*6+2] += QC[2]*dsps[0][0*3+2] + WQ[2]*dsps[1][0*3+2]
			+   eta2*tmp6[0];
	    DSDS[0*6+3] += QC[0]*dsps[0][0*3+1] + WQ[0]*dsps[1][0*3+1]
			+ ze22*psps[0*3+1];
	    DSDS[0*6+4] += QC[1]*dsps[0][0*3+2] + WQ[1]*dsps[1][0*3+2];
	    DSDS[0*6+5] += QC[2]*dsps[0][0*3+0] + WQ[2]*dsps[1][0*3+0];
	    DSDS[1*6+0] += QC[0]*dsps[0][1*3+0] + WQ[0]*dsps[1][1*3+0]
			+   eta2*tmp6[1];
	    DSDS[1*6+1] += QC[1]*dsps[0][1*3+1] + WQ[1]*dsps[1][1*3+1]
			+   eta2*tmp6[1] + ze22*psps[1*3+1];
	    DSDS[1*6+2] += QC[2]*dsps[0][1*3+2] + WQ[2]*dsps[1][1*3+2]
			+   eta2*tmp6[1];
	    DSDS[1*6+3] += QC[0]*dsps[0][1*3+1] + WQ[0]*dsps[1][1*3+1];
	    DSDS[1*6+4] += QC[1]*dsps[0][1*3+2] + WQ[1]*dsps[1][1*3+2]
			+ ze22*psps[1*3+2];
	    DSDS[1*6+5] += QC[2]*dsps[0][1*3+0] + WQ[2]*dsps[1][1*3+0];
	    DSDS[2*6+0] += QC[0]*dsps[0][2*3+0] + WQ[0]*dsps[1][2*3+0]
			+   eta2*tmp6[2];
	    DSDS[2*6+1] += QC[1]*dsps[0][2*3+1] + WQ[1]*dsps[1][2*3+1]
			+   eta2*tmp6[2];
	    DSDS[2*6+2] += QC[2]*dsps[0][2*3+2] + WQ[2]*dsps[1][2*3+2]
			+   eta2*tmp6[2] + ze22*psps[2*3+2];
	    DSDS[2*6+3] += QC[0]*dsps[0][2*3+1] + WQ[0]*dsps[1][2*3+1];
	    DSDS[2*6+4] += QC[1]*dsps[0][2*3+2] + WQ[1]*dsps[1][2*3+2];
	    DSDS[2*6+5] += QC[2]*dsps[0][2*3+0] + WQ[2]*dsps[1][2*3+0]
			+ ze22*psps[2*3+0];
	    DSDS[3*6+0] += QC[0]*dsps[0][3*3+0] + WQ[0]*dsps[1][3*3+0]
			+   eta2*tmp6[3] + ze2*psps[1*3+0];
	    DSDS[3*6+1] += QC[1]*dsps[0][3*3+1] + WQ[1]*dsps[1][3*3+1]
			+   eta2*tmp6[3] + ze2*psps[0*3+1];
	    DSDS[3*6+2] += QC[2]*dsps[0][3*3+2] + WQ[2]*dsps[1][3*3+2]
			+   eta2*tmp6[3];
	    DSDS[3*6+3] += QC[0]*dsps[0][3*3+1] + WQ[0]*dsps[1][3*3+1]
			+ ze2*psps[1*3+1];
	    DSDS[3*6+4] += QC[1]*dsps[0][3*3+2] + WQ[1]*dsps[1][3*3+2]
			+ ze2*psps[0*3+2];
	    DSDS[3*6+5] += QC[2]*dsps[0][3*3+0] + WQ[2]*dsps[1][3*3+0];
	    DSDS[4*6+0] += QC[0]*dsps[0][4*3+0] + WQ[0]*dsps[1][4*3+0]
			+   eta2*tmp6[4];
	    DSDS[4*6+1] += QC[1]*dsps[0][4*3+1] + WQ[1]*dsps[1][4*3+1]
			+   eta2*tmp6[4] + ze2*psps[2*3+1];
	    DSDS[4*6+2] += QC[2]*dsps[0][4*3+2] + WQ[2]*dsps[1][4*3+2]
			+   eta2*tmp6[4] + ze2*psps[1*3+2];
	    DSDS[4*6+3] += QC[0]*dsps[0][4*3+1] + WQ[0]*dsps[1][4*3+1];
	    DSDS[4*6+4] += QC[1]*dsps[0][4*3+2] + WQ[1]*dsps[1][4*3+2]
			+ ze2*psps[2*3+2];
	    DSDS[4*6+5] += QC[2]*dsps[0][4*3+0] + WQ[2]*dsps[1][4*3+0]
			+ ze2*psps[1*3+0];
	    DSDS[5*6+0] += QC[0]*dsps[0][5*3+0] + WQ[0]*dsps[1][5*3+0]
			+   eta2*tmp6[5] + ze2*psps[2*3+0];
	    DSDS[5*6+1] += QC[1]*dsps[0][5*3+1] + WQ[1]*dsps[1][5*3+1]
			+   eta2*tmp6[5];
	    DSDS[5*6+2] += QC[2]*dsps[0][5*3+2] + WQ[2]*dsps[1][5*3+2]
			+   eta2*tmp6[5] + ze2*psps[0*3+2];
	    DSDS[5*6+3] += QC[0]*dsps[0][5*3+1] + WQ[0]*dsps[1][5*3+1]
			+ ze2*psps[2*3+1];
	    DSDS[5*6+4] += QC[1]*dsps[0][5*3+2] + WQ[1]*dsps[1][5*3+2];
	    DSDS[5*6+5] += QC[2]*dsps[0][5*3+0] + WQ[2]*dsps[1][5*3+0]
			+ ze2*psps[0*3+0];
            */
            /*
            {
            double dsps[6*3][1+1];
            int i3x[]={0,1,2,1,2,0};
            for (int j=0; j<6; j++) {
#pragma unroll
              for (int i=0; i<3; i++) {
                dsps[j*3+i][0] = QC[i]*dsss[0][j] + WQ[i]*dsss[1][j];
                dsps[j*3+i][1] = QC[i]*dsss[1][j] + WQ[i]*dsss[2][j];
              }
              {
                double zz=(j<3)? ze22: ze2;
                int j0 = (j<3)? j: j%3;
                int j1 = (j<3)? j: (j+1)%3;
		dsps[j*3+j0][0] += zz*psss[1][j1];
		dsps[j*3+j0][1] += zz*psss[2][j1];
                if (j>=3) {
		dsps[j*3+j1][0] += zz*psss[1][j0];
		dsps[j*3+j1][1] += zz*psss[2][j0];
                }
              }
              for (int i=0; i<3; i++) 
	        DSPS[j*3+i] += dsps[j*3+i][0];
#pragma unroll
              for (int i=0; i<6; i++) { 
                //DSDS[j*6+i] += QC[i%3]*dsps[0][j*3+i3x[i]] + WQ[i%3]*dsps[1][j*3+i3x[i]];
                DSDS[j*6+i] += QC[i%3]*dsps[j*3+i3x[i]][0] + WQ[i%3]*dsps[j*3+i3x[i]][1];
              }
            } 
            } //dsps
            */

            {
              double dsss[2+1];
              double dsps[3][1+1];
#pragma unroll
            for (int j=0; j<6; j++) {
              int j0 = j%3;
              int j1 = (j<3)? j: (j+1)%3;
              double zt = (j<3)? zeta2: 0;
#pragma unroll
	    for (int m=0; m<=2; m++) {
              double tmp;
		int m1 = m+1;
		tmp = ssss[m] - rz*ssss[m1];

		dsss[m] = PA[j0]*psss[m][j1] + WP[j0]*psss[m1][j1] + zt*tmp;
	    }	// end m loop
            {
              double tmp = dsss[0] - re*dsss[1];
	      DSDS[j*6+0] += eta2*tmp;
	      DSDS[j*6+1] += eta2*tmp;
	      DSDS[j*6+2] += eta2*tmp;
            }

#pragma unroll
              for (int i=0; i<3; i++) {
                dsps[i][0] = QC[i]*dsss[0] + WQ[i]*dsss[1];
                dsps[i][1] = QC[i]*dsss[1] + WQ[i]*dsss[2];
              }
                zt=(j<3)? ze22: ze2;
		dsps[j0][0] += zt*psss[1][j1];
		dsps[j0][1] += zt*psss[2][j1];
                if (j>=3) {
		dsps[j1][0] += zt*psss[1][j0];
		dsps[j1][1] += zt*psss[2][j0];
                }
#pragma unroll
              for (int i=0; i<3; i++) 
	        DSPS[j*3+i] += dsps[i][0];
#pragma unroll
              for (int i=0; i<6; i++) { 
                //DSDS[j*6+i] += QC[i%3]*dsps[i3x[i]][0] + WQ[i%3]*dsps[i3x[i]][1];
                int i1 = (i<3)? i: (i+1)%3;
                DSDS[j*6+i] += QC[i%3]*dsps[i1][0] + WQ[i%3]*dsps[i1][1];
              }
            }
            } //dsss, dsps

            // Should be parallelize with 6 threads
#pragma unroll
            for (int j=0; j<3; j++) {
              double psps[3];
              int j1=(j+1)%3;
              int j2=(j+2)%3;
#pragma unroll
              for (int i=0; i<3; i++) {
	        psps[i] = QC[i]*psss[1][j] + WQ[i]*psss[2][j];
              }
	      psps[j] += ze2*ssss[2];

              DSDS[j*6+j]   += ze22*psps[j];
              DSDS[j*6+j+3] += ze22*psps[j1];
	      DSDS[(j2+3)*6+j2] += ze2*psps[j2];
	      DSDS[(j2+3)*6+j2+3] += ze2*psps[j];
	      DSDS[(j+3)*6+j1] += ze2*psps[j1];
	      DSDS[(j+3)*6+j1+3] += ze2*psps[j2];
            }
            /*
	    DSDS[0*6+0] += ze22*psps[0*3+0];
	    DSDS[0*6+3] += ze22*psps[0*3+1];
	    DSDS[1*6+1] += ze22*psps[1*3+1];
	    DSDS[1*6+4] += ze22*psps[1*3+2];
	    DSDS[2*6+2] += ze22*psps[2*3+2];
	    DSDS[2*6+5] += ze22*psps[2*3+0];

	    DSDS[3*6+0] += ze2*psps[1*3+0];
	    DSDS[3*6+3] += ze2*psps[1*3+1];
	    DSDS[4*6+1] += ze2*psps[2*3+1];
	    DSDS[4*6+4] += ze2*psps[2*3+2];
	    DSDS[5*6+0] += ze2*psps[2*3+0];
	    DSDS[5*6+3] += ze2*psps[2*3+1];

	    DSDS[3*6+1] += ze2*psps[0*3+1];
	    DSDS[3*6+4] += ze2*psps[0*3+2];
	    DSDS[4*6+2] += ze2*psps[1*3+2];
	    DSDS[4*6+5] += ze2*psps[1*3+0];
	    DSDS[5*6+2] += ze2*psps[0*3+2];
	    DSDS[5*6+5] += ze2*psps[0*3+0];
            */

            }
	}	// klps
    }	// ijps
    // (D,S|P,P)
#pragma unroll
    for (int ab=0, ab01=0, ab10=0, ab00=0;
            ab<6; ab++, ab01 += 3*3, ab10 += 6, ab00 += 3) {
        DSPP[ab01+0*3+0] = DSDS[ab10+0] - DC[0]*DSPS[ab00+0];
        DSPP[ab01+0*3+1] = DSDS[ab10+3] - DC[1]*DSPS[ab00+0];
        DSPP[ab01+0*3+2] = DSDS[ab10+5] - DC[2]*DSPS[ab00+0];
        DSPP[ab01+1*3+0] = DSDS[ab10+3] - DC[0]*DSPS[ab00+1];
        DSPP[ab01+1*3+1] = DSDS[ab10+1] - DC[1]*DSPS[ab00+1];
        DSPP[ab01+1*3+2] = DSDS[ab10+4] - DC[2]*DSPS[ab00+1];
        DSPP[ab01+2*3+0] = DSDS[ab10+5] - DC[0]*DSPS[ab00+2];
        DSPP[ab01+2*3+1] = DSDS[ab10+4] - DC[1]*DSPS[ab00+2];
        DSPP[ab01+2*3+2] = DSDS[ab10+2] - DC[2]*DSPS[ab00+2];
    }
    {
    double sqr3;
    sqr3 = sqrt(3.e0);
#pragma unroll
    for (int i=3*3*3; i<6*3*3; i++ ) DSPP[i] *= sqr3;
    }
}

#endif /* 0 */
// dsss
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_os_dsss( double *eh ) {
    int i;
    // (DS|SS)
#pragma unroll
    for ( i=0; i<(0+6); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_coef_os_dsss(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 0;
#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
        coef_ab = coef_a;
        coef_abc = coef_ab;
        DINT[ix] = coef_abc * eh[ix];
        ix++;
    }
}

__device__ void gpu_vrr_calc_os_dsss(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
  double dtmp;
    // (ss|ss) m=0,2
    //gpu_fmt( &ev[0], 2, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt2_method3( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 2
    gpu_fmt2_method2( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 1
    gpu_fmt2_method1( T, cssss, &ev[0] );
#else
    gpu_fmt2( &ev[0], T, cssss );
#endif
    dtmp = zeta2*(ev[0]-rz*ev[1]);
    // (ps|ss) m=0,1
    ev[3]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[4]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[5]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[6]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[7]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[8]=PA[2]*ev[1]+WP[2]*ev[2];
    // (ds|ss) m=0,0
    //ev[ 9]=PA[0]*ev[3]+WP[0]*ev[6]+zeta2*(ev[0]-rz*ev[1]);
    //ev[10]=PA[1]*ev[4]+WP[1]*ev[7]+zeta2*(ev[0]-rz*ev[1]);
    //ev[11]=PA[2]*ev[5]+WP[2]*ev[8]+zeta2*(ev[0]-rz*ev[1]);
    ev[ 9]=PA[0]*ev[3]+WP[0]*ev[6]+dtmp;
    ev[10]=PA[1]*ev[4]+WP[1]*ev[7]+dtmp;
    ev[11]=PA[2]*ev[5]+WP[2]*ev[8]+dtmp;
    ev[12]=PA[0]*ev[4]+WP[0]*ev[7];
    ev[13]=PA[0]*ev[5]+WP[0]*ev[8];
    ev[14]=PA[1]*ev[5]+WP[1]*ev[8];
}

__device__ void gpu_vrr_cint_os_dsss( const double *ev, double *eh ) {
    int La=2, Lb=0, Lc=0, Ld=0;
    int i, ih, iv;
    // (DS|SS)
#pragma unroll
    for ( i=0, iv=9, ih=0; i<6; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dsss(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[15];

    gpu_hrr_clear_os_dsss( DINT );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            PQ2  = ZERO;
            for ( i=0; i<3; i++ ) {
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            ze2 = rz * eta * HALF;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_os_dsss(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_os_dsss( ev, DINT );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_coef_os_dsss( DINT, DINT );
}

#if 0
int ofmo_twoint_os_dsss(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*1*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;

    
    mythread = omp_get_thread_num();
//    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*1*1*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dsss(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=1*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<1; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_dsss(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*1*1];
    int mythread;

    mythread = omp_get_thread_num();
//    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) { 
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }
    
    max_nzeri -= 6*1*1*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }
    
    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dsss(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=1*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<1; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
// dsps
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_os_dsps( double *eh ) {
    int i;
    // (DS|PS)
#pragma unroll
    for ( i=0; i<(0+18); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_coef_os_dsps(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 0;
#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
        coef_ab = coef_a;
#pragma unroll
        for ( k=0, kao=1; k<3; k++, kao++ ) {
            coef_abc = coef_ab * LDG(DFACT[kao]);
            //DINT[ix] = coef_abc * eh[ix];
            //ix++;
            DINT[ix++] *= coef_abc;
        }
    }
}

__device__ void gpu_vrr_calc_os_dsps(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *eh ) {
    double tmp0,tmp1;
    double ev[12];
    double ep[9];
    // (ss|ss) m=0,3
    //gpu_fmt( &ev[0], 3, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt3_method3( T, cssss, ev );
#elif CUDA_FMT_M == 2
    gpu_fmt3_method2( T, cssss, ev );
#elif CUDA_FMT_M == 1
    gpu_fmt3_method1( T, cssss, ev );
#else
    gpu_fmt3( ev, T, cssss );
#endif
    tmp0 = zeta2*(ev[0]-rz*ev[1]);
    tmp1 = zeta2*(ev[1]-rz*ev[2]);
    // (ps|ss) m=0,2
    ep[ 0]=PA[0]*ev[0]+WP[0]*ev[1];
    ep[ 1]=PA[1]*ev[0]+WP[1]*ev[1];
    ep[ 2]=PA[2]*ev[0]+WP[2]*ev[1];
    ep[ 3]=PA[0]*ev[1]+WP[0]*ev[2];
    ep[ 4]=PA[1]*ev[1]+WP[1]*ev[2];
    ep[ 5]=PA[2]*ev[1]+WP[2]*ev[2];
    ep[ 6]=PA[0]*ev[2]+WP[0]*ev[3];
    ep[ 7]=PA[1]*ev[2]+WP[1]*ev[3];
    ep[ 8]=PA[2]*ev[2]+WP[2]*ev[3];
    // (ds|ss) m=0,1
    ev[ 0]=PA[0]*ep[0]+WP[0]*ep[ 3]+tmp0;
    ev[ 1]=PA[0]*ep[3]+WP[0]*ep[ 6]+tmp1;
    ev[ 2]=PA[1]*ep[1]+WP[1]*ep[ 4]+tmp0;
    ev[ 3]=PA[1]*ep[4]+WP[1]*ep[ 7]+tmp1;
    ev[ 4]=PA[2]*ep[2]+WP[2]*ep[ 5]+tmp0;
    ev[ 5]=PA[2]*ep[5]+WP[2]*ep[ 8]+tmp1;
    ev[ 6]=PA[0]*ep[1]+WP[0]*ep[ 4];
    ev[ 7]=PA[0]*ep[4]+WP[0]*ep[ 7];
    ev[ 8]=PA[0]*ep[2]+WP[0]*ep[ 5];
    ev[ 9]=PA[0]*ep[5]+WP[0]*ep[ 8];
    ev[10]=PA[1]*ep[2]+WP[1]*ep[ 5];
    ev[11]=PA[1]*ep[5]+WP[1]*ep[ 8];
    // (ds|ps) m=[0,0]
    eh[ 0]+=QC[0]*ev[ 0]+WQ[0]*ev[ 1]+2.e0*ze2*ep[3];
    eh[ 1]+=QC[1]*ev[ 0]+WQ[1]*ev[ 1];
    eh[ 2]+=QC[2]*ev[ 0]+WQ[2]*ev[ 1];
    eh[ 3]+=QC[0]*ev[ 2]+WQ[0]*ev[ 3];
    eh[ 4]+=QC[1]*ev[ 2]+WQ[1]*ev[ 3]+2.e0*ze2*ep[4];
    eh[ 5]+=QC[2]*ev[ 2]+WQ[2]*ev[ 3];
    eh[ 6]+=QC[0]*ev[ 4]+WQ[0]*ev[ 5];
    eh[ 7]+=QC[1]*ev[ 4]+WQ[1]*ev[ 5];
    eh[ 8]+=QC[2]*ev[ 4]+WQ[2]*ev[ 5]+2.e0*ze2*ep[5];
    eh[ 9]+=QC[0]*ev[ 6]+WQ[0]*ev[ 7]+     ze2*ep[4];
    eh[10]+=QC[1]*ev[ 6]+WQ[1]*ev[ 7]+     ze2*ep[3];
    eh[11]+=QC[2]*ev[ 6]+WQ[2]*ev[ 7];
    eh[12]+=QC[0]*ev[ 8]+WQ[0]*ev[ 9]+     ze2*ep[5];
    eh[13]+=QC[1]*ev[ 8]+WQ[1]*ev[ 9];
    eh[14]+=QC[2]*ev[ 8]+WQ[2]*ev[ 9]+     ze2*ep[3];
    eh[15]+=QC[0]*ev[10]+WQ[0]*ev[11];
    eh[16]+=QC[1]*ev[10]+WQ[1]*ev[11]+     ze2*ep[5];
    eh[17]+=QC[2]*ev[10]+WQ[2]*ev[11]+     ze2*ep[4];
}

__device__ void gpu_vrr_cint_os_dsps( const double *ev, double *eh ) {
    int La=2, Lb=0, Lc=1, Ld=0;
    int i, ih, iv;
    // (DS|PS)
#pragma unroll
    //for ( i=0, iv=25, ih=0; i<18; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    for ( i=0; i<18; i++) eh[i]+=ev[i];
}

__device__ void gpu_twoint_core_os_dsps(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
//    double ev[18];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

    gpu_hrr_clear_os_dsps( DINT );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            ze2 = rz * eta * HALF;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_os_dsps(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    //ev );
                    DINT );
            //gpu_vrr_cint_os_dsps( ev, DINT );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_coef_os_dsps( DINT, DINT );
}

#if 0
int gpu_twoint_os_dsps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*3*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;

    
    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = gpu_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*1*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_os_dsps(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int gpu_twoint_direct_os_dsps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*3*1];
    int mythread;

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = gpu_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) { 
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }
    
    max_nzeri -= 6*1*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }
    
    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_os_dsps(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
// dspp
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_os_dspp( double *eh ) {
    int i;
    // (DS|PS)
#pragma unroll
    for ( i=0; i<(0+18); i++ ) eh[i] = 0.e0;
    // (DS|DS)
#pragma unroll
    for ( i=18; i<(18+36); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_calc_os_dspp(
//        const double BA[3], const double DC[3], double *eh ) {
        const double BA[3], const double DC[3], const double *ev, double *eh ) {
    // HRR for (XX|XX)-type integral (center CD)
    // (DS,PP)
#pragma unroll
    for (int i=0,j=0,ix=18,iy=0;i<6;i++) {
      eh[iy++] = ev[ix+0] - DC[0]*ev[j];
      eh[iy++] = ev[ix+3] - DC[1]*ev[j];
      eh[iy++] = ev[ix+4] - DC[2]*ev[j++];
      eh[iy++] = ev[ix+3] - DC[0]*ev[j];
      eh[iy++] = ev[ix+1] - DC[1]*ev[j];
      eh[iy++] = ev[ix+5] - DC[2]*ev[j++];
      eh[iy++] = ev[ix+4] - DC[0]*ev[j];
      eh[iy++] = ev[ix+5] - DC[1]*ev[j];
      eh[iy++] = ev[ix+2] - DC[2]*ev[j++];
      ix+=6;
    }
/*
#pragma unroll
    for (int i=0,iy=0;i<18;i++) {
#pragma unroll
      for (int j=0;j<3;j++) {
        eh[iy++] = -DC[j]*eh[i];
      }
    }

#pragma unroll
    for (int i=0,ix=18,iy=0;i<6;i++) {
      eh[iy++] += eh[ix+0];
      eh[iy++] += eh[ix+3];
      eh[iy++] += eh[ix+4];
      eh[iy++] += eh[ix+3];
      eh[iy++] += eh[ix+1];
      eh[iy++] += eh[ix+5];
      eh[iy++] += eh[ix+4];
      eh[iy++] += eh[ix+5];
      eh[iy++] += eh[ix+2];
      ix+=6;
    }
    */
    /*
    eh[  54] = eh[  18] - DC[0]*eh[   0];
    eh[  55] = eh[  21] - DC[1]*eh[   0];
    eh[  56] = eh[  22] - DC[2]*eh[   0];
    eh[  57] = eh[  21] - DC[0]*eh[   1];
    eh[  58] = eh[  19] - DC[1]*eh[   1];
    eh[  59] = eh[  23] - DC[2]*eh[   1];
    eh[  60] = eh[  22] - DC[0]*eh[   2];
    eh[  61] = eh[  23] - DC[1]*eh[   2];
    eh[  62] = eh[  20] - DC[2]*eh[   2];
    eh[  63] = eh[  24] - DC[0]*eh[   3];
    eh[  64] = eh[  27] - DC[1]*eh[   3];
    eh[  65] = eh[  28] - DC[2]*eh[   3];
    eh[  66] = eh[  27] - DC[0]*eh[   4];
    eh[  67] = eh[  25] - DC[1]*eh[   4];
    eh[  68] = eh[  29] - DC[2]*eh[   4];
    eh[  69] = eh[  28] - DC[0]*eh[   5];
    eh[  70] = eh[  29] - DC[1]*eh[   5];
    eh[  71] = eh[  26] - DC[2]*eh[   5];
    eh[  72] = eh[  30] - DC[0]*eh[   6];
    eh[  73] = eh[  33] - DC[1]*eh[   6];
    eh[  74] = eh[  34] - DC[2]*eh[   6];
    eh[  75] = eh[  33] - DC[0]*eh[   7];
    eh[  76] = eh[  31] - DC[1]*eh[   7];
    eh[  77] = eh[  35] - DC[2]*eh[   7];
    eh[  78] = eh[  34] - DC[0]*eh[   8];
    eh[  79] = eh[  35] - DC[1]*eh[   8];
    eh[  80] = eh[  32] - DC[2]*eh[   8];
    eh[  81] = eh[  36] - DC[0]*eh[   9];
    eh[  82] = eh[  39] - DC[1]*eh[   9];
    eh[  83] = eh[  40] - DC[2]*eh[   9];
    eh[  84] = eh[  39] - DC[0]*eh[  10];
    eh[  85] = eh[  37] - DC[1]*eh[  10];
    eh[  86] = eh[  41] - DC[2]*eh[  10];
    eh[  87] = eh[  40] - DC[0]*eh[  11];
    eh[  88] = eh[  41] - DC[1]*eh[  11];
    eh[  89] = eh[  38] - DC[2]*eh[  11];
    eh[  90] = eh[  42] - DC[0]*eh[  12];
    eh[  91] = eh[  45] - DC[1]*eh[  12];
    eh[  92] = eh[  46] - DC[2]*eh[  12];
    eh[  93] = eh[  45] - DC[0]*eh[  13];
    eh[  94] = eh[  43] - DC[1]*eh[  13];
    eh[  95] = eh[  47] - DC[2]*eh[  13];
    eh[  96] = eh[  46] - DC[0]*eh[  14];
    eh[  97] = eh[  47] - DC[1]*eh[  14];
    eh[  98] = eh[  44] - DC[2]*eh[  14];
    eh[  99] = eh[  48] - DC[0]*eh[  15];
    eh[ 100] = eh[  51] - DC[1]*eh[  15];
    eh[ 101] = eh[  52] - DC[2]*eh[  15];
    eh[ 102] = eh[  51] - DC[0]*eh[  16];
    eh[ 103] = eh[  49] - DC[1]*eh[  16];
    eh[ 104] = eh[  53] - DC[2]*eh[  16];
    eh[ 105] = eh[  52] - DC[0]*eh[  17];
    eh[ 106] = eh[  53] - DC[1]*eh[  17];
    eh[ 107] = eh[  50] - DC[2]*eh[  17];
    */
}

__device__ void gpu_hrr_coef_os_dspp(
        //const double *eh, double *DINT ) {
        const double *DC, const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 54;
    iy = 0;

    /*
#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
        coef_ab = coef_a;
#pragma unroll
        for ( k=0, kao=1; k<3; k++, kao++ ) {
            coef_abc = coef_ab * LDG(DFACT[kao]);
#pragma unroll
            for ( l=0, lao=1; l<3; l++, lao++ ) {
                //DINT[iy] = coef_abc * DFACT[lao] * eh[ix];
                DINT[iy] *= coef_abc * LDG(DFACT[lao]);
                iy++;
                ix++;
            }
        }
    }
    */
    const int ix9[]={0,3,4,3,1,5,4,5,2};
    int iz;
#pragma unroll
    for ( i=0, iao=4, ix=18, iz=0; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
        coef_ab = coef_a;
#pragma unroll
        for ( k=0, kao=1, j=0; k<3; k++, kao++, iz++ ) {
            coef_abc = coef_ab * LDG(DFACT[kao]);
#pragma unroll
            for ( l=0, lao=1; l<3; l++, lao++ ) {
                DINT[iy++] = coef_abc * LDG(DFACT[lao]) *
                  (eh[ix+ix9[j++]] - DC[l]*eh[iz]);
            }
        }
        ix+=6;
    }
}

__device__ void gpu_vrr_calc_os_dspp(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *eh ) {
    double ev[27], ew[36], d[6];
    // (ss|ss) m=0,4
    //gpu_fmt( &ev[0], 4, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt4_method3( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 2
    gpu_fmt4_method2( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 1
    gpu_fmt4_method1( T, cssss, &ev[0] );
#else
    gpu_fmt4( &ev[0], T, cssss );
#endif
    // (ps|ss) m=0,3
    ew[ 0]=PA[0]*ev[0]+WP[0]*ev[1];
    ew[ 1]=PA[1]*ev[0]+WP[1]*ev[1];
    ew[ 2]=PA[2]*ev[0]+WP[2]*ev[1];
    ew[ 3]=PA[0]*ev[1]+WP[0]*ev[2];
    ew[ 4]=PA[1]*ev[1]+WP[1]*ev[2];
    ew[ 5]=PA[2]*ev[1]+WP[2]*ev[2];
    ew[ 6]=PA[0]*ev[2]+WP[0]*ev[3];
    ew[ 7]=PA[1]*ev[2]+WP[1]*ev[3];
    ew[ 8]=PA[2]*ev[2]+WP[2]*ev[3];
    ew[ 9]=PA[0]*ev[3]+WP[0]*ev[4];
    ew[10]=PA[1]*ev[3]+WP[1]*ev[4];
    ew[11]=PA[2]*ev[3]+WP[2]*ev[4];

    d[0] = zeta2*(ev[0]-rz*ev[1]);
    d[1] = zeta2*(ev[1]-rz*ev[2]);
    d[2] = zeta2*(ev[2]-rz*ev[3]);
    d[3] = ze2*ev[2];
    // (ds|ss) m=0,2
    ev[ 0]=PA[0]*ew[ 0]+WP[0]*ew[ 3]+d[0];
    ev[ 1]=PA[1]*ew[ 1]+WP[1]*ew[ 4]+d[0];
    ev[ 2]=PA[2]*ew[ 2]+WP[2]*ew[ 5]+d[0];
    ev[ 3]=PA[0]*ew[ 1]+WP[0]*ew[ 4];
    ev[ 4]=PA[0]*ew[ 2]+WP[0]*ew[ 5];
    ev[ 5]=PA[1]*ew[ 2]+WP[1]*ew[ 5];
    ev[ 6]=PA[0]*ew[ 3]+WP[0]*ew[ 6]+d[1];
    ev[ 7]=PA[1]*ew[ 4]+WP[1]*ew[ 7]+d[1];
    ev[ 8]=PA[2]*ew[ 5]+WP[2]*ew[ 8]+d[1];
    ev[ 9]=PA[0]*ew[ 4]+WP[0]*ew[ 7];
    ev[10]=PA[0]*ew[ 5]+WP[0]*ew[ 8];
    ev[11]=PA[1]*ew[ 5]+WP[1]*ew[ 8];
    ev[12]=PA[0]*ew[ 6]+WP[0]*ew[ 9]+d[2];
    ev[13]=PA[1]*ew[ 7]+WP[1]*ew[10]+d[2];
    ev[14]=PA[2]*ew[ 8]+WP[2]*ew[11]+d[2];
    ev[15]=PA[0]*ew[ 7]+WP[0]*ew[10];
    ev[16]=PA[0]*ew[ 8]+WP[0]*ew[11];
    ev[17]=PA[1]*ew[ 8]+WP[1]*ew[11];
    // (ps|ps) m=[1,1]
    ev[18]=QC[0]*ew[ 3]+WQ[0]*ew[ 6]+d[3];
    ev[19]=QC[1]*ew[ 3]+WQ[1]*ew[ 6];
    ev[20]=QC[2]*ew[ 3]+WQ[2]*ew[ 6];
    ev[21]=QC[0]*ew[ 4]+WQ[0]*ew[ 7];
    ev[22]=QC[1]*ew[ 4]+WQ[1]*ew[ 7]+d[3];
    ev[23]=QC[2]*ew[ 4]+WQ[2]*ew[ 7];
    ev[24]=QC[0]*ew[ 5]+WQ[0]*ew[ 8];
    ev[25]=QC[1]*ew[ 5]+WQ[1]*ew[ 8];
    ev[26]=QC[2]*ew[ 5]+WQ[2]*ew[ 8]+d[3];
#pragma unroll
    for (int i=0,j=3; i<6; i++) d[i] = ze2*ew[j++];
    // (ds|ps) m=[0,1]
    ew[ 0]=QC[0]*ev[ 0]+WQ[0]*ev[ 6]+2.e0*d[ 0];
    ew[ 1]=QC[1]*ev[ 0]+WQ[1]*ev[ 6];
    ew[ 2]=QC[2]*ev[ 0]+WQ[2]*ev[ 6];
    ew[ 3]=QC[0]*ev[ 1]+WQ[0]*ev[ 7];
    ew[ 4]=QC[1]*ev[ 1]+WQ[1]*ev[ 7]+2.e0*d[ 1];
    ew[ 5]=QC[2]*ev[ 1]+WQ[2]*ev[ 7];
    ew[ 6]=QC[0]*ev[ 2]+WQ[0]*ev[ 8];
    ew[ 7]=QC[1]*ev[ 2]+WQ[1]*ev[ 8];
    ew[ 8]=QC[2]*ev[ 2]+WQ[2]*ev[ 8]+2.e0*d[ 2];
    ew[ 9]=QC[0]*ev[ 3]+WQ[0]*ev[ 9]+     d[ 1];
    ew[10]=QC[1]*ev[ 3]+WQ[1]*ev[ 9]+     d[ 0];
    ew[11]=QC[2]*ev[ 3]+WQ[2]*ev[ 9];
    ew[12]=QC[0]*ev[ 4]+WQ[0]*ev[10]+     d[ 2];
    ew[13]=QC[1]*ev[ 4]+WQ[1]*ev[10];
    ew[14]=QC[2]*ev[ 4]+WQ[2]*ev[10]+     d[ 0];
    ew[15]=QC[0]*ev[ 5]+WQ[0]*ev[11];
    ew[16]=QC[1]*ev[ 5]+WQ[1]*ev[11]+     d[ 2];
    ew[17]=QC[2]*ev[ 5]+WQ[2]*ev[11]+     d[ 1];
    ew[18]=QC[0]*ev[ 6]+WQ[0]*ev[12]+2.e0*d[ 3];
    ew[19]=QC[1]*ev[ 6]+WQ[1]*ev[12];
    ew[20]=QC[2]*ev[ 6]+WQ[2]*ev[12];
    ew[21]=QC[0]*ev[ 7]+WQ[0]*ev[13];
    ew[22]=QC[1]*ev[ 7]+WQ[1]*ev[13]+2.e0*d[ 4];
    ew[23]=QC[2]*ev[ 7]+WQ[2]*ev[13];
    ew[24]=QC[0]*ev[ 8]+WQ[0]*ev[14];
    ew[25]=QC[1]*ev[ 8]+WQ[1]*ev[14];
    ew[26]=QC[2]*ev[ 8]+WQ[2]*ev[14]+2.e0*d[ 5];
    ew[27]=QC[0]*ev[ 9]+WQ[0]*ev[15]+     d[ 4];
    ew[28]=QC[1]*ev[ 9]+WQ[1]*ev[15]+     d[ 3];
    ew[29]=QC[2]*ev[ 9]+WQ[2]*ev[15];
    ew[30]=QC[0]*ev[10]+WQ[0]*ev[16]+     d[ 5];
    ew[31]=QC[1]*ev[10]+WQ[1]*ev[16];
    ew[32]=QC[2]*ev[10]+WQ[2]*ev[16]+     d[ 3];
    ew[33]=QC[0]*ev[11]+WQ[0]*ev[17];
    ew[34]=QC[1]*ev[11]+WQ[1]*ev[17]+     d[ 5];
    ew[35]=QC[2]*ev[11]+WQ[2]*ev[17]+     d[ 4];
#pragma unroll
    for (int i=0; i<6; i++) d[i] = eta2*(ev[ i]-re*ev[i+6]);
#pragma unroll
    for (int i=0; i<18; i++ ) eh[i]+=ew[i];
    // (DS|DS)
    // (ds|ds) m=[0,0]
    eh[ 18]+=QC[0]*ew[ 0]+WQ[0]*ew[18]+d[0] +2.e0*ze2*ev[18];
    eh[ 19]+=QC[1]*ew[ 1]+WQ[1]*ew[19]+d[0];
    eh[ 20]+=QC[2]*ew[ 2]+WQ[2]*ew[20]+d[0];
    eh[ 21]+=QC[0]*ew[ 1]+WQ[0]*ew[19]+2.e0*ze2*ev[19];
    eh[ 22]+=QC[0]*ew[ 2]+WQ[0]*ew[20]+2.e0*ze2*ev[20];
    eh[ 23]+=QC[1]*ew[ 2]+WQ[1]*ew[20];
    eh[ 24]+=QC[0]*ew[ 3]+WQ[0]*ew[21]+d[1];
    eh[ 25]+=QC[1]*ew[ 4]+WQ[1]*ew[22]+d[1] +2.e0*ze2*ev[22];
    eh[ 26]+=QC[2]*ew[ 5]+WQ[2]*ew[23]+d[1];
    eh[ 27]+=QC[0]*ew[ 4]+WQ[0]*ew[22];
    eh[ 28]+=QC[0]*ew[ 5]+WQ[0]*ew[23];
    eh[ 29]+=QC[1]*ew[ 5]+WQ[1]*ew[23]+2.e0*ze2*ev[23];
    eh[ 30]+=QC[0]*ew[ 6]+WQ[0]*ew[24]+d[2];
    eh[ 31]+=QC[1]*ew[ 7]+WQ[1]*ew[25]+d[2];
    eh[ 32]+=QC[2]*ew[ 8]+WQ[2]*ew[26]+d[2] +2.e0*ze2*ev[26];
    eh[ 33]+=QC[0]*ew[ 7]+WQ[0]*ew[25];
    eh[ 34]+=QC[0]*ew[ 8]+WQ[0]*ew[26];
    eh[ 35]+=QC[1]*ew[ 8]+WQ[1]*ew[26];
    eh[ 36]+=QC[0]*ew[ 9]+WQ[0]*ew[27]+d[3] +     ze2*ev[21];
    eh[ 37]+=QC[1]*ew[10]+WQ[1]*ew[28]+d[3] +     ze2*ev[19];
    eh[ 38]+=QC[2]*ew[11]+WQ[2]*ew[29]+d[3];
    eh[ 39]+=QC[0]*ew[10]+WQ[0]*ew[28]+     ze2*ev[22];
    eh[ 40]+=QC[0]*ew[11]+WQ[0]*ew[29]+     ze2*ev[23];
    eh[ 41]+=QC[1]*ew[11]+WQ[1]*ew[29]+     ze2*ev[20];
    eh[ 42]+=QC[0]*ew[12]+WQ[0]*ew[30]+d[4] +     ze2*ev[24];
    eh[ 43]+=QC[1]*ew[13]+WQ[1]*ew[31]+d[4];
    eh[ 44]+=QC[2]*ew[14]+WQ[2]*ew[32]+d[4] +     ze2*ev[20];
    eh[ 45]+=QC[0]*ew[13]+WQ[0]*ew[31]+     ze2*ev[25];
    eh[ 46]+=QC[0]*ew[14]+WQ[0]*ew[32]+     ze2*ev[26];
    eh[ 47]+=QC[1]*ew[14]+WQ[1]*ew[32];
    eh[ 48]+=QC[0]*ew[15]+WQ[0]*ew[33]+d[5];
    eh[ 49]+=QC[1]*ew[16]+WQ[1]*ew[34]+d[5] +     ze2*ev[25];
    eh[ 50]+=QC[2]*ew[17]+WQ[2]*ew[35]+d[5] +     ze2*ev[23];
    eh[ 51]+=QC[0]*ew[16]+WQ[0]*ew[34];
    eh[ 52]+=QC[0]*ew[17]+WQ[0]*ew[35];
    eh[ 53]+=QC[1]*ew[17]+WQ[1]*ew[35]+     ze2*ev[26];
}

__device__ void gpu_vrr_cint_os_dspp( const double *ev, double *eh ) {
    int La=2, Lb=0, Lc=1, Ld=1;
    int i, ih, iv;
    // (DS|PS)
#pragma unroll
    for ( i=0, iv=44, ih=0; i<18; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (DS|DS)
#pragma unroll
    for ( i=0, iv=80, ih=18; i<36; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dspp(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
//    double ev[116], eh[108];
    double eh[54];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

    gpu_hrr_clear_os_dspp( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            re    = rho * eta;
            ze2 = rz * eta2;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_os_dspp(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    //ev );
                    eh );
            //gpu_vrr_cint_os_dspp( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    //gpu_hrr_calc_os_dspp( BA, DC, eh );
    //gpu_hrr_calc_os_dspp( BA, DC, eh, DINT );
    //gpu_hrr_coef_os_dspp( eh, DINT );
    gpu_hrr_coef_os_dspp( DC, eh, DINT );
}

#if 0
int gpu_twoint_os_dspp(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*3*3];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = gpu_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*1*3*3;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_os_dspp(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*3; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int gpu_twoint_direct_os_dspp(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*3*3];
    int mythread;

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = gpu_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*1*3*3;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_os_dspp(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*3; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
// dsds
// NOT TUNED!
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_dsds( double *eh ) {
    int i;
    // (DS|DS)
#pragma unroll
    for ( i=0; i<(0+36); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_coef_dsds(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 0;
#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
        coef_ab = coef_a;
#pragma unroll
        for ( k=0, kao=4; k<6; k++, kao++ ) {
            coef_abc = coef_ab * LDG(DFACT[kao]);
            DINT[ix] = coef_abc * eh[ix];
            ix++;
        }
    }
}

__device__ void gpu_vrr_calc_dsds(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
    // (ss|ss) m=0,4
    //gpu_fmt( &ev[0], 4, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt4_method3( T, cssss, ev );
#elif CUDA_FMT_M == 2
    gpu_fmt4_method2( T, cssss, ev );
#elif CUDA_FMT_M == 1
    gpu_fmt4_method1( T, cssss, ev );
#else
    gpu_fmt4( ev, T, cssss );
#endif
    // (ps|ss) m=0,3
    ev[ 5]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[ 6]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[ 7]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[ 8]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[ 9]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[10]=PA[2]*ev[1]+WP[2]*ev[2];
    ev[11]=PA[0]*ev[2]+WP[0]*ev[3];
    ev[12]=PA[1]*ev[2]+WP[1]*ev[3];
    ev[13]=PA[2]*ev[2]+WP[2]*ev[3];
    ev[14]=PA[0]*ev[3]+WP[0]*ev[4];
    ev[15]=PA[1]*ev[3]+WP[1]*ev[4];
    ev[16]=PA[2]*ev[3]+WP[2]*ev[4];
    // (ds|ss) m=0,2
    ev[17]=PA[0]*ev[ 5]+WP[0]*ev[ 8]+zeta2*(ev[0]-rz*ev[1]);
    ev[18]=PA[1]*ev[ 6]+WP[1]*ev[ 9]+zeta2*(ev[0]-rz*ev[1]);
    ev[19]=PA[2]*ev[ 7]+WP[2]*ev[10]+zeta2*(ev[0]-rz*ev[1]);
    ev[20]=PA[0]*ev[ 6]+WP[0]*ev[ 9];
    ev[21]=PA[0]*ev[ 7]+WP[0]*ev[10];
    ev[22]=PA[1]*ev[ 7]+WP[1]*ev[10];
    ev[23]=PA[0]*ev[ 8]+WP[0]*ev[11]+zeta2*(ev[1]-rz*ev[2]);
    ev[24]=PA[1]*ev[ 9]+WP[1]*ev[12]+zeta2*(ev[1]-rz*ev[2]);
    ev[25]=PA[2]*ev[10]+WP[2]*ev[13]+zeta2*(ev[1]-rz*ev[2]);
    ev[26]=PA[0]*ev[ 9]+WP[0]*ev[12];
    ev[27]=PA[0]*ev[10]+WP[0]*ev[13];
    ev[28]=PA[1]*ev[10]+WP[1]*ev[13];
    ev[29]=PA[0]*ev[11]+WP[0]*ev[14]+zeta2*(ev[2]-rz*ev[3]);
    ev[30]=PA[1]*ev[12]+WP[1]*ev[15]+zeta2*(ev[2]-rz*ev[3]);
    ev[31]=PA[2]*ev[13]+WP[2]*ev[16]+zeta2*(ev[2]-rz*ev[3]);
    ev[32]=PA[0]*ev[12]+WP[0]*ev[15];
    ev[33]=PA[0]*ev[13]+WP[0]*ev[16];
    ev[34]=PA[1]*ev[13]+WP[1]*ev[16];
    // (ps|ps) m=[1,1]
    ev[35]=QC[0]*ev[ 8]+WQ[0]*ev[11]+ze2*ev[2];
    ev[36]=QC[1]*ev[ 8]+WQ[1]*ev[11];
    ev[37]=QC[2]*ev[ 8]+WQ[2]*ev[11];
    ev[38]=QC[0]*ev[ 9]+WQ[0]*ev[12];
    ev[39]=QC[1]*ev[ 9]+WQ[1]*ev[12]+ze2*ev[2];
    ev[40]=QC[2]*ev[ 9]+WQ[2]*ev[12];
    ev[41]=QC[0]*ev[10]+WQ[0]*ev[13];
    ev[42]=QC[1]*ev[10]+WQ[1]*ev[13];
    ev[43]=QC[2]*ev[10]+WQ[2]*ev[13]+ze2*ev[2];
    // (ds|ps) m=[0,1]
    ev[44]=QC[0]*ev[17]+WQ[0]*ev[23]+2.e0*ze2*ev[ 8];
    ev[45]=QC[1]*ev[17]+WQ[1]*ev[23];
    ev[46]=QC[2]*ev[17]+WQ[2]*ev[23];
    ev[47]=QC[0]*ev[18]+WQ[0]*ev[24];
    ev[48]=QC[1]*ev[18]+WQ[1]*ev[24]+2.e0*ze2*ev[ 9];
    ev[49]=QC[2]*ev[18]+WQ[2]*ev[24];
    ev[50]=QC[0]*ev[19]+WQ[0]*ev[25];
    ev[51]=QC[1]*ev[19]+WQ[1]*ev[25];
    ev[52]=QC[2]*ev[19]+WQ[2]*ev[25]+2.e0*ze2*ev[10];
    ev[53]=QC[0]*ev[20]+WQ[0]*ev[26]+     ze2*ev[ 9];
    ev[54]=QC[1]*ev[20]+WQ[1]*ev[26]+     ze2*ev[ 8];
    ev[55]=QC[2]*ev[20]+WQ[2]*ev[26];
    ev[56]=QC[0]*ev[21]+WQ[0]*ev[27]+     ze2*ev[10];
    ev[57]=QC[1]*ev[21]+WQ[1]*ev[27];
    ev[58]=QC[2]*ev[21]+WQ[2]*ev[27]+     ze2*ev[ 8];
    ev[59]=QC[0]*ev[22]+WQ[0]*ev[28];
    ev[60]=QC[1]*ev[22]+WQ[1]*ev[28]+     ze2*ev[10];
    ev[61]=QC[2]*ev[22]+WQ[2]*ev[28]+     ze2*ev[ 9];
    ev[62]=QC[0]*ev[23]+WQ[0]*ev[29]+2.e0*ze2*ev[11];
    ev[63]=QC[1]*ev[23]+WQ[1]*ev[29];
    ev[64]=QC[2]*ev[23]+WQ[2]*ev[29];
    ev[65]=QC[0]*ev[24]+WQ[0]*ev[30];
    ev[66]=QC[1]*ev[24]+WQ[1]*ev[30]+2.e0*ze2*ev[12];
    ev[67]=QC[2]*ev[24]+WQ[2]*ev[30];
    ev[68]=QC[0]*ev[25]+WQ[0]*ev[31];
    ev[69]=QC[1]*ev[25]+WQ[1]*ev[31];
    ev[70]=QC[2]*ev[25]+WQ[2]*ev[31]+2.e0*ze2*ev[13];
    ev[71]=QC[0]*ev[26]+WQ[0]*ev[32]+     ze2*ev[12];
    ev[72]=QC[1]*ev[26]+WQ[1]*ev[32]+     ze2*ev[11];
    ev[73]=QC[2]*ev[26]+WQ[2]*ev[32];
    ev[74]=QC[0]*ev[27]+WQ[0]*ev[33]+     ze2*ev[13];
    ev[75]=QC[1]*ev[27]+WQ[1]*ev[33];
    ev[76]=QC[2]*ev[27]+WQ[2]*ev[33]+     ze2*ev[11];
    ev[77]=QC[0]*ev[28]+WQ[0]*ev[34];
    ev[78]=QC[1]*ev[28]+WQ[1]*ev[34]+     ze2*ev[13];
    ev[79]=QC[2]*ev[28]+WQ[2]*ev[34]+     ze2*ev[12];
    // (ds|ds) m=[0,0]
    ev[ 80]=QC[0]*ev[44]+WQ[0]*ev[62]+eta2*(ev[17]-re*ev[23])
            +2.e0*ze2*ev[35];
    ev[ 81]=QC[1]*ev[45]+WQ[1]*ev[63]+eta2*(ev[17]-re*ev[23]);
    ev[ 82]=QC[2]*ev[46]+WQ[2]*ev[64]+eta2*(ev[17]-re*ev[23]);
    ev[ 83]=QC[0]*ev[45]+WQ[0]*ev[63]+2.e0*ze2*ev[36];
    ev[ 84]=QC[0]*ev[46]+WQ[0]*ev[64]+2.e0*ze2*ev[37];
    ev[ 85]=QC[1]*ev[46]+WQ[1]*ev[64];
    ev[ 86]=QC[0]*ev[47]+WQ[0]*ev[65]+eta2*(ev[18]-re*ev[24]);
    ev[ 87]=QC[1]*ev[48]+WQ[1]*ev[66]+eta2*(ev[18]-re*ev[24])
            +2.e0*ze2*ev[39];
    ev[ 88]=QC[2]*ev[49]+WQ[2]*ev[67]+eta2*(ev[18]-re*ev[24]);
    ev[ 89]=QC[0]*ev[48]+WQ[0]*ev[66];
    ev[ 90]=QC[0]*ev[49]+WQ[0]*ev[67];
    ev[ 91]=QC[1]*ev[49]+WQ[1]*ev[67]+2.e0*ze2*ev[40];
    ev[ 92]=QC[0]*ev[50]+WQ[0]*ev[68]+eta2*(ev[19]-re*ev[25]);
    ev[ 93]=QC[1]*ev[51]+WQ[1]*ev[69]+eta2*(ev[19]-re*ev[25]);
    ev[ 94]=QC[2]*ev[52]+WQ[2]*ev[70]+eta2*(ev[19]-re*ev[25])
            +2.e0*ze2*ev[43];
    ev[ 95]=QC[0]*ev[51]+WQ[0]*ev[69];
    ev[ 96]=QC[0]*ev[52]+WQ[0]*ev[70];
    ev[ 97]=QC[1]*ev[52]+WQ[1]*ev[70];
    ev[ 98]=QC[0]*ev[53]+WQ[0]*ev[71]+eta2*(ev[20]-re*ev[26])
            +     ze2*ev[38];
    ev[ 99]=QC[1]*ev[54]+WQ[1]*ev[72]+eta2*(ev[20]-re*ev[26])
            +     ze2*ev[36];
    ev[100]=QC[2]*ev[55]+WQ[2]*ev[73]+eta2*(ev[20]-re*ev[26]);
    ev[101]=QC[0]*ev[54]+WQ[0]*ev[72]+     ze2*ev[39];
    ev[102]=QC[0]*ev[55]+WQ[0]*ev[73]+     ze2*ev[40];
    ev[103]=QC[1]*ev[55]+WQ[1]*ev[73]+     ze2*ev[37];
    ev[104]=QC[0]*ev[56]+WQ[0]*ev[74]+eta2*(ev[21]-re*ev[27])
            +     ze2*ev[41];
    ev[105]=QC[1]*ev[57]+WQ[1]*ev[75]+eta2*(ev[21]-re*ev[27]);
    ev[106]=QC[2]*ev[58]+WQ[2]*ev[76]+eta2*(ev[21]-re*ev[27])
            +     ze2*ev[37];
    ev[107]=QC[0]*ev[57]+WQ[0]*ev[75]+     ze2*ev[42];
    ev[108]=QC[0]*ev[58]+WQ[0]*ev[76]+     ze2*ev[43];
    ev[109]=QC[1]*ev[58]+WQ[1]*ev[76];
    ev[110]=QC[0]*ev[59]+WQ[0]*ev[77]+eta2*(ev[22]-re*ev[28]);
    ev[111]=QC[1]*ev[60]+WQ[1]*ev[78]+eta2*(ev[22]-re*ev[28])
            +     ze2*ev[42];
    ev[112]=QC[2]*ev[61]+WQ[2]*ev[79]+eta2*(ev[22]-re*ev[28])
            +     ze2*ev[40];
    ev[113]=QC[0]*ev[60]+WQ[0]*ev[78];
    ev[114]=QC[0]*ev[61]+WQ[0]*ev[79];
    ev[115]=QC[1]*ev[61]+WQ[1]*ev[79]+     ze2*ev[43];
}

__device__ void gpu_vrr_cint_dsds( const double *ev, double *eh ) {
    int La=2, Lb=0, Lc=2, Ld=0;
    int i, ih, iv;
    // (DS|DS)
    for ( i=0, iv=80, ih=0; i<36; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dsds(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[116];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

    //DFACT = ofmo_getadd_dfact();
    gpu_hrr_clear_dsds( DINT );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            re    = rho * eta;
            ze2 = rz * eta2;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_dsds(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_dsds( ev, DINT );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_coef_dsds( DINT, DINT );
}

#if 0
int ofmo_twoint_os_dsds(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*6*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*1*6*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dsds(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
#ifdef SORT_CSP
            int ijgekl = (ics>kcs);
            if (ics==kcs) ijgekl = (jcs>=lcs);
            if (!ijgekl) ipat = ( (ics==kcs && jcs<lcs) ? true : false);
#endif
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=6*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
#ifndef SORT_CSP
                                if ( IJ >= KL ) {
#else
                                if ((ijgekl&&IJ>=KL) || (!ijgekl&&KL>=IJ)) {
#endif
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_dsds(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*1*6*1];
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*1*6*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*ofmo_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dsds(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
#ifdef SORT_CSP
            int ijgekl = (ics>kcs);
            if (ics==kcs) ijgekl = (jcs>=lcs);
            if (!ijgekl) ipat = ( (ics==kcs && jcs<lcs) ? true : false);
#endif
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=6*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
#ifndef SORT_CSP
                                if ( IJ >= KL ) {
#else
                                if ((ijgekl&&IJ>=KL) || (!ijgekl&&KL>=IJ)) {
#endif
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // if 0
// dpss
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_dpss( double *eh ) {
    int i;
    // (DS|SS)
#pragma unroll
    for ( i=0; i<(0+6); i++ ) eh[i] = 0.e0;
    // (FS|SS)
#pragma unroll
    for ( i=6; i<(6+10); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_calc_dpss(
        const double BA[3], const double DC[3], double *eh ) {
    // (DP,SS)
    eh[  16] = eh[   6] - BA[0]*eh[   0];
    eh[  17] = eh[   9] - BA[1]*eh[   0];
    eh[  18] = eh[  10] - BA[2]*eh[   0];
    eh[  19] = eh[  11] - BA[0]*eh[   1];
    eh[  20] = eh[   7] - BA[1]*eh[   1];
    eh[  21] = eh[  14] - BA[2]*eh[   1];
    eh[  22] = eh[  12] - BA[0]*eh[   2];
    eh[  23] = eh[  15] - BA[1]*eh[   2];
    eh[  24] = eh[   8] - BA[2]*eh[   2];
    eh[  25] = eh[   9] - BA[0]*eh[   3];
    eh[  26] = eh[  11] - BA[1]*eh[   3];
    eh[  27] = eh[  13] - BA[2]*eh[   3];
    eh[  28] = eh[  10] - BA[0]*eh[   4];
    eh[  29] = eh[  13] - BA[1]*eh[   4];
    eh[  30] = eh[  12] - BA[2]*eh[   4];
    eh[  31] = eh[  13] - BA[0]*eh[   5];
    eh[  32] = eh[  14] - BA[1]*eh[   5];
    eh[  33] = eh[  15] - BA[2]*eh[   5];
    // HRR for (XX|XX)-type integral (center CD)
}

__device__ void gpu_hrr_coef_dpss(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 16;
    iy = 0;

#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
#pragma unroll
        for ( j=0, jao=1; j<3; j++, jao++ ) {
            coef_ab = coef_a * LDG(DFACT[jao]);
            coef_abc = coef_ab;
            DINT[iy] = coef_abc * eh[ix];
            iy++;
            ix++;
        }
    }
}

__device__ void gpu_vrr_calc_dpss(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
    // (ss|ss) m=0,3
    //fmt( &ev[0], 3, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt3_method3( T, cssss, ev );
#elif CUDA_FMT_M == 2
    gpu_fmt3_method2( T, cssss, ev );
#elif CUDA_FMT_M == 1
    gpu_fmt3_method1( T, cssss, ev );
#else
    gpu_fmt3( ev, T, cssss );
#endif
    // (ps|ss) m=0,2
    ev[ 4]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[ 5]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[ 6]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[ 7]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[ 8]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[ 9]=PA[2]*ev[1]+WP[2]*ev[2];
    ev[10]=PA[0]*ev[2]+WP[0]*ev[3];
    ev[11]=PA[1]*ev[2]+WP[1]*ev[3];
    ev[12]=PA[2]*ev[2]+WP[2]*ev[3];
    // (ds|ss) m=0,1
    ev[13]=PA[0]*ev[4]+WP[0]*ev[ 7]+zeta2*(ev[0]-rz*ev[1]);
    ev[14]=PA[1]*ev[5]+WP[1]*ev[ 8]+zeta2*(ev[0]-rz*ev[1]);
    ev[15]=PA[2]*ev[6]+WP[2]*ev[ 9]+zeta2*(ev[0]-rz*ev[1]);
    ev[16]=PA[0]*ev[5]+WP[0]*ev[ 8];
    ev[17]=PA[0]*ev[6]+WP[0]*ev[ 9];
    ev[18]=PA[1]*ev[6]+WP[1]*ev[ 9];
    ev[19]=PA[0]*ev[7]+WP[0]*ev[10]+zeta2*(ev[1]-rz*ev[2]);
    ev[20]=PA[1]*ev[8]+WP[1]*ev[11]+zeta2*(ev[1]-rz*ev[2]);
    ev[21]=PA[2]*ev[9]+WP[2]*ev[12]+zeta2*(ev[1]-rz*ev[2]);
    ev[22]=PA[0]*ev[8]+WP[0]*ev[11];
    ev[23]=PA[0]*ev[9]+WP[0]*ev[12];
    ev[24]=PA[1]*ev[9]+WP[1]*ev[12];
    // (fs|ss) m=0,0
    ev[25]=PA[0]*ev[13]+WP[0]*ev[19]+2.e0*zeta2*(ev[4]-rz*ev[7]);
    ev[26]=PA[1]*ev[14]+WP[1]*ev[20]+2.e0*zeta2*(ev[5]-rz*ev[8]);
    ev[27]=PA[2]*ev[15]+WP[2]*ev[21]+2.e0*zeta2*(ev[6]-rz*ev[9]);
    ev[28]=PA[1]*ev[13]+WP[1]*ev[19];
    ev[29]=PA[2]*ev[13]+WP[2]*ev[19];
    ev[30]=PA[0]*ev[14]+WP[0]*ev[20];
    ev[31]=PA[0]*ev[15]+WP[0]*ev[21];
    ev[32]=PA[0]*ev[18]+WP[0]*ev[24];
    ev[33]=PA[2]*ev[14]+WP[2]*ev[20];
    ev[34]=PA[1]*ev[15]+WP[1]*ev[21];
}

__device__ void gpu_vrr_cint_dpss( const double *ev, double *eh ) {
    int La=2, Lb=1, Lc=0, Ld=0;
    int i, ih, iv;
    // (DS|SS)
#pragma unroll
    for ( i=0, iv=13, ih=0; i<6; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|SS)
#pragma unroll
    for ( i=0, iv=25, ih=6; i<10; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dpss(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[35], eh[34];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

//    DFACT = ofmo_getadd_dfact();
    gpu_hrr_clear_dpss( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            ze2 = rz * eta * HALF;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_dpss(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_dpss( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_calc_dpss( BA, DC, eh );
    gpu_hrr_coef_dpss( eh, DINT );
}

#if 0
int ofmo_twoint_os_dpss(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*1*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*3*1*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dpss(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=1*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<1; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_dpss(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*1*1];
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*3*1*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*ofmo_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dpss(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=1*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<1; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
// dpps
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_dpps( double *eh, double *ef ) {
    int i;
    // (DS|PS)
#pragma unroll
    for ( i=0; i<(0+18); i++ ) eh[i] = 0.e0;
    // (FS|PS)
#pragma unroll
    //for ( i=18; i<(18+30); i++ ) eh[i] = 0.e0;
    for ( i=0; i<(30); i++ ) ef[i] = 0.e0;
}

__device__ void gpu_hrr_calc_dpps(
        //const double BA[3], const double DC[3], double *eh ) {
        const double BA[3], const double DC[3],
        const double eh[18], const double ef[30], double *ew ) {
    // (DP,PS)
    ew[  0] = ef[   0] - BA[0]*eh[   0];
    ew[  1] = ef[   1] - BA[0]*eh[   1];
    ew[  2] = ef[   2] - BA[0]*eh[   2];
    ew[  3] = ef[   9] - BA[1]*eh[   0];
    ew[  4] = ef[  10] - BA[1]*eh[   1];
    ew[  5] = ef[  11] - BA[1]*eh[   2];
    ew[  6] = ef[  12] - BA[2]*eh[   0];
    ew[  7] = ef[  13] - BA[2]*eh[   1];
    ew[  8] = ef[  14] - BA[2]*eh[   2];
    ew[  9] = ef[  15] - BA[0]*eh[   3];
    ew[ 10] = ef[  16] - BA[0]*eh[   4];
    ew[ 11] = ef[  17] - BA[0]*eh[   5];
    ew[ 12] = ef[   3] - BA[1]*eh[   3];
    ew[ 13] = ef[   4] - BA[1]*eh[   4];
    ew[ 14] = ef[   5] - BA[1]*eh[   5];
    ew[ 15] = ef[  24] - BA[2]*eh[   3];
    ew[ 16] = ef[  25] - BA[2]*eh[   4];
    ew[ 17] = ef[  26] - BA[2]*eh[   5];
    ew[ 18] = ef[  18] - BA[0]*eh[   6];
    ew[ 19] = ef[  19] - BA[0]*eh[   7];
    ew[ 20] = ef[  20] - BA[0]*eh[   8];
    ew[ 21] = ef[  27] - BA[1]*eh[   6];
    ew[ 22] = ef[  28] - BA[1]*eh[   7];
    ew[ 23] = ef[  29] - BA[1]*eh[   8];
    ew[ 24] = ef[   6] - BA[2]*eh[   6];
    ew[ 25] = ef[   7] - BA[2]*eh[   7];
    ew[ 26] = ef[   8] - BA[2]*eh[   8];
    ew[ 27] = ef[   9] - BA[0]*eh[   9];
    ew[ 28] = ef[  10] - BA[0]*eh[  10];
    ew[ 29] = ef[  11] - BA[0]*eh[  11];
    ew[ 30] = ef[  15] - BA[1]*eh[   9];
    ew[ 31] = ef[  16] - BA[1]*eh[  10];
    ew[ 32] = ef[  17] - BA[1]*eh[  11];
    ew[ 33] = ef[  21] - BA[2]*eh[   9];
    ew[ 34] = ef[  22] - BA[2]*eh[  10];
    ew[ 35] = ef[  23] - BA[2]*eh[  11];
    ew[ 36] = ef[  12] - BA[0]*eh[  12];
    ew[ 37] = ef[  13] - BA[0]*eh[  13];
    ew[ 38] = ef[  14] - BA[0]*eh[  14];
    ew[ 39] = ef[  21] - BA[1]*eh[  12];
    ew[ 40] = ef[  22] - BA[1]*eh[  13];
    ew[ 41] = ef[  23] - BA[1]*eh[  14];
    ew[ 42] = ef[  18] - BA[2]*eh[  12];
    ew[ 43] = ef[  19] - BA[2]*eh[  13];
    ew[ 44] = ef[  20] - BA[2]*eh[  14];
    ew[ 45] = ef[  21] - BA[0]*eh[  15];
    ew[ 46] = ef[  22] - BA[0]*eh[  16];
    ew[ 47] = ef[  23] - BA[0]*eh[  17];
    ew[ 48] = ef[  24] - BA[1]*eh[  15];
    ew[ 49] = ef[  25] - BA[1]*eh[  16];
    ew[ 50] = ef[  26] - BA[1]*eh[  17];
    ew[ 51] = ef[  27] - BA[2]*eh[  15];
    ew[ 52] = ef[  28] - BA[2]*eh[  16];
    ew[ 53] = ef[  29] - BA[2]*eh[  17];
    // HRR for (XX|XX)-type integral (center CD)
}

__device__ void gpu_hrr_coef_dpps(
        //const double *eh, double *DINT ) {
        double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 48;
    iy = 0;

#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
#pragma unroll
        for ( j=0, jao=1; j<3; j++, jao++ ) {
            coef_ab = coef_a * LDG(DFACT[jao]);
#pragma unroll
            for ( k=0, kao=1; k<3; k++, kao++ ) {
                coef_abc = coef_ab * LDG(DFACT[kao]);
                //DINT[iy] = coef_abc * eh[ix];
                DINT[iy] *= coef_abc;
                iy++;
                ix++;
            }
        }
    }
}

__device__ void gpu_vrr_calc_dpps(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *eh, double *ef ) {
    double d[6], ew[20], ev[16];
    // (ss|ss) m=0,4
    //gpu_fmt( &ev[0], 4, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt4_method3( T, cssss, &d[0] );
#elif CUDA_FMT_M == 2
    gpu_fmt4_method2( T, cssss, &d[0] );
#elif CUDA_FMT_M == 1
    gpu_fmt4_method1( T, cssss, &d[0] );
#else
    gpu_fmt4( &d[0], T, cssss );
#endif
    // (ps|ss) m=0,3
#pragma unroll
    for (int i=0; i<3; i++) {
#pragma unroll
      for (int j=0; j<4; j++) {
        ew[i*4+j] = PA[i]*d[j]+WP[i]*d[j+1];
      }
    }
    d[0]=zeta2*(d[0]-rz*d[1]);
    d[1]=zeta2*(d[1]-rz*d[2]);
    d[2]=zeta2*(d[2]-rz*d[3]);
    // (ds|ss) m=0,2
    ev[ 0]=PA[0]*ew[ 0]+WP[0]*ew[ 1]+d[0];
    ev[ 1]=PA[0]*ew[ 1]+WP[0]*ew[ 2]+d[1];
    ev[ 2]=PA[0]*ew[ 2]+WP[0]*ew[ 3]+d[2];
    ev[ 3]=PA[1]*ew[ 4]+WP[1]*ew[ 5]+d[0];
    ev[ 4]=PA[1]*ew[ 5]+WP[1]*ew[ 6]+d[1];
    ev[ 5]=PA[1]*ew[ 6]+WP[1]*ew[ 7]+d[2];
    ev[ 6]=PA[2]*ew[ 8]+WP[2]*ew[ 9]+d[0];
    ev[ 7]=PA[2]*ew[ 9]+WP[2]*ew[10]+d[1];
    ev[ 8]=PA[2]*ew[10]+WP[2]*ew[11]+d[2];
    ev[ 9]=PA[1]*ew[ 8]+WP[1]*ew[ 9];
    ev[10]=PA[1]*ew[ 9]+WP[1]*ew[10];
    ev[11]=PA[1]*ew[10]+WP[1]*ew[11];
    ev[12]=PA[0]*ew[ 4]+WP[0]*ew[ 5];
    ev[13]=PA[0]*ew[ 5]+WP[0]*ew[ 6];
    ev[14]=PA[0]*ew[ 8]+WP[0]*ew[ 9];
    ev[15]=PA[0]*ew[ 9]+WP[0]*ew[10];
    //ev[32]=PA[0]*ew[ 7]+WP[0]*ew[10];
    //ev[33]=PA[0]*ew[ 8]+WP[0]*ew[11];
    d[0] = ze2*ew[1];
    d[1] = ze2*ew[5];
    d[2] = ze2*ew[9];
    // (ds|ps) m=[0,0]
    eh[ 0]+=QC[0]*ev[ 0]+WQ[0]*ev[ 1]+2.e0*d[0];
    eh[ 1]+=QC[1]*ev[ 0]+WQ[1]*ev[ 1];
    eh[ 2]+=QC[2]*ev[ 0]+WQ[2]*ev[ 1];
    eh[ 3]+=QC[0]*ev[ 3]+WQ[0]*ev[ 4];
    eh[ 4]+=QC[1]*ev[ 3]+WQ[1]*ev[ 4]+2.e0*d[1];
    eh[ 5]+=QC[2]*ev[ 3]+WQ[2]*ev[ 4];
    eh[ 6]+=QC[0]*ev[ 6]+WQ[0]*ev[ 7];
    eh[ 7]+=QC[1]*ev[ 6]+WQ[1]*ev[ 7];
    eh[ 8]+=QC[2]*ev[ 6]+WQ[2]*ev[ 7]+2.e0*d[2];
    eh[ 9]+=QC[0]*ev[12]+WQ[0]*ev[13]+     d[1];
    eh[10]+=QC[1]*ev[12]+WQ[1]*ev[13]+     d[0];
    eh[11]+=QC[2]*ev[12]+WQ[2]*ev[13];
    eh[12]+=QC[0]*ev[14]+WQ[0]*ev[15]+     d[2];
    eh[13]+=QC[1]*ev[14]+WQ[1]*ev[15];
    eh[14]+=QC[2]*ev[14]+WQ[2]*ev[15]+     d[0];
    eh[15]+=QC[0]*ev[ 9]+WQ[0]*ev[10];
    eh[16]+=QC[1]*ev[ 9]+WQ[1]*ev[10]+     d[2];
    eh[17]+=QC[2]*ev[ 9]+WQ[2]*ev[10]+     d[1];
    // (fs|ss) m=0,1
    d[0] = 2.e0*zeta2*(ew[ 0]-rz*ew[ 1]);
    d[1] = 2.e0*zeta2*(ew[ 1]-rz*ew[ 2]);
    d[2] = 2.e0*zeta2*(ew[ 4]-rz*ew[ 5]);
    d[3] = 2.e0*zeta2*(ew[ 5]-rz*ew[ 6]);
    d[4] = 2.e0*zeta2*(ew[ 8]-rz*ew[ 9]);
    d[5] = 2.e0*zeta2*(ew[ 9]-rz*ew[10]);
    ew[ 0]=PA[0]*ev[ 0]+WP[0]*ev[ 1]+d[0];
    ew[ 1]=PA[0]*ev[ 1]+WP[0]*ev[ 2]+d[1];
    ew[ 2]=PA[1]*ev[ 3]+WP[1]*ev[ 4]+d[2];
    ew[ 3]=PA[1]*ev[ 4]+WP[1]*ev[ 5]+d[3];
    ew[ 4]=PA[2]*ev[ 6]+WP[2]*ev[ 7]+d[4];
    ew[ 5]=PA[2]*ev[ 7]+WP[2]*ev[ 8]+d[5];
    ew[ 6]=PA[1]*ev[ 0]+WP[1]*ev[ 1];
    ew[ 7]=PA[1]*ev[ 1]+WP[1]*ev[ 2];
    ew[ 8]=PA[2]*ev[ 0]+WP[2]*ev[ 1];
    ew[ 9]=PA[2]*ev[ 1]+WP[2]*ev[ 2];
    ew[10]=PA[0]*ev[ 3]+WP[0]*ev[ 4];
    ew[11]=PA[0]*ev[ 4]+WP[0]*ev[ 5];
    ew[12]=PA[0]*ev[ 6]+WP[0]*ev[ 7];
    ew[13]=PA[0]*ev[ 7]+WP[0]*ev[ 8];
    ew[14]=PA[0]*ev[ 9]+WP[0]*ev[10];
    ew[15]=PA[0]*ev[10]+WP[0]*ev[11];
    ew[16]=PA[2]*ev[ 3]+WP[2]*ev[ 4];
    ew[17]=PA[2]*ev[ 4]+WP[2]*ev[ 5];
    ew[18]=PA[1]*ev[ 6]+WP[1]*ev[ 7];
    ew[19]=PA[1]*ev[ 7]+WP[1]*ev[ 8];
    // (fs|ps) m+=[0,0]
    ef[ 0]+=QC[0]*ew[ 0]+WQ[0]*ew[ 1]+3.e0*ze2*ev[ 1];
    ef[ 1]+=QC[1]*ew[ 0]+WQ[1]*ew[ 1];
    ef[ 2]+=QC[2]*ew[ 0]+WQ[2]*ew[ 1];
    ef[ 3]+=QC[0]*ew[ 2]+WQ[0]*ew[ 3];
    ef[ 4]+=QC[1]*ew[ 2]+WQ[1]*ew[ 3]+3.e0*ze2*ev[ 4];
    ef[ 5]+=QC[2]*ew[ 2]+WQ[2]*ew[ 3];
    ef[ 6]+=QC[0]*ew[ 4]+WQ[0]*ew[ 5];
    ef[ 7]+=QC[1]*ew[ 4]+WQ[1]*ew[ 5];
    ef[ 8]+=QC[2]*ew[ 4]+WQ[2]*ew[ 5]+3.e0*ze2*ev[ 7];
    ef[ 9]+=QC[0]*ew[ 6]+WQ[0]*ew[ 7]+2.e0*ze2*ev[13];
    ef[10]+=QC[1]*ew[ 6]+WQ[1]*ew[ 7]+     ze2*ev[ 1];
    ef[11]+=QC[2]*ew[ 6]+WQ[2]*ew[ 7];
    ef[12]+=QC[0]*ew[ 8]+WQ[0]*ew[ 9]+2.e0*ze2*ev[15];
    ef[13]+=QC[1]*ew[ 8]+WQ[1]*ew[ 9];
    ef[14]+=QC[2]*ew[ 8]+WQ[2]*ew[ 9]+     ze2*ev[ 1];
    ef[15]+=QC[0]*ew[10]+WQ[0]*ew[11]+     ze2*ev[ 4];
    ef[16]+=QC[1]*ew[10]+WQ[1]*ew[11]+2.e0*ze2*ev[13];
    ef[17]+=QC[2]*ew[10]+WQ[2]*ew[11];
    ef[18]+=QC[0]*ew[12]+WQ[0]*ew[13]+     ze2*ev[ 7];
    ef[19]+=QC[1]*ew[12]+WQ[1]*ew[13];
    ef[20]+=QC[2]*ew[12]+WQ[2]*ew[13]+2.e0*ze2*ev[15];
    ef[21]+=QC[0]*ew[14]+WQ[0]*ew[15]+     ze2*ev[10];
    ef[22]+=QC[1]*ew[14]+WQ[1]*ew[15]+     ze2*ev[15];
    ef[23]+=QC[2]*ew[14]+WQ[2]*ew[15]+     ze2*ev[13];
    ef[24]+=QC[0]*ew[16]+WQ[0]*ew[17];
    ef[25]+=QC[1]*ew[16]+WQ[1]*ew[17]+2.e0*ze2*ev[10];
    ef[26]+=QC[2]*ew[16]+WQ[2]*ew[17]+     ze2*ev[ 4];
    ef[27]+=QC[0]*ew[18]+WQ[0]*ew[19];
    ef[28]+=QC[1]*ew[18]+WQ[1]*ew[19]+     ze2*ev[ 7];
    ef[29]+=QC[2]*ew[18]+WQ[2]*ew[19]+2.e0*ze2*ev[10];
}

__device__ void gpu_vrr_cint_dpps( const double *ev, double *eh ) {
    int La=2, Lb=1, Lc=1, Ld=0;
    int i, ih, iv;
    // (DS|PS)
#pragma unroll
    for ( i=0, iv=55, ih=0; i<18; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|PS)
#pragma unroll
    for ( i=0, iv=73, ih=18; i<30; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dpps(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
//    double ev[103], eh[102];
    //double eh[48];
    double eh[18], ef[30];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

    gpu_hrr_clear_dpps( eh, ef );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            ze2 = rz * eta * HALF;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_dpps(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    eh, ef );
//                    ev );
//            gpu_vrr_cint_dpps( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    //gpu_hrr_calc_dpps( BA, DC, eh );
    //gpu_hrr_coef_dpps( eh, DINT );
    gpu_hrr_calc_dpps( BA, DC, eh, ef, DINT );
    gpu_hrr_coef_dpps( DINT );
}

#if 0
int gpu_twoint_os_dpps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*3*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;

    
    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = gpu_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*3*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_os_dpps(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int gpu_twoint_direct_os_dpps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*3*1];
    int mythread;
    float eps_eri = gpu_twoint_eps_eri(0);
    float eps_ps4 = gpu_twoint_eps_ps4(0);
    float eps_sch = gpu_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = gpu_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) { 
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }
    
    max_nzeri -= 6*3*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }
    
    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*gpu_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_os_dpps(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
// dppp
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_dppp( double *eh ) {
    int i;
    // (DS|PS)
#pragma unroll
    for ( i=0; i<(0+18); i++ ) eh[i] = 0.e0;
    // (DS|DS)
#pragma unroll
    for ( i=18; i<(18+36); i++ ) eh[i] = 0.e0;
    // (FS|PS)
#pragma unroll
    for ( i=54; i<(54+30); i++ ) eh[i] = 0.e0;
    // (FS|DS)
#pragma unroll
    for ( i=84; i<(84+60); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_calc_dppp(
        const double BA[3], const double DC[3], double *eh ) {
    // (DP,PS)
    eh[ 144] = eh[  54] - BA[0]*eh[   0];
    eh[ 145] = eh[  55] - BA[0]*eh[   1];
    eh[ 146] = eh[  56] - BA[0]*eh[   2];
    eh[ 147] = eh[  63] - BA[1]*eh[   0];
    eh[ 148] = eh[  64] - BA[1]*eh[   1];
    eh[ 149] = eh[  65] - BA[1]*eh[   2];
    eh[ 150] = eh[  66] - BA[2]*eh[   0];
    eh[ 151] = eh[  67] - BA[2]*eh[   1];
    eh[ 152] = eh[  68] - BA[2]*eh[   2];
    eh[ 153] = eh[  69] - BA[0]*eh[   3];
    eh[ 154] = eh[  70] - BA[0]*eh[   4];
    eh[ 155] = eh[  71] - BA[0]*eh[   5];
    eh[ 156] = eh[  57] - BA[1]*eh[   3];
    eh[ 157] = eh[  58] - BA[1]*eh[   4];
    eh[ 158] = eh[  59] - BA[1]*eh[   5];
    eh[ 159] = eh[  78] - BA[2]*eh[   3];
    eh[ 160] = eh[  79] - BA[2]*eh[   4];
    eh[ 161] = eh[  80] - BA[2]*eh[   5];
    eh[ 162] = eh[  72] - BA[0]*eh[   6];
    eh[ 163] = eh[  73] - BA[0]*eh[   7];
    eh[ 164] = eh[  74] - BA[0]*eh[   8];
    eh[ 165] = eh[  81] - BA[1]*eh[   6];
    eh[ 166] = eh[  82] - BA[1]*eh[   7];
    eh[ 167] = eh[  83] - BA[1]*eh[   8];
    eh[ 168] = eh[  60] - BA[2]*eh[   6];
    eh[ 169] = eh[  61] - BA[2]*eh[   7];
    eh[ 170] = eh[  62] - BA[2]*eh[   8];
    eh[ 171] = eh[  63] - BA[0]*eh[   9];
    eh[ 172] = eh[  64] - BA[0]*eh[  10];
    eh[ 173] = eh[  65] - BA[0]*eh[  11];
    eh[ 174] = eh[  69] - BA[1]*eh[   9];
    eh[ 175] = eh[  70] - BA[1]*eh[  10];
    eh[ 176] = eh[  71] - BA[1]*eh[  11];
    eh[ 177] = eh[  75] - BA[2]*eh[   9];
    eh[ 178] = eh[  76] - BA[2]*eh[  10];
    eh[ 179] = eh[  77] - BA[2]*eh[  11];
    eh[ 180] = eh[  66] - BA[0]*eh[  12];
    eh[ 181] = eh[  67] - BA[0]*eh[  13];
    eh[ 182] = eh[  68] - BA[0]*eh[  14];
    eh[ 183] = eh[  75] - BA[1]*eh[  12];
    eh[ 184] = eh[  76] - BA[1]*eh[  13];
    eh[ 185] = eh[  77] - BA[1]*eh[  14];
    eh[ 186] = eh[  72] - BA[2]*eh[  12];
    eh[ 187] = eh[  73] - BA[2]*eh[  13];
    eh[ 188] = eh[  74] - BA[2]*eh[  14];
    eh[ 189] = eh[  75] - BA[0]*eh[  15];
    eh[ 190] = eh[  76] - BA[0]*eh[  16];
    eh[ 191] = eh[  77] - BA[0]*eh[  17];
    eh[ 192] = eh[  78] - BA[1]*eh[  15];
    eh[ 193] = eh[  79] - BA[1]*eh[  16];
    eh[ 194] = eh[  80] - BA[1]*eh[  17];
    eh[ 195] = eh[  81] - BA[2]*eh[  15];
    eh[ 196] = eh[  82] - BA[2]*eh[  16];
    eh[ 197] = eh[  83] - BA[2]*eh[  17];
    // (DP,DS)
    eh[ 198] = eh[  84] - BA[0]*eh[  18];
    eh[ 199] = eh[  85] - BA[0]*eh[  19];
    eh[ 200] = eh[  86] - BA[0]*eh[  20];
    eh[ 201] = eh[  87] - BA[0]*eh[  21];
    eh[ 202] = eh[  88] - BA[0]*eh[  22];
    eh[ 203] = eh[  89] - BA[0]*eh[  23];
    eh[ 204] = eh[ 102] - BA[1]*eh[  18];
    eh[ 205] = eh[ 103] - BA[1]*eh[  19];
    eh[ 206] = eh[ 104] - BA[1]*eh[  20];
    eh[ 207] = eh[ 105] - BA[1]*eh[  21];
    eh[ 208] = eh[ 106] - BA[1]*eh[  22];
    eh[ 209] = eh[ 107] - BA[1]*eh[  23];
    eh[ 210] = eh[ 108] - BA[2]*eh[  18];
    eh[ 211] = eh[ 109] - BA[2]*eh[  19];
    eh[ 212] = eh[ 110] - BA[2]*eh[  20];
    eh[ 213] = eh[ 111] - BA[2]*eh[  21];
    eh[ 214] = eh[ 112] - BA[2]*eh[  22];
    eh[ 215] = eh[ 113] - BA[2]*eh[  23];
    eh[ 216] = eh[ 114] - BA[0]*eh[  24];
    eh[ 217] = eh[ 115] - BA[0]*eh[  25];
    eh[ 218] = eh[ 116] - BA[0]*eh[  26];
    eh[ 219] = eh[ 117] - BA[0]*eh[  27];
    eh[ 220] = eh[ 118] - BA[0]*eh[  28];
    eh[ 221] = eh[ 119] - BA[0]*eh[  29];
    eh[ 222] = eh[  90] - BA[1]*eh[  24];
    eh[ 223] = eh[  91] - BA[1]*eh[  25];
    eh[ 224] = eh[  92] - BA[1]*eh[  26];
    eh[ 225] = eh[  93] - BA[1]*eh[  27];
    eh[ 226] = eh[  94] - BA[1]*eh[  28];
    eh[ 227] = eh[  95] - BA[1]*eh[  29];
    eh[ 228] = eh[ 132] - BA[2]*eh[  24];
    eh[ 229] = eh[ 133] - BA[2]*eh[  25];
    eh[ 230] = eh[ 134] - BA[2]*eh[  26];
    eh[ 231] = eh[ 135] - BA[2]*eh[  27];
    eh[ 232] = eh[ 136] - BA[2]*eh[  28];
    eh[ 233] = eh[ 137] - BA[2]*eh[  29];
    eh[ 234] = eh[ 120] - BA[0]*eh[  30];
    eh[ 235] = eh[ 121] - BA[0]*eh[  31];
    eh[ 236] = eh[ 122] - BA[0]*eh[  32];
    eh[ 237] = eh[ 123] - BA[0]*eh[  33];
    eh[ 238] = eh[ 124] - BA[0]*eh[  34];
    eh[ 239] = eh[ 125] - BA[0]*eh[  35];
    eh[ 240] = eh[ 138] - BA[1]*eh[  30];
    eh[ 241] = eh[ 139] - BA[1]*eh[  31];
    eh[ 242] = eh[ 140] - BA[1]*eh[  32];
    eh[ 243] = eh[ 141] - BA[1]*eh[  33];
    eh[ 244] = eh[ 142] - BA[1]*eh[  34];
    eh[ 245] = eh[ 143] - BA[1]*eh[  35];
    eh[ 246] = eh[  96] - BA[2]*eh[  30];
    eh[ 247] = eh[  97] - BA[2]*eh[  31];
    eh[ 248] = eh[  98] - BA[2]*eh[  32];
    eh[ 249] = eh[  99] - BA[2]*eh[  33];
    eh[ 250] = eh[ 100] - BA[2]*eh[  34];
    eh[ 251] = eh[ 101] - BA[2]*eh[  35];
    eh[ 252] = eh[ 102] - BA[0]*eh[  36];
    eh[ 253] = eh[ 103] - BA[0]*eh[  37];
    eh[ 254] = eh[ 104] - BA[0]*eh[  38];
    eh[ 255] = eh[ 105] - BA[0]*eh[  39];
    eh[ 256] = eh[ 106] - BA[0]*eh[  40];
    eh[ 257] = eh[ 107] - BA[0]*eh[  41];
    eh[ 258] = eh[ 114] - BA[1]*eh[  36];
    eh[ 259] = eh[ 115] - BA[1]*eh[  37];
    eh[ 260] = eh[ 116] - BA[1]*eh[  38];
    eh[ 261] = eh[ 117] - BA[1]*eh[  39];
    eh[ 262] = eh[ 118] - BA[1]*eh[  40];
    eh[ 263] = eh[ 119] - BA[1]*eh[  41];
    eh[ 264] = eh[ 126] - BA[2]*eh[  36];
    eh[ 265] = eh[ 127] - BA[2]*eh[  37];
    eh[ 266] = eh[ 128] - BA[2]*eh[  38];
    eh[ 267] = eh[ 129] - BA[2]*eh[  39];
    eh[ 268] = eh[ 130] - BA[2]*eh[  40];
    eh[ 269] = eh[ 131] - BA[2]*eh[  41];
    eh[ 270] = eh[ 108] - BA[0]*eh[  42];
    eh[ 271] = eh[ 109] - BA[0]*eh[  43];
    eh[ 272] = eh[ 110] - BA[0]*eh[  44];
    eh[ 273] = eh[ 111] - BA[0]*eh[  45];
    eh[ 274] = eh[ 112] - BA[0]*eh[  46];
    eh[ 275] = eh[ 113] - BA[0]*eh[  47];
    eh[ 276] = eh[ 126] - BA[1]*eh[  42];
    eh[ 277] = eh[ 127] - BA[1]*eh[  43];
    eh[ 278] = eh[ 128] - BA[1]*eh[  44];
    eh[ 279] = eh[ 129] - BA[1]*eh[  45];
    eh[ 280] = eh[ 130] - BA[1]*eh[  46];
    eh[ 281] = eh[ 131] - BA[1]*eh[  47];
    eh[ 282] = eh[ 120] - BA[2]*eh[  42];
    eh[ 283] = eh[ 121] - BA[2]*eh[  43];
    eh[ 284] = eh[ 122] - BA[2]*eh[  44];
    eh[ 285] = eh[ 123] - BA[2]*eh[  45];
    eh[ 286] = eh[ 124] - BA[2]*eh[  46];
    eh[ 287] = eh[ 125] - BA[2]*eh[  47];
    eh[ 288] = eh[ 126] - BA[0]*eh[  48];
    eh[ 289] = eh[ 127] - BA[0]*eh[  49];
    eh[ 290] = eh[ 128] - BA[0]*eh[  50];
    eh[ 291] = eh[ 129] - BA[0]*eh[  51];
    eh[ 292] = eh[ 130] - BA[0]*eh[  52];
    eh[ 293] = eh[ 131] - BA[0]*eh[  53];
    eh[ 294] = eh[ 132] - BA[1]*eh[  48];
    eh[ 295] = eh[ 133] - BA[1]*eh[  49];
    eh[ 296] = eh[ 134] - BA[1]*eh[  50];
    eh[ 297] = eh[ 135] - BA[1]*eh[  51];
    eh[ 298] = eh[ 136] - BA[1]*eh[  52];
    eh[ 299] = eh[ 137] - BA[1]*eh[  53];
    eh[ 300] = eh[ 138] - BA[2]*eh[  48];
    eh[ 301] = eh[ 139] - BA[2]*eh[  49];
    eh[ 302] = eh[ 140] - BA[2]*eh[  50];
    eh[ 303] = eh[ 141] - BA[2]*eh[  51];
    eh[ 304] = eh[ 142] - BA[2]*eh[  52];
    eh[ 305] = eh[ 143] - BA[2]*eh[  53];
    // HRR for (XX|XX)-type integral (center CD)
    // (DP,PP)
    eh[ 306] = eh[ 198] - DC[0]*eh[ 144];
    eh[ 307] = eh[ 201] - DC[1]*eh[ 144];
    eh[ 308] = eh[ 202] - DC[2]*eh[ 144];
    eh[ 309] = eh[ 201] - DC[0]*eh[ 145];
    eh[ 310] = eh[ 199] - DC[1]*eh[ 145];
    eh[ 311] = eh[ 203] - DC[2]*eh[ 145];
    eh[ 312] = eh[ 202] - DC[0]*eh[ 146];
    eh[ 313] = eh[ 203] - DC[1]*eh[ 146];
    eh[ 314] = eh[ 200] - DC[2]*eh[ 146];
    eh[ 315] = eh[ 204] - DC[0]*eh[ 147];
    eh[ 316] = eh[ 207] - DC[1]*eh[ 147];
    eh[ 317] = eh[ 208] - DC[2]*eh[ 147];
    eh[ 318] = eh[ 207] - DC[0]*eh[ 148];
    eh[ 319] = eh[ 205] - DC[1]*eh[ 148];
    eh[ 320] = eh[ 209] - DC[2]*eh[ 148];
    eh[ 321] = eh[ 208] - DC[0]*eh[ 149];
    eh[ 322] = eh[ 209] - DC[1]*eh[ 149];
    eh[ 323] = eh[ 206] - DC[2]*eh[ 149];
    eh[ 324] = eh[ 210] - DC[0]*eh[ 150];
    eh[ 325] = eh[ 213] - DC[1]*eh[ 150];
    eh[ 326] = eh[ 214] - DC[2]*eh[ 150];
    eh[ 327] = eh[ 213] - DC[0]*eh[ 151];
    eh[ 328] = eh[ 211] - DC[1]*eh[ 151];
    eh[ 329] = eh[ 215] - DC[2]*eh[ 151];
    eh[ 330] = eh[ 214] - DC[0]*eh[ 152];
    eh[ 331] = eh[ 215] - DC[1]*eh[ 152];
    eh[ 332] = eh[ 212] - DC[2]*eh[ 152];
    eh[ 333] = eh[ 216] - DC[0]*eh[ 153];
    eh[ 334] = eh[ 219] - DC[1]*eh[ 153];
    eh[ 335] = eh[ 220] - DC[2]*eh[ 153];
    eh[ 336] = eh[ 219] - DC[0]*eh[ 154];
    eh[ 337] = eh[ 217] - DC[1]*eh[ 154];
    eh[ 338] = eh[ 221] - DC[2]*eh[ 154];
    eh[ 339] = eh[ 220] - DC[0]*eh[ 155];
    eh[ 340] = eh[ 221] - DC[1]*eh[ 155];
    eh[ 341] = eh[ 218] - DC[2]*eh[ 155];
    eh[ 342] = eh[ 222] - DC[0]*eh[ 156];
    eh[ 343] = eh[ 225] - DC[1]*eh[ 156];
    eh[ 344] = eh[ 226] - DC[2]*eh[ 156];
    eh[ 345] = eh[ 225] - DC[0]*eh[ 157];
    eh[ 346] = eh[ 223] - DC[1]*eh[ 157];
    eh[ 347] = eh[ 227] - DC[2]*eh[ 157];
    eh[ 348] = eh[ 226] - DC[0]*eh[ 158];
    eh[ 349] = eh[ 227] - DC[1]*eh[ 158];
    eh[ 350] = eh[ 224] - DC[2]*eh[ 158];
    eh[ 351] = eh[ 228] - DC[0]*eh[ 159];
    eh[ 352] = eh[ 231] - DC[1]*eh[ 159];
    eh[ 353] = eh[ 232] - DC[2]*eh[ 159];
    eh[ 354] = eh[ 231] - DC[0]*eh[ 160];
    eh[ 355] = eh[ 229] - DC[1]*eh[ 160];
    eh[ 356] = eh[ 233] - DC[2]*eh[ 160];
    eh[ 357] = eh[ 232] - DC[0]*eh[ 161];
    eh[ 358] = eh[ 233] - DC[1]*eh[ 161];
    eh[ 359] = eh[ 230] - DC[2]*eh[ 161];
    eh[ 360] = eh[ 234] - DC[0]*eh[ 162];
    eh[ 361] = eh[ 237] - DC[1]*eh[ 162];
    eh[ 362] = eh[ 238] - DC[2]*eh[ 162];
    eh[ 363] = eh[ 237] - DC[0]*eh[ 163];
    eh[ 364] = eh[ 235] - DC[1]*eh[ 163];
    eh[ 365] = eh[ 239] - DC[2]*eh[ 163];
    eh[ 366] = eh[ 238] - DC[0]*eh[ 164];
    eh[ 367] = eh[ 239] - DC[1]*eh[ 164];
    eh[ 368] = eh[ 236] - DC[2]*eh[ 164];
    eh[ 369] = eh[ 240] - DC[0]*eh[ 165];
    eh[ 370] = eh[ 243] - DC[1]*eh[ 165];
    eh[ 371] = eh[ 244] - DC[2]*eh[ 165];
    eh[ 372] = eh[ 243] - DC[0]*eh[ 166];
    eh[ 373] = eh[ 241] - DC[1]*eh[ 166];
    eh[ 374] = eh[ 245] - DC[2]*eh[ 166];
    eh[ 375] = eh[ 244] - DC[0]*eh[ 167];
    eh[ 376] = eh[ 245] - DC[1]*eh[ 167];
    eh[ 377] = eh[ 242] - DC[2]*eh[ 167];
    eh[ 378] = eh[ 246] - DC[0]*eh[ 168];
    eh[ 379] = eh[ 249] - DC[1]*eh[ 168];
    eh[ 380] = eh[ 250] - DC[2]*eh[ 168];
    eh[ 381] = eh[ 249] - DC[0]*eh[ 169];
    eh[ 382] = eh[ 247] - DC[1]*eh[ 169];
    eh[ 383] = eh[ 251] - DC[2]*eh[ 169];
    eh[ 384] = eh[ 250] - DC[0]*eh[ 170];
    eh[ 385] = eh[ 251] - DC[1]*eh[ 170];
    eh[ 386] = eh[ 248] - DC[2]*eh[ 170];
    eh[ 387] = eh[ 252] - DC[0]*eh[ 171];
    eh[ 388] = eh[ 255] - DC[1]*eh[ 171];
    eh[ 389] = eh[ 256] - DC[2]*eh[ 171];
    eh[ 390] = eh[ 255] - DC[0]*eh[ 172];
    eh[ 391] = eh[ 253] - DC[1]*eh[ 172];
    eh[ 392] = eh[ 257] - DC[2]*eh[ 172];
    eh[ 393] = eh[ 256] - DC[0]*eh[ 173];
    eh[ 394] = eh[ 257] - DC[1]*eh[ 173];
    eh[ 395] = eh[ 254] - DC[2]*eh[ 173];
    eh[ 396] = eh[ 258] - DC[0]*eh[ 174];
    eh[ 397] = eh[ 261] - DC[1]*eh[ 174];
    eh[ 398] = eh[ 262] - DC[2]*eh[ 174];
    eh[ 399] = eh[ 261] - DC[0]*eh[ 175];
    eh[ 400] = eh[ 259] - DC[1]*eh[ 175];
    eh[ 401] = eh[ 263] - DC[2]*eh[ 175];
    eh[ 402] = eh[ 262] - DC[0]*eh[ 176];
    eh[ 403] = eh[ 263] - DC[1]*eh[ 176];
    eh[ 404] = eh[ 260] - DC[2]*eh[ 176];
    eh[ 405] = eh[ 264] - DC[0]*eh[ 177];
    eh[ 406] = eh[ 267] - DC[1]*eh[ 177];
    eh[ 407] = eh[ 268] - DC[2]*eh[ 177];
    eh[ 408] = eh[ 267] - DC[0]*eh[ 178];
    eh[ 409] = eh[ 265] - DC[1]*eh[ 178];
    eh[ 410] = eh[ 269] - DC[2]*eh[ 178];
    eh[ 411] = eh[ 268] - DC[0]*eh[ 179];
    eh[ 412] = eh[ 269] - DC[1]*eh[ 179];
    eh[ 413] = eh[ 266] - DC[2]*eh[ 179];
    eh[ 414] = eh[ 270] - DC[0]*eh[ 180];
    eh[ 415] = eh[ 273] - DC[1]*eh[ 180];
    eh[ 416] = eh[ 274] - DC[2]*eh[ 180];
    eh[ 417] = eh[ 273] - DC[0]*eh[ 181];
    eh[ 418] = eh[ 271] - DC[1]*eh[ 181];
    eh[ 419] = eh[ 275] - DC[2]*eh[ 181];
    eh[ 420] = eh[ 274] - DC[0]*eh[ 182];
    eh[ 421] = eh[ 275] - DC[1]*eh[ 182];
    eh[ 422] = eh[ 272] - DC[2]*eh[ 182];
    eh[ 423] = eh[ 276] - DC[0]*eh[ 183];
    eh[ 424] = eh[ 279] - DC[1]*eh[ 183];
    eh[ 425] = eh[ 280] - DC[2]*eh[ 183];
    eh[ 426] = eh[ 279] - DC[0]*eh[ 184];
    eh[ 427] = eh[ 277] - DC[1]*eh[ 184];
    eh[ 428] = eh[ 281] - DC[2]*eh[ 184];
    eh[ 429] = eh[ 280] - DC[0]*eh[ 185];
    eh[ 430] = eh[ 281] - DC[1]*eh[ 185];
    eh[ 431] = eh[ 278] - DC[2]*eh[ 185];
    eh[ 432] = eh[ 282] - DC[0]*eh[ 186];
    eh[ 433] = eh[ 285] - DC[1]*eh[ 186];
    eh[ 434] = eh[ 286] - DC[2]*eh[ 186];
    eh[ 435] = eh[ 285] - DC[0]*eh[ 187];
    eh[ 436] = eh[ 283] - DC[1]*eh[ 187];
    eh[ 437] = eh[ 287] - DC[2]*eh[ 187];
    eh[ 438] = eh[ 286] - DC[0]*eh[ 188];
    eh[ 439] = eh[ 287] - DC[1]*eh[ 188];
    eh[ 440] = eh[ 284] - DC[2]*eh[ 188];
    eh[ 441] = eh[ 288] - DC[0]*eh[ 189];
    eh[ 442] = eh[ 291] - DC[1]*eh[ 189];
    eh[ 443] = eh[ 292] - DC[2]*eh[ 189];
    eh[ 444] = eh[ 291] - DC[0]*eh[ 190];
    eh[ 445] = eh[ 289] - DC[1]*eh[ 190];
    eh[ 446] = eh[ 293] - DC[2]*eh[ 190];
    eh[ 447] = eh[ 292] - DC[0]*eh[ 191];
    eh[ 448] = eh[ 293] - DC[1]*eh[ 191];
    eh[ 449] = eh[ 290] - DC[2]*eh[ 191];
    eh[ 450] = eh[ 294] - DC[0]*eh[ 192];
    eh[ 451] = eh[ 297] - DC[1]*eh[ 192];
    eh[ 452] = eh[ 298] - DC[2]*eh[ 192];
    eh[ 453] = eh[ 297] - DC[0]*eh[ 193];
    eh[ 454] = eh[ 295] - DC[1]*eh[ 193];
    eh[ 455] = eh[ 299] - DC[2]*eh[ 193];
    eh[ 456] = eh[ 298] - DC[0]*eh[ 194];
    eh[ 457] = eh[ 299] - DC[1]*eh[ 194];
    eh[ 458] = eh[ 296] - DC[2]*eh[ 194];
    eh[ 459] = eh[ 300] - DC[0]*eh[ 195];
    eh[ 460] = eh[ 303] - DC[1]*eh[ 195];
    eh[ 461] = eh[ 304] - DC[2]*eh[ 195];
    eh[ 462] = eh[ 303] - DC[0]*eh[ 196];
    eh[ 463] = eh[ 301] - DC[1]*eh[ 196];
    eh[ 464] = eh[ 305] - DC[2]*eh[ 196];
    eh[ 465] = eh[ 304] - DC[0]*eh[ 197];
    eh[ 466] = eh[ 305] - DC[1]*eh[ 197];
    eh[ 467] = eh[ 302] - DC[2]*eh[ 197];
}

__device__ void gpu_hrr_coef_dppp(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 306;
    iy = 0;

#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
#pragma unroll
        for ( j=0, jao=1; j<3; j++, jao++ ) {
            coef_ab = coef_a * LDG(DFACT[jao]);
#pragma unroll
            for ( k=0, kao=1; k<3; k++, kao++ ) {
                coef_abc = coef_ab * LDG(DFACT[kao]);
#pragma unroll
                for ( l=0, lao=1; l<3; l++, lao++ ) {
                    DINT[iy] = coef_abc * LDG(DFACT[lao]) * eh[ix];
                    iy++;
                    ix++;
                }
            }
        }
    }
}

__device__ void gpu_vrr_calc_dppp(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
    // (ss|ss) m=0,5
    //fmt( &ev[0], 5, T, cssss );
    //OFMO_FMT( &ev[0], 5, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt5_method3( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 2
    gpu_fmt5_method2( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 1
    gpu_fmt5_method1( T, cssss, &ev[0] );
#else
    gpu_fmt5( &ev[0], T, cssss );
#endif
    // (ps|ss) m=0,4
    ev[ 6]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[ 7]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[ 8]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[ 9]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[10]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[11]=PA[2]*ev[1]+WP[2]*ev[2];
    ev[12]=PA[0]*ev[2]+WP[0]*ev[3];
    ev[13]=PA[1]*ev[2]+WP[1]*ev[3];
    ev[14]=PA[2]*ev[2]+WP[2]*ev[3];
    ev[15]=PA[0]*ev[3]+WP[0]*ev[4];
    ev[16]=PA[1]*ev[3]+WP[1]*ev[4];
    ev[17]=PA[2]*ev[3]+WP[2]*ev[4];
    ev[18]=PA[0]*ev[4]+WP[0]*ev[5];
    ev[19]=PA[1]*ev[4]+WP[1]*ev[5];
    ev[20]=PA[2]*ev[4]+WP[2]*ev[5];
    // (ds|ss) m=0,3
    ev[21]=PA[0]*ev[ 6]+WP[0]*ev[ 9]+zeta2*(ev[0]-rz*ev[1]);
    ev[22]=PA[1]*ev[ 7]+WP[1]*ev[10]+zeta2*(ev[0]-rz*ev[1]);
    ev[23]=PA[2]*ev[ 8]+WP[2]*ev[11]+zeta2*(ev[0]-rz*ev[1]);
    ev[24]=PA[0]*ev[ 7]+WP[0]*ev[10];
    ev[25]=PA[0]*ev[ 8]+WP[0]*ev[11];
    ev[26]=PA[1]*ev[ 8]+WP[1]*ev[11];
    ev[27]=PA[0]*ev[ 9]+WP[0]*ev[12]+zeta2*(ev[1]-rz*ev[2]);
    ev[28]=PA[1]*ev[10]+WP[1]*ev[13]+zeta2*(ev[1]-rz*ev[2]);
    ev[29]=PA[2]*ev[11]+WP[2]*ev[14]+zeta2*(ev[1]-rz*ev[2]);
    ev[30]=PA[0]*ev[10]+WP[0]*ev[13];
    ev[31]=PA[0]*ev[11]+WP[0]*ev[14];
    ev[32]=PA[1]*ev[11]+WP[1]*ev[14];
    ev[33]=PA[0]*ev[12]+WP[0]*ev[15]+zeta2*(ev[2]-rz*ev[3]);
    ev[34]=PA[1]*ev[13]+WP[1]*ev[16]+zeta2*(ev[2]-rz*ev[3]);
    ev[35]=PA[2]*ev[14]+WP[2]*ev[17]+zeta2*(ev[2]-rz*ev[3]);
    ev[36]=PA[0]*ev[13]+WP[0]*ev[16];
    ev[37]=PA[0]*ev[14]+WP[0]*ev[17];
    ev[38]=PA[1]*ev[14]+WP[1]*ev[17];
    ev[39]=PA[0]*ev[15]+WP[0]*ev[18]+zeta2*(ev[3]-rz*ev[4]);
    ev[40]=PA[1]*ev[16]+WP[1]*ev[19]+zeta2*(ev[3]-rz*ev[4]);
    ev[41]=PA[2]*ev[17]+WP[2]*ev[20]+zeta2*(ev[3]-rz*ev[4]);
    ev[42]=PA[0]*ev[16]+WP[0]*ev[19];
    ev[43]=PA[0]*ev[17]+WP[0]*ev[20];
    ev[44]=PA[1]*ev[17]+WP[1]*ev[20];
    // (fs|ss) m=0,2
    ev[45]=PA[0]*ev[21]+WP[0]*ev[27]+2.e0*zeta2*(ev[ 6]-rz*ev[ 9]);
    ev[46]=PA[1]*ev[22]+WP[1]*ev[28]+2.e0*zeta2*(ev[ 7]-rz*ev[10]);
    ev[47]=PA[2]*ev[23]+WP[2]*ev[29]+2.e0*zeta2*(ev[ 8]-rz*ev[11]);
    ev[48]=PA[1]*ev[21]+WP[1]*ev[27];
    ev[49]=PA[2]*ev[21]+WP[2]*ev[27];
    ev[50]=PA[0]*ev[22]+WP[0]*ev[28];
    ev[51]=PA[0]*ev[23]+WP[0]*ev[29];
    ev[52]=PA[0]*ev[26]+WP[0]*ev[32];
    ev[53]=PA[2]*ev[22]+WP[2]*ev[28];
    ev[54]=PA[1]*ev[23]+WP[1]*ev[29];
    ev[55]=PA[0]*ev[27]+WP[0]*ev[33]+2.e0*zeta2*(ev[ 9]-rz*ev[12]);
    ev[56]=PA[1]*ev[28]+WP[1]*ev[34]+2.e0*zeta2*(ev[10]-rz*ev[13]);
    ev[57]=PA[2]*ev[29]+WP[2]*ev[35]+2.e0*zeta2*(ev[11]-rz*ev[14]);
    ev[58]=PA[1]*ev[27]+WP[1]*ev[33];
    ev[59]=PA[2]*ev[27]+WP[2]*ev[33];
    ev[60]=PA[0]*ev[28]+WP[0]*ev[34];
    ev[61]=PA[0]*ev[29]+WP[0]*ev[35];
    ev[62]=PA[0]*ev[32]+WP[0]*ev[38];
    ev[63]=PA[2]*ev[28]+WP[2]*ev[34];
    ev[64]=PA[1]*ev[29]+WP[1]*ev[35];
    ev[65]=PA[0]*ev[33]+WP[0]*ev[39]+2.e0*zeta2*(ev[12]-rz*ev[15]);
    ev[66]=PA[1]*ev[34]+WP[1]*ev[40]+2.e0*zeta2*(ev[13]-rz*ev[16]);
    ev[67]=PA[2]*ev[35]+WP[2]*ev[41]+2.e0*zeta2*(ev[14]-rz*ev[17]);
    ev[68]=PA[1]*ev[33]+WP[1]*ev[39];
    ev[69]=PA[2]*ev[33]+WP[2]*ev[39];
    ev[70]=PA[0]*ev[34]+WP[0]*ev[40];
    ev[71]=PA[0]*ev[35]+WP[0]*ev[41];
    ev[72]=PA[0]*ev[38]+WP[0]*ev[44];
    ev[73]=PA[2]*ev[34]+WP[2]*ev[40];
    ev[74]=PA[1]*ev[35]+WP[1]*ev[41];
    // (ps|ps) m=[1,1]
    ev[75]=QC[0]*ev[ 9]+WQ[0]*ev[12]+ze2*ev[2];
    ev[76]=QC[1]*ev[ 9]+WQ[1]*ev[12];
    ev[77]=QC[2]*ev[ 9]+WQ[2]*ev[12];
    ev[78]=QC[0]*ev[10]+WQ[0]*ev[13];
    ev[79]=QC[1]*ev[10]+WQ[1]*ev[13]+ze2*ev[2];
    ev[80]=QC[2]*ev[10]+WQ[2]*ev[13];
    ev[81]=QC[0]*ev[11]+WQ[0]*ev[14];
    ev[82]=QC[1]*ev[11]+WQ[1]*ev[14];
    ev[83]=QC[2]*ev[11]+WQ[2]*ev[14]+ze2*ev[2];
    // (ds|ps) m=[0,1]
    ev[ 84]=QC[0]*ev[21]+WQ[0]*ev[27]+2.e0*ze2*ev[ 9];
    ev[ 85]=QC[1]*ev[21]+WQ[1]*ev[27];
    ev[ 86]=QC[2]*ev[21]+WQ[2]*ev[27];
    ev[ 87]=QC[0]*ev[22]+WQ[0]*ev[28];
    ev[ 88]=QC[1]*ev[22]+WQ[1]*ev[28]+2.e0*ze2*ev[10];
    ev[ 89]=QC[2]*ev[22]+WQ[2]*ev[28];
    ev[ 90]=QC[0]*ev[23]+WQ[0]*ev[29];
    ev[ 91]=QC[1]*ev[23]+WQ[1]*ev[29];
    ev[ 92]=QC[2]*ev[23]+WQ[2]*ev[29]+2.e0*ze2*ev[11];
    ev[ 93]=QC[0]*ev[24]+WQ[0]*ev[30]+     ze2*ev[10];
    ev[ 94]=QC[1]*ev[24]+WQ[1]*ev[30]+     ze2*ev[ 9];
    ev[ 95]=QC[2]*ev[24]+WQ[2]*ev[30];
    ev[ 96]=QC[0]*ev[25]+WQ[0]*ev[31]+     ze2*ev[11];
    ev[ 97]=QC[1]*ev[25]+WQ[1]*ev[31];
    ev[ 98]=QC[2]*ev[25]+WQ[2]*ev[31]+     ze2*ev[ 9];
    ev[ 99]=QC[0]*ev[26]+WQ[0]*ev[32];
    ev[100]=QC[1]*ev[26]+WQ[1]*ev[32]+     ze2*ev[11];
    ev[101]=QC[2]*ev[26]+WQ[2]*ev[32]+     ze2*ev[10];
    ev[102]=QC[0]*ev[27]+WQ[0]*ev[33]+2.e0*ze2*ev[12];
    ev[103]=QC[1]*ev[27]+WQ[1]*ev[33];
    ev[104]=QC[2]*ev[27]+WQ[2]*ev[33];
    ev[105]=QC[0]*ev[28]+WQ[0]*ev[34];
    ev[106]=QC[1]*ev[28]+WQ[1]*ev[34]+2.e0*ze2*ev[13];
    ev[107]=QC[2]*ev[28]+WQ[2]*ev[34];
    ev[108]=QC[0]*ev[29]+WQ[0]*ev[35];
    ev[109]=QC[1]*ev[29]+WQ[1]*ev[35];
    ev[110]=QC[2]*ev[29]+WQ[2]*ev[35]+2.e0*ze2*ev[14];
    ev[111]=QC[0]*ev[30]+WQ[0]*ev[36]+     ze2*ev[13];
    ev[112]=QC[1]*ev[30]+WQ[1]*ev[36]+     ze2*ev[12];
    ev[113]=QC[2]*ev[30]+WQ[2]*ev[36];
    ev[114]=QC[0]*ev[31]+WQ[0]*ev[37]+     ze2*ev[14];
    ev[115]=QC[1]*ev[31]+WQ[1]*ev[37];
    ev[116]=QC[2]*ev[31]+WQ[2]*ev[37]+     ze2*ev[12];
    ev[117]=QC[0]*ev[32]+WQ[0]*ev[38];
    ev[118]=QC[1]*ev[32]+WQ[1]*ev[38]+     ze2*ev[14];
    ev[119]=QC[2]*ev[32]+WQ[2]*ev[38]+     ze2*ev[13];
    // (fs|ps) m=[0,1]
    ev[120]=QC[0]*ev[45]+WQ[0]*ev[55]+3.e0*ze2*ev[27];
    ev[121]=QC[1]*ev[45]+WQ[1]*ev[55];
    ev[122]=QC[2]*ev[45]+WQ[2]*ev[55];
    ev[123]=QC[0]*ev[46]+WQ[0]*ev[56];
    ev[124]=QC[1]*ev[46]+WQ[1]*ev[56]+3.e0*ze2*ev[28];
    ev[125]=QC[2]*ev[46]+WQ[2]*ev[56];
    ev[126]=QC[0]*ev[47]+WQ[0]*ev[57];
    ev[127]=QC[1]*ev[47]+WQ[1]*ev[57];
    ev[128]=QC[2]*ev[47]+WQ[2]*ev[57]+3.e0*ze2*ev[29];
    ev[129]=QC[0]*ev[48]+WQ[0]*ev[58]+2.e0*ze2*ev[30];
    ev[130]=QC[1]*ev[48]+WQ[1]*ev[58]+     ze2*ev[27];
    ev[131]=QC[2]*ev[48]+WQ[2]*ev[58];
    ev[132]=QC[0]*ev[49]+WQ[0]*ev[59]+2.e0*ze2*ev[31];
    ev[133]=QC[1]*ev[49]+WQ[1]*ev[59];
    ev[134]=QC[2]*ev[49]+WQ[2]*ev[59]+     ze2*ev[27];
    ev[135]=QC[0]*ev[50]+WQ[0]*ev[60]+     ze2*ev[28];
    ev[136]=QC[1]*ev[50]+WQ[1]*ev[60]+2.e0*ze2*ev[30];
    ev[137]=QC[2]*ev[50]+WQ[2]*ev[60];
    ev[138]=QC[0]*ev[51]+WQ[0]*ev[61]+     ze2*ev[29];
    ev[139]=QC[1]*ev[51]+WQ[1]*ev[61];
    ev[140]=QC[2]*ev[51]+WQ[2]*ev[61]+2.e0*ze2*ev[31];
    ev[141]=QC[0]*ev[52]+WQ[0]*ev[62]+     ze2*ev[32];
    ev[142]=QC[1]*ev[52]+WQ[1]*ev[62]+     ze2*ev[31];
    ev[143]=QC[2]*ev[52]+WQ[2]*ev[62]+     ze2*ev[30];
    ev[144]=QC[0]*ev[53]+WQ[0]*ev[63];
    ev[145]=QC[1]*ev[53]+WQ[1]*ev[63]+2.e0*ze2*ev[32];
    ev[146]=QC[2]*ev[53]+WQ[2]*ev[63]+     ze2*ev[28];
    ev[147]=QC[0]*ev[54]+WQ[0]*ev[64];
    ev[148]=QC[1]*ev[54]+WQ[1]*ev[64]+     ze2*ev[29];
    ev[149]=QC[2]*ev[54]+WQ[2]*ev[64]+2.e0*ze2*ev[32];
    ev[150]=QC[0]*ev[55]+WQ[0]*ev[65]+3.e0*ze2*ev[33];
    ev[151]=QC[1]*ev[55]+WQ[1]*ev[65];
    ev[152]=QC[2]*ev[55]+WQ[2]*ev[65];
    ev[153]=QC[0]*ev[56]+WQ[0]*ev[66];
    ev[154]=QC[1]*ev[56]+WQ[1]*ev[66]+3.e0*ze2*ev[34];
    ev[155]=QC[2]*ev[56]+WQ[2]*ev[66];
    ev[156]=QC[0]*ev[57]+WQ[0]*ev[67];
    ev[157]=QC[1]*ev[57]+WQ[1]*ev[67];
    ev[158]=QC[2]*ev[57]+WQ[2]*ev[67]+3.e0*ze2*ev[35];
    ev[159]=QC[0]*ev[58]+WQ[0]*ev[68]+2.e0*ze2*ev[36];
    ev[160]=QC[1]*ev[58]+WQ[1]*ev[68]+     ze2*ev[33];
    ev[161]=QC[2]*ev[58]+WQ[2]*ev[68];
    ev[162]=QC[0]*ev[59]+WQ[0]*ev[69]+2.e0*ze2*ev[37];
    ev[163]=QC[1]*ev[59]+WQ[1]*ev[69];
    ev[164]=QC[2]*ev[59]+WQ[2]*ev[69]+     ze2*ev[33];
    ev[165]=QC[0]*ev[60]+WQ[0]*ev[70]+     ze2*ev[34];
    ev[166]=QC[1]*ev[60]+WQ[1]*ev[70]+2.e0*ze2*ev[36];
    ev[167]=QC[2]*ev[60]+WQ[2]*ev[70];
    ev[168]=QC[0]*ev[61]+WQ[0]*ev[71]+     ze2*ev[35];
    ev[169]=QC[1]*ev[61]+WQ[1]*ev[71];
    ev[170]=QC[2]*ev[61]+WQ[2]*ev[71]+2.e0*ze2*ev[37];
    ev[171]=QC[0]*ev[62]+WQ[0]*ev[72]+     ze2*ev[38];
    ev[172]=QC[1]*ev[62]+WQ[1]*ev[72]+     ze2*ev[37];
    ev[173]=QC[2]*ev[62]+WQ[2]*ev[72]+     ze2*ev[36];
    ev[174]=QC[0]*ev[63]+WQ[0]*ev[73];
    ev[175]=QC[1]*ev[63]+WQ[1]*ev[73]+2.e0*ze2*ev[38];
    ev[176]=QC[2]*ev[63]+WQ[2]*ev[73]+     ze2*ev[34];
    ev[177]=QC[0]*ev[64]+WQ[0]*ev[74];
    ev[178]=QC[1]*ev[64]+WQ[1]*ev[74]+     ze2*ev[35];
    ev[179]=QC[2]*ev[64]+WQ[2]*ev[74]+2.e0*ze2*ev[38];
    // (ds|ds) m=[0,0]
    ev[180]=QC[0]*ev[ 84]+WQ[0]*ev[102]+eta2*(ev[21]-re*ev[27])
            +2.e0*ze2*ev[75];
    ev[181]=QC[1]*ev[ 85]+WQ[1]*ev[103]+eta2*(ev[21]-re*ev[27]);
    ev[182]=QC[2]*ev[ 86]+WQ[2]*ev[104]+eta2*(ev[21]-re*ev[27]);
    ev[183]=QC[0]*ev[ 85]+WQ[0]*ev[103]+2.e0*ze2*ev[76];
    ev[184]=QC[0]*ev[ 86]+WQ[0]*ev[104]+2.e0*ze2*ev[77];
    ev[185]=QC[1]*ev[ 86]+WQ[1]*ev[104];
    ev[186]=QC[0]*ev[ 87]+WQ[0]*ev[105]+eta2*(ev[22]-re*ev[28]);
    ev[187]=QC[1]*ev[ 88]+WQ[1]*ev[106]+eta2*(ev[22]-re*ev[28])
            +2.e0*ze2*ev[79];
    ev[188]=QC[2]*ev[ 89]+WQ[2]*ev[107]+eta2*(ev[22]-re*ev[28]);
    ev[189]=QC[0]*ev[ 88]+WQ[0]*ev[106];
    ev[190]=QC[0]*ev[ 89]+WQ[0]*ev[107];
    ev[191]=QC[1]*ev[ 89]+WQ[1]*ev[107]+2.e0*ze2*ev[80];
    ev[192]=QC[0]*ev[ 90]+WQ[0]*ev[108]+eta2*(ev[23]-re*ev[29]);
    ev[193]=QC[1]*ev[ 91]+WQ[1]*ev[109]+eta2*(ev[23]-re*ev[29]);
    ev[194]=QC[2]*ev[ 92]+WQ[2]*ev[110]+eta2*(ev[23]-re*ev[29])
            +2.e0*ze2*ev[83];
    ev[195]=QC[0]*ev[ 91]+WQ[0]*ev[109];
    ev[196]=QC[0]*ev[ 92]+WQ[0]*ev[110];
    ev[197]=QC[1]*ev[ 92]+WQ[1]*ev[110];
    ev[198]=QC[0]*ev[ 93]+WQ[0]*ev[111]+eta2*(ev[24]-re*ev[30])
            +     ze2*ev[78];
    ev[199]=QC[1]*ev[ 94]+WQ[1]*ev[112]+eta2*(ev[24]-re*ev[30])
            +     ze2*ev[76];
    ev[200]=QC[2]*ev[ 95]+WQ[2]*ev[113]+eta2*(ev[24]-re*ev[30]);
    ev[201]=QC[0]*ev[ 94]+WQ[0]*ev[112]+     ze2*ev[79];
    ev[202]=QC[0]*ev[ 95]+WQ[0]*ev[113]+     ze2*ev[80];
    ev[203]=QC[1]*ev[ 95]+WQ[1]*ev[113]+     ze2*ev[77];
    ev[204]=QC[0]*ev[ 96]+WQ[0]*ev[114]+eta2*(ev[25]-re*ev[31])
            +     ze2*ev[81];
    ev[205]=QC[1]*ev[ 97]+WQ[1]*ev[115]+eta2*(ev[25]-re*ev[31]);
    ev[206]=QC[2]*ev[ 98]+WQ[2]*ev[116]+eta2*(ev[25]-re*ev[31])
            +     ze2*ev[77];
    ev[207]=QC[0]*ev[ 97]+WQ[0]*ev[115]+     ze2*ev[82];
    ev[208]=QC[0]*ev[ 98]+WQ[0]*ev[116]+     ze2*ev[83];
    ev[209]=QC[1]*ev[ 98]+WQ[1]*ev[116];
    ev[210]=QC[0]*ev[ 99]+WQ[0]*ev[117]+eta2*(ev[26]-re*ev[32]);
    ev[211]=QC[1]*ev[100]+WQ[1]*ev[118]+eta2*(ev[26]-re*ev[32])
            +     ze2*ev[82];
    ev[212]=QC[2]*ev[101]+WQ[2]*ev[119]+eta2*(ev[26]-re*ev[32])
            +     ze2*ev[80];
    ev[213]=QC[0]*ev[100]+WQ[0]*ev[118];
    ev[214]=QC[0]*ev[101]+WQ[0]*ev[119];
    ev[215]=QC[1]*ev[101]+WQ[1]*ev[119]+     ze2*ev[83];
    // (fs|ds) m=[0,0]
    ev[216]=QC[0]*ev[120]+WQ[0]*ev[150]+eta2*(ev[45]-re*ev[55])
            +3.e0*ze2*ev[102];
    ev[217]=QC[1]*ev[121]+WQ[1]*ev[151]+eta2*(ev[45]-re*ev[55]);
    ev[218]=QC[2]*ev[122]+WQ[2]*ev[152]+eta2*(ev[45]-re*ev[55]);
    ev[219]=QC[0]*ev[121]+WQ[0]*ev[151]+3.e0*ze2*ev[103];
    ev[220]=QC[0]*ev[122]+WQ[0]*ev[152]+3.e0*ze2*ev[104];
    ev[221]=QC[1]*ev[122]+WQ[1]*ev[152];
    ev[222]=QC[0]*ev[123]+WQ[0]*ev[153]+eta2*(ev[46]-re*ev[56]);
    ev[223]=QC[1]*ev[124]+WQ[1]*ev[154]+eta2*(ev[46]-re*ev[56])
            +3.e0*ze2*ev[106];
    ev[224]=QC[2]*ev[125]+WQ[2]*ev[155]+eta2*(ev[46]-re*ev[56]);
    ev[225]=QC[0]*ev[124]+WQ[0]*ev[154];
    ev[226]=QC[0]*ev[125]+WQ[0]*ev[155];
    ev[227]=QC[1]*ev[125]+WQ[1]*ev[155]+3.e0*ze2*ev[107];
    ev[228]=QC[0]*ev[126]+WQ[0]*ev[156]+eta2*(ev[47]-re*ev[57]);
    ev[229]=QC[1]*ev[127]+WQ[1]*ev[157]+eta2*(ev[47]-re*ev[57]);
    ev[230]=QC[2]*ev[128]+WQ[2]*ev[158]+eta2*(ev[47]-re*ev[57])
            +3.e0*ze2*ev[110];
    ev[231]=QC[0]*ev[127]+WQ[0]*ev[157];
    ev[232]=QC[0]*ev[128]+WQ[0]*ev[158];
    ev[233]=QC[1]*ev[128]+WQ[1]*ev[158];
    ev[234]=QC[0]*ev[129]+WQ[0]*ev[159]+eta2*(ev[48]-re*ev[58])
            +2.e0*ze2*ev[111];
    ev[235]=QC[1]*ev[130]+WQ[1]*ev[160]+eta2*(ev[48]-re*ev[58])
            +     ze2*ev[103];
    ev[236]=QC[2]*ev[131]+WQ[2]*ev[161]+eta2*(ev[48]-re*ev[58]);
    ev[237]=QC[0]*ev[130]+WQ[0]*ev[160]+2.e0*ze2*ev[112];
    ev[238]=QC[0]*ev[131]+WQ[0]*ev[161]+2.e0*ze2*ev[113];
    ev[239]=QC[1]*ev[131]+WQ[1]*ev[161]+     ze2*ev[104];
    ev[240]=QC[0]*ev[132]+WQ[0]*ev[162]+eta2*(ev[49]-re*ev[59])
            +2.e0*ze2*ev[114];
    ev[241]=QC[1]*ev[133]+WQ[1]*ev[163]+eta2*(ev[49]-re*ev[59]);
    ev[242]=QC[2]*ev[134]+WQ[2]*ev[164]+eta2*(ev[49]-re*ev[59])
            +     ze2*ev[104];
    ev[243]=QC[0]*ev[133]+WQ[0]*ev[163]+2.e0*ze2*ev[115];
    ev[244]=QC[0]*ev[134]+WQ[0]*ev[164]+2.e0*ze2*ev[116];
    ev[245]=QC[1]*ev[134]+WQ[1]*ev[164];
    ev[246]=QC[0]*ev[135]+WQ[0]*ev[165]+eta2*(ev[50]-re*ev[60])
            +     ze2*ev[105];
    ev[247]=QC[1]*ev[136]+WQ[1]*ev[166]+eta2*(ev[50]-re*ev[60])
            +2.e0*ze2*ev[112];
    ev[248]=QC[2]*ev[137]+WQ[2]*ev[167]+eta2*(ev[50]-re*ev[60]);
    ev[249]=QC[0]*ev[136]+WQ[0]*ev[166]+     ze2*ev[106];
    ev[250]=QC[0]*ev[137]+WQ[0]*ev[167]+     ze2*ev[107];
    ev[251]=QC[1]*ev[137]+WQ[1]*ev[167]+2.e0*ze2*ev[113];
    ev[252]=QC[0]*ev[138]+WQ[0]*ev[168]+eta2*(ev[51]-re*ev[61])
            +     ze2*ev[108];
    ev[253]=QC[1]*ev[139]+WQ[1]*ev[169]+eta2*(ev[51]-re*ev[61]);
    ev[254]=QC[2]*ev[140]+WQ[2]*ev[170]+eta2*(ev[51]-re*ev[61])
            +2.e0*ze2*ev[116];
    ev[255]=QC[0]*ev[139]+WQ[0]*ev[169]+     ze2*ev[109];
    ev[256]=QC[0]*ev[140]+WQ[0]*ev[170]+     ze2*ev[110];
    ev[257]=QC[1]*ev[140]+WQ[1]*ev[170];
    ev[258]=QC[0]*ev[141]+WQ[0]*ev[171]+eta2*(ev[52]-re*ev[62])
            +     ze2*ev[117];
    ev[259]=QC[1]*ev[142]+WQ[1]*ev[172]+eta2*(ev[52]-re*ev[62])
            +     ze2*ev[115];
    ev[260]=QC[2]*ev[143]+WQ[2]*ev[173]+eta2*(ev[52]-re*ev[62])
            +     ze2*ev[113];
    ev[261]=QC[0]*ev[142]+WQ[0]*ev[172]+     ze2*ev[118];
    ev[262]=QC[0]*ev[143]+WQ[0]*ev[173]+     ze2*ev[119];
    ev[263]=QC[1]*ev[143]+WQ[1]*ev[173]+     ze2*ev[116];
    ev[264]=QC[0]*ev[144]+WQ[0]*ev[174]+eta2*(ev[53]-re*ev[63]);
    ev[265]=QC[1]*ev[145]+WQ[1]*ev[175]+eta2*(ev[53]-re*ev[63])
            +2.e0*ze2*ev[118];
    ev[266]=QC[2]*ev[146]+WQ[2]*ev[176]+eta2*(ev[53]-re*ev[63])
            +     ze2*ev[107];
    ev[267]=QC[0]*ev[145]+WQ[0]*ev[175];
    ev[268]=QC[0]*ev[146]+WQ[0]*ev[176];
    ev[269]=QC[1]*ev[146]+WQ[1]*ev[176]+2.e0*ze2*ev[119];
    ev[270]=QC[0]*ev[147]+WQ[0]*ev[177]+eta2*(ev[54]-re*ev[64]);
    ev[271]=QC[1]*ev[148]+WQ[1]*ev[178]+eta2*(ev[54]-re*ev[64])
            +     ze2*ev[109];
    ev[272]=QC[2]*ev[149]+WQ[2]*ev[179]+eta2*(ev[54]-re*ev[64])
            +2.e0*ze2*ev[119];
    ev[273]=QC[0]*ev[148]+WQ[0]*ev[178];
    ev[274]=QC[0]*ev[149]+WQ[0]*ev[179];
    ev[275]=QC[1]*ev[149]+WQ[1]*ev[179]+     ze2*ev[110];
}

__device__ void gpu_vrr_cint_dppp( const double *ev, double *eh ) {
    int La=2, Lb=1, Lc=1, Ld=1;
    int i, ih, iv;
    // (DS|PS)
#pragma unroll
    for ( i=0, iv=84, ih=0; i<18; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (DS|DS)
#pragma unroll
    for ( i=0, iv=180, ih=18; i<36; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|PS)
#pragma unroll
    for ( i=0, iv=120, ih=54; i<30; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|DS)
#pragma unroll
    for ( i=0, iv=216, ih=84; i<60; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dppp(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[276], eh[468];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

//    DFACT = ofmo_getadd_dfact();
    gpu_hrr_clear_dppp( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            re    = rho * eta;
            ze2 = rz * eta2;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_dppp(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_dppp( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_calc_dppp( BA, DC, eh );
    gpu_hrr_coef_dppp( eh, DINT );
}

#if 0
int ofmo_twoint_os_dppp(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*3*3];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*3*3*3;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dppp(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*3; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_dppp(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*3*3];
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*3*3*3;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*ofmo_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dppp(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*3; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // if 0
// dpps
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_dpds( double *eh ) {
    int i;
    // (DS|DS)
#pragma unroll
    for ( i=0; i<(0+36); i++ ) eh[i] = 0.e0;
    // (FS|DS)
#pragma unroll
    for ( i=36; i<(36+60); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_calc_dpds(
        const double BA[3], const double DC[3], double *eh ) {
    // (DP,DS)
    eh[  96] = eh[  36] - BA[0]*eh[   0];
    eh[  97] = eh[  37] - BA[0]*eh[   1];
    eh[  98] = eh[  38] - BA[0]*eh[   2];
    eh[  99] = eh[  39] - BA[0]*eh[   3];
    eh[ 100] = eh[  40] - BA[0]*eh[   4];
    eh[ 101] = eh[  41] - BA[0]*eh[   5];
    eh[ 102] = eh[  54] - BA[1]*eh[   0];
    eh[ 103] = eh[  55] - BA[1]*eh[   1];
    eh[ 104] = eh[  56] - BA[1]*eh[   2];
    eh[ 105] = eh[  57] - BA[1]*eh[   3];
    eh[ 106] = eh[  58] - BA[1]*eh[   4];
    eh[ 107] = eh[  59] - BA[1]*eh[   5];
    eh[ 108] = eh[  60] - BA[2]*eh[   0];
    eh[ 109] = eh[  61] - BA[2]*eh[   1];
    eh[ 110] = eh[  62] - BA[2]*eh[   2];
    eh[ 111] = eh[  63] - BA[2]*eh[   3];
    eh[ 112] = eh[  64] - BA[2]*eh[   4];
    eh[ 113] = eh[  65] - BA[2]*eh[   5];
    eh[ 114] = eh[  66] - BA[0]*eh[   6];
    eh[ 115] = eh[  67] - BA[0]*eh[   7];
    eh[ 116] = eh[  68] - BA[0]*eh[   8];
    eh[ 117] = eh[  69] - BA[0]*eh[   9];
    eh[ 118] = eh[  70] - BA[0]*eh[  10];
    eh[ 119] = eh[  71] - BA[0]*eh[  11];
    eh[ 120] = eh[  42] - BA[1]*eh[   6];
    eh[ 121] = eh[  43] - BA[1]*eh[   7];
    eh[ 122] = eh[  44] - BA[1]*eh[   8];
    eh[ 123] = eh[  45] - BA[1]*eh[   9];
    eh[ 124] = eh[  46] - BA[1]*eh[  10];
    eh[ 125] = eh[  47] - BA[1]*eh[  11];
    eh[ 126] = eh[  84] - BA[2]*eh[   6];
    eh[ 127] = eh[  85] - BA[2]*eh[   7];
    eh[ 128] = eh[  86] - BA[2]*eh[   8];
    eh[ 129] = eh[  87] - BA[2]*eh[   9];
    eh[ 130] = eh[  88] - BA[2]*eh[  10];
    eh[ 131] = eh[  89] - BA[2]*eh[  11];
    eh[ 132] = eh[  72] - BA[0]*eh[  12];
    eh[ 133] = eh[  73] - BA[0]*eh[  13];
    eh[ 134] = eh[  74] - BA[0]*eh[  14];
    eh[ 135] = eh[  75] - BA[0]*eh[  15];
    eh[ 136] = eh[  76] - BA[0]*eh[  16];
    eh[ 137] = eh[  77] - BA[0]*eh[  17];
    eh[ 138] = eh[  90] - BA[1]*eh[  12];
    eh[ 139] = eh[  91] - BA[1]*eh[  13];
    eh[ 140] = eh[  92] - BA[1]*eh[  14];
    eh[ 141] = eh[  93] - BA[1]*eh[  15];
    eh[ 142] = eh[  94] - BA[1]*eh[  16];
    eh[ 143] = eh[  95] - BA[1]*eh[  17];
    eh[ 144] = eh[  48] - BA[2]*eh[  12];
    eh[ 145] = eh[  49] - BA[2]*eh[  13];
    eh[ 146] = eh[  50] - BA[2]*eh[  14];
    eh[ 147] = eh[  51] - BA[2]*eh[  15];
    eh[ 148] = eh[  52] - BA[2]*eh[  16];
    eh[ 149] = eh[  53] - BA[2]*eh[  17];
    eh[ 150] = eh[  54] - BA[0]*eh[  18];
    eh[ 151] = eh[  55] - BA[0]*eh[  19];
    eh[ 152] = eh[  56] - BA[0]*eh[  20];
    eh[ 153] = eh[  57] - BA[0]*eh[  21];
    eh[ 154] = eh[  58] - BA[0]*eh[  22];
    eh[ 155] = eh[  59] - BA[0]*eh[  23];
    eh[ 156] = eh[  66] - BA[1]*eh[  18];
    eh[ 157] = eh[  67] - BA[1]*eh[  19];
    eh[ 158] = eh[  68] - BA[1]*eh[  20];
    eh[ 159] = eh[  69] - BA[1]*eh[  21];
    eh[ 160] = eh[  70] - BA[1]*eh[  22];
    eh[ 161] = eh[  71] - BA[1]*eh[  23];
    eh[ 162] = eh[  78] - BA[2]*eh[  18];
    eh[ 163] = eh[  79] - BA[2]*eh[  19];
    eh[ 164] = eh[  80] - BA[2]*eh[  20];
    eh[ 165] = eh[  81] - BA[2]*eh[  21];
    eh[ 166] = eh[  82] - BA[2]*eh[  22];
    eh[ 167] = eh[  83] - BA[2]*eh[  23];
    eh[ 168] = eh[  60] - BA[0]*eh[  24];
    eh[ 169] = eh[  61] - BA[0]*eh[  25];
    eh[ 170] = eh[  62] - BA[0]*eh[  26];
    eh[ 171] = eh[  63] - BA[0]*eh[  27];
    eh[ 172] = eh[  64] - BA[0]*eh[  28];
    eh[ 173] = eh[  65] - BA[0]*eh[  29];
    eh[ 174] = eh[  78] - BA[1]*eh[  24];
    eh[ 175] = eh[  79] - BA[1]*eh[  25];
    eh[ 176] = eh[  80] - BA[1]*eh[  26];
    eh[ 177] = eh[  81] - BA[1]*eh[  27];
    eh[ 178] = eh[  82] - BA[1]*eh[  28];
    eh[ 179] = eh[  83] - BA[1]*eh[  29];
    eh[ 180] = eh[  72] - BA[2]*eh[  24];
    eh[ 181] = eh[  73] - BA[2]*eh[  25];
    eh[ 182] = eh[  74] - BA[2]*eh[  26];
    eh[ 183] = eh[  75] - BA[2]*eh[  27];
    eh[ 184] = eh[  76] - BA[2]*eh[  28];
    eh[ 185] = eh[  77] - BA[2]*eh[  29];
    eh[ 186] = eh[  78] - BA[0]*eh[  30];
    eh[ 187] = eh[  79] - BA[0]*eh[  31];
    eh[ 188] = eh[  80] - BA[0]*eh[  32];
    eh[ 189] = eh[  81] - BA[0]*eh[  33];
    eh[ 190] = eh[  82] - BA[0]*eh[  34];
    eh[ 191] = eh[  83] - BA[0]*eh[  35];
    eh[ 192] = eh[  84] - BA[1]*eh[  30];
    eh[ 193] = eh[  85] - BA[1]*eh[  31];
    eh[ 194] = eh[  86] - BA[1]*eh[  32];
    eh[ 195] = eh[  87] - BA[1]*eh[  33];
    eh[ 196] = eh[  88] - BA[1]*eh[  34];
    eh[ 197] = eh[  89] - BA[1]*eh[  35];
    eh[ 198] = eh[  90] - BA[2]*eh[  30];
    eh[ 199] = eh[  91] - BA[2]*eh[  31];
    eh[ 200] = eh[  92] - BA[2]*eh[  32];
    eh[ 201] = eh[  93] - BA[2]*eh[  33];
    eh[ 202] = eh[  94] - BA[2]*eh[  34];
    eh[ 203] = eh[  95] - BA[2]*eh[  35];
    // HRR for (XX|XX)-type integral (center CD)
}

__device__ void gpu_hrr_coef_dpds(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 96;
    iy = 0;

#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
#pragma unroll
        for ( j=0, jao=1; j<3; j++, jao++ ) {
            coef_ab = coef_a * LDG(DFACT[jao]);
#pragma unroll
            for ( k=0, kao=4; k<6; k++, kao++ ) {
                coef_abc = coef_ab * LDG(DFACT[kao]);
                DINT[iy] = coef_abc * eh[ix];
                iy++;
                ix++;
            }
        }
    }
}

__device__ void gpu_vrr_calc_dpds(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
    // (ss|ss) m=0,5
    //fmt( &ev[0], 5, T, cssss );
    //OFMO_FMT( &ev[0], 5, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt5_method3( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 2
    gpu_fmt5_method2( T, cssss, &ev[0] );
#elif CUDA_FMT_M == 1
    gpu_fmt5_method1( T, cssss, &ev[0] );
#else
    gpu_fmt5( &ev[0], T, cssss );
#endif
    // (ps|ss) m=0,4
    ev[ 6]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[ 7]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[ 8]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[ 9]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[10]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[11]=PA[2]*ev[1]+WP[2]*ev[2];
    ev[12]=PA[0]*ev[2]+WP[0]*ev[3];
    ev[13]=PA[1]*ev[2]+WP[1]*ev[3];
    ev[14]=PA[2]*ev[2]+WP[2]*ev[3];
    ev[15]=PA[0]*ev[3]+WP[0]*ev[4];
    ev[16]=PA[1]*ev[3]+WP[1]*ev[4];
    ev[17]=PA[2]*ev[3]+WP[2]*ev[4];
    ev[18]=PA[0]*ev[4]+WP[0]*ev[5];
    ev[19]=PA[1]*ev[4]+WP[1]*ev[5];
    ev[20]=PA[2]*ev[4]+WP[2]*ev[5];
    // (ds|ss) m=0,3
    ev[21]=PA[0]*ev[ 6]+WP[0]*ev[ 9]+zeta2*(ev[0]-rz*ev[1]);
    ev[22]=PA[1]*ev[ 7]+WP[1]*ev[10]+zeta2*(ev[0]-rz*ev[1]);
    ev[23]=PA[2]*ev[ 8]+WP[2]*ev[11]+zeta2*(ev[0]-rz*ev[1]);
    ev[24]=PA[0]*ev[ 7]+WP[0]*ev[10];
    ev[25]=PA[0]*ev[ 8]+WP[0]*ev[11];
    ev[26]=PA[1]*ev[ 8]+WP[1]*ev[11];
    ev[27]=PA[0]*ev[ 9]+WP[0]*ev[12]+zeta2*(ev[1]-rz*ev[2]);
    ev[28]=PA[1]*ev[10]+WP[1]*ev[13]+zeta2*(ev[1]-rz*ev[2]);
    ev[29]=PA[2]*ev[11]+WP[2]*ev[14]+zeta2*(ev[1]-rz*ev[2]);
    ev[30]=PA[0]*ev[10]+WP[0]*ev[13];
    ev[31]=PA[0]*ev[11]+WP[0]*ev[14];
    ev[32]=PA[1]*ev[11]+WP[1]*ev[14];
    ev[33]=PA[0]*ev[12]+WP[0]*ev[15]+zeta2*(ev[2]-rz*ev[3]);
    ev[34]=PA[1]*ev[13]+WP[1]*ev[16]+zeta2*(ev[2]-rz*ev[3]);
    ev[35]=PA[2]*ev[14]+WP[2]*ev[17]+zeta2*(ev[2]-rz*ev[3]);
    ev[36]=PA[0]*ev[13]+WP[0]*ev[16];
    ev[37]=PA[0]*ev[14]+WP[0]*ev[17];
    ev[38]=PA[1]*ev[14]+WP[1]*ev[17];
    ev[39]=PA[0]*ev[15]+WP[0]*ev[18]+zeta2*(ev[3]-rz*ev[4]);
    ev[40]=PA[1]*ev[16]+WP[1]*ev[19]+zeta2*(ev[3]-rz*ev[4]);
    ev[41]=PA[2]*ev[17]+WP[2]*ev[20]+zeta2*(ev[3]-rz*ev[4]);
    ev[42]=PA[0]*ev[16]+WP[0]*ev[19];
    ev[43]=PA[0]*ev[17]+WP[0]*ev[20];
    ev[44]=PA[1]*ev[17]+WP[1]*ev[20];
    // (fs|ss) m=0,2
    ev[45]=PA[0]*ev[21]+WP[0]*ev[27]+2.e0*zeta2*(ev[ 6]-rz*ev[ 9]);
    ev[46]=PA[1]*ev[22]+WP[1]*ev[28]+2.e0*zeta2*(ev[ 7]-rz*ev[10]);
    ev[47]=PA[2]*ev[23]+WP[2]*ev[29]+2.e0*zeta2*(ev[ 8]-rz*ev[11]);
    ev[48]=PA[1]*ev[21]+WP[1]*ev[27];
    ev[49]=PA[2]*ev[21]+WP[2]*ev[27];
    ev[50]=PA[0]*ev[22]+WP[0]*ev[28];
    ev[51]=PA[0]*ev[23]+WP[0]*ev[29];
    ev[52]=PA[0]*ev[26]+WP[0]*ev[32];
    ev[53]=PA[2]*ev[22]+WP[2]*ev[28];
    ev[54]=PA[1]*ev[23]+WP[1]*ev[29];
    ev[55]=PA[0]*ev[27]+WP[0]*ev[33]+2.e0*zeta2*(ev[ 9]-rz*ev[12]);
    ev[56]=PA[1]*ev[28]+WP[1]*ev[34]+2.e0*zeta2*(ev[10]-rz*ev[13]);
    ev[57]=PA[2]*ev[29]+WP[2]*ev[35]+2.e0*zeta2*(ev[11]-rz*ev[14]);
    ev[58]=PA[1]*ev[27]+WP[1]*ev[33];
    ev[59]=PA[2]*ev[27]+WP[2]*ev[33];
    ev[60]=PA[0]*ev[28]+WP[0]*ev[34];
    ev[61]=PA[0]*ev[29]+WP[0]*ev[35];
    ev[62]=PA[0]*ev[32]+WP[0]*ev[38];
    ev[63]=PA[2]*ev[28]+WP[2]*ev[34];
    ev[64]=PA[1]*ev[29]+WP[1]*ev[35];
    ev[65]=PA[0]*ev[33]+WP[0]*ev[39]+2.e0*zeta2*(ev[12]-rz*ev[15]);
    ev[66]=PA[1]*ev[34]+WP[1]*ev[40]+2.e0*zeta2*(ev[13]-rz*ev[16]);
    ev[67]=PA[2]*ev[35]+WP[2]*ev[41]+2.e0*zeta2*(ev[14]-rz*ev[17]);
    ev[68]=PA[1]*ev[33]+WP[1]*ev[39];
    ev[69]=PA[2]*ev[33]+WP[2]*ev[39];
    ev[70]=PA[0]*ev[34]+WP[0]*ev[40];
    ev[71]=PA[0]*ev[35]+WP[0]*ev[41];
    ev[72]=PA[0]*ev[38]+WP[0]*ev[44];
    ev[73]=PA[2]*ev[34]+WP[2]*ev[40];
    ev[74]=PA[1]*ev[35]+WP[1]*ev[41];
    // (ps|ps) m=[1,1]
    ev[75]=QC[0]*ev[ 9]+WQ[0]*ev[12]+ze2*ev[2];
    ev[76]=QC[1]*ev[ 9]+WQ[1]*ev[12];
    ev[77]=QC[2]*ev[ 9]+WQ[2]*ev[12];
    ev[78]=QC[0]*ev[10]+WQ[0]*ev[13];
    ev[79]=QC[1]*ev[10]+WQ[1]*ev[13]+ze2*ev[2];
    ev[80]=QC[2]*ev[10]+WQ[2]*ev[13];
    ev[81]=QC[0]*ev[11]+WQ[0]*ev[14];
    ev[82]=QC[1]*ev[11]+WQ[1]*ev[14];
    ev[83]=QC[2]*ev[11]+WQ[2]*ev[14]+ze2*ev[2];
    // (ds|ps) m=[0,1]
    ev[ 84]=QC[0]*ev[21]+WQ[0]*ev[27]+2.e0*ze2*ev[ 9];
    ev[ 85]=QC[1]*ev[21]+WQ[1]*ev[27];
    ev[ 86]=QC[2]*ev[21]+WQ[2]*ev[27];
    ev[ 87]=QC[0]*ev[22]+WQ[0]*ev[28];
    ev[ 88]=QC[1]*ev[22]+WQ[1]*ev[28]+2.e0*ze2*ev[10];
    ev[ 89]=QC[2]*ev[22]+WQ[2]*ev[28];
    ev[ 90]=QC[0]*ev[23]+WQ[0]*ev[29];
    ev[ 91]=QC[1]*ev[23]+WQ[1]*ev[29];
    ev[ 92]=QC[2]*ev[23]+WQ[2]*ev[29]+2.e0*ze2*ev[11];
    ev[ 93]=QC[0]*ev[24]+WQ[0]*ev[30]+     ze2*ev[10];
    ev[ 94]=QC[1]*ev[24]+WQ[1]*ev[30]+     ze2*ev[ 9];
    ev[ 95]=QC[2]*ev[24]+WQ[2]*ev[30];
    ev[ 96]=QC[0]*ev[25]+WQ[0]*ev[31]+     ze2*ev[11];
    ev[ 97]=QC[1]*ev[25]+WQ[1]*ev[31];
    ev[ 98]=QC[2]*ev[25]+WQ[2]*ev[31]+     ze2*ev[ 9];
    ev[ 99]=QC[0]*ev[26]+WQ[0]*ev[32];
    ev[100]=QC[1]*ev[26]+WQ[1]*ev[32]+     ze2*ev[11];
    ev[101]=QC[2]*ev[26]+WQ[2]*ev[32]+     ze2*ev[10];
    ev[102]=QC[0]*ev[27]+WQ[0]*ev[33]+2.e0*ze2*ev[12];
    ev[103]=QC[1]*ev[27]+WQ[1]*ev[33];
    ev[104]=QC[2]*ev[27]+WQ[2]*ev[33];
    ev[105]=QC[0]*ev[28]+WQ[0]*ev[34];
    ev[106]=QC[1]*ev[28]+WQ[1]*ev[34]+2.e0*ze2*ev[13];
    ev[107]=QC[2]*ev[28]+WQ[2]*ev[34];
    ev[108]=QC[0]*ev[29]+WQ[0]*ev[35];
    ev[109]=QC[1]*ev[29]+WQ[1]*ev[35];
    ev[110]=QC[2]*ev[29]+WQ[2]*ev[35]+2.e0*ze2*ev[14];
    ev[111]=QC[0]*ev[30]+WQ[0]*ev[36]+     ze2*ev[13];
    ev[112]=QC[1]*ev[30]+WQ[1]*ev[36]+     ze2*ev[12];
    ev[113]=QC[2]*ev[30]+WQ[2]*ev[36];
    ev[114]=QC[0]*ev[31]+WQ[0]*ev[37]+     ze2*ev[14];
    ev[115]=QC[1]*ev[31]+WQ[1]*ev[37];
    ev[116]=QC[2]*ev[31]+WQ[2]*ev[37]+     ze2*ev[12];
    ev[117]=QC[0]*ev[32]+WQ[0]*ev[38];
    ev[118]=QC[1]*ev[32]+WQ[1]*ev[38]+     ze2*ev[14];
    ev[119]=QC[2]*ev[32]+WQ[2]*ev[38]+     ze2*ev[13];
    // (fs|ps) m=[0,1]
    ev[120]=QC[0]*ev[45]+WQ[0]*ev[55]+3.e0*ze2*ev[27];
    ev[121]=QC[1]*ev[45]+WQ[1]*ev[55];
    ev[122]=QC[2]*ev[45]+WQ[2]*ev[55];
    ev[123]=QC[0]*ev[46]+WQ[0]*ev[56];
    ev[124]=QC[1]*ev[46]+WQ[1]*ev[56]+3.e0*ze2*ev[28];
    ev[125]=QC[2]*ev[46]+WQ[2]*ev[56];
    ev[126]=QC[0]*ev[47]+WQ[0]*ev[57];
    ev[127]=QC[1]*ev[47]+WQ[1]*ev[57];
    ev[128]=QC[2]*ev[47]+WQ[2]*ev[57]+3.e0*ze2*ev[29];
    ev[129]=QC[0]*ev[48]+WQ[0]*ev[58]+2.e0*ze2*ev[30];
    ev[130]=QC[1]*ev[48]+WQ[1]*ev[58]+     ze2*ev[27];
    ev[131]=QC[2]*ev[48]+WQ[2]*ev[58];
    ev[132]=QC[0]*ev[49]+WQ[0]*ev[59]+2.e0*ze2*ev[31];
    ev[133]=QC[1]*ev[49]+WQ[1]*ev[59];
    ev[134]=QC[2]*ev[49]+WQ[2]*ev[59]+     ze2*ev[27];
    ev[135]=QC[0]*ev[50]+WQ[0]*ev[60]+     ze2*ev[28];
    ev[136]=QC[1]*ev[50]+WQ[1]*ev[60]+2.e0*ze2*ev[30];
    ev[137]=QC[2]*ev[50]+WQ[2]*ev[60];
    ev[138]=QC[0]*ev[51]+WQ[0]*ev[61]+     ze2*ev[29];
    ev[139]=QC[1]*ev[51]+WQ[1]*ev[61];
    ev[140]=QC[2]*ev[51]+WQ[2]*ev[61]+2.e0*ze2*ev[31];
    ev[141]=QC[0]*ev[52]+WQ[0]*ev[62]+     ze2*ev[32];
    ev[142]=QC[1]*ev[52]+WQ[1]*ev[62]+     ze2*ev[31];
    ev[143]=QC[2]*ev[52]+WQ[2]*ev[62]+     ze2*ev[30];
    ev[144]=QC[0]*ev[53]+WQ[0]*ev[63];
    ev[145]=QC[1]*ev[53]+WQ[1]*ev[63]+2.e0*ze2*ev[32];
    ev[146]=QC[2]*ev[53]+WQ[2]*ev[63]+     ze2*ev[28];
    ev[147]=QC[0]*ev[54]+WQ[0]*ev[64];
    ev[148]=QC[1]*ev[54]+WQ[1]*ev[64]+     ze2*ev[29];
    ev[149]=QC[2]*ev[54]+WQ[2]*ev[64]+2.e0*ze2*ev[32];
    ev[150]=QC[0]*ev[55]+WQ[0]*ev[65]+3.e0*ze2*ev[33];
    ev[151]=QC[1]*ev[55]+WQ[1]*ev[65];
    ev[152]=QC[2]*ev[55]+WQ[2]*ev[65];
    ev[153]=QC[0]*ev[56]+WQ[0]*ev[66];
    ev[154]=QC[1]*ev[56]+WQ[1]*ev[66]+3.e0*ze2*ev[34];
    ev[155]=QC[2]*ev[56]+WQ[2]*ev[66];
    ev[156]=QC[0]*ev[57]+WQ[0]*ev[67];
    ev[157]=QC[1]*ev[57]+WQ[1]*ev[67];
    ev[158]=QC[2]*ev[57]+WQ[2]*ev[67]+3.e0*ze2*ev[35];
    ev[159]=QC[0]*ev[58]+WQ[0]*ev[68]+2.e0*ze2*ev[36];
    ev[160]=QC[1]*ev[58]+WQ[1]*ev[68]+     ze2*ev[33];
    ev[161]=QC[2]*ev[58]+WQ[2]*ev[68];
    ev[162]=QC[0]*ev[59]+WQ[0]*ev[69]+2.e0*ze2*ev[37];
    ev[163]=QC[1]*ev[59]+WQ[1]*ev[69];
    ev[164]=QC[2]*ev[59]+WQ[2]*ev[69]+     ze2*ev[33];
    ev[165]=QC[0]*ev[60]+WQ[0]*ev[70]+     ze2*ev[34];
    ev[166]=QC[1]*ev[60]+WQ[1]*ev[70]+2.e0*ze2*ev[36];
    ev[167]=QC[2]*ev[60]+WQ[2]*ev[70];
    ev[168]=QC[0]*ev[61]+WQ[0]*ev[71]+     ze2*ev[35];
    ev[169]=QC[1]*ev[61]+WQ[1]*ev[71];
    ev[170]=QC[2]*ev[61]+WQ[2]*ev[71]+2.e0*ze2*ev[37];
    ev[171]=QC[0]*ev[62]+WQ[0]*ev[72]+     ze2*ev[38];
    ev[172]=QC[1]*ev[62]+WQ[1]*ev[72]+     ze2*ev[37];
    ev[173]=QC[2]*ev[62]+WQ[2]*ev[72]+     ze2*ev[36];
    ev[174]=QC[0]*ev[63]+WQ[0]*ev[73];
    ev[175]=QC[1]*ev[63]+WQ[1]*ev[73]+2.e0*ze2*ev[38];
    ev[176]=QC[2]*ev[63]+WQ[2]*ev[73]+     ze2*ev[34];
    ev[177]=QC[0]*ev[64]+WQ[0]*ev[74];
    ev[178]=QC[1]*ev[64]+WQ[1]*ev[74]+     ze2*ev[35];
    ev[179]=QC[2]*ev[64]+WQ[2]*ev[74]+2.e0*ze2*ev[38];
    // (ds|ds) m=[0,0]
    ev[180]=QC[0]*ev[ 84]+WQ[0]*ev[102]+eta2*(ev[21]-re*ev[27])
            +2.e0*ze2*ev[75];
    ev[181]=QC[1]*ev[ 85]+WQ[1]*ev[103]+eta2*(ev[21]-re*ev[27]);
    ev[182]=QC[2]*ev[ 86]+WQ[2]*ev[104]+eta2*(ev[21]-re*ev[27]);
    ev[183]=QC[0]*ev[ 85]+WQ[0]*ev[103]+2.e0*ze2*ev[76];
    ev[184]=QC[0]*ev[ 86]+WQ[0]*ev[104]+2.e0*ze2*ev[77];
    ev[185]=QC[1]*ev[ 86]+WQ[1]*ev[104];
    ev[186]=QC[0]*ev[ 87]+WQ[0]*ev[105]+eta2*(ev[22]-re*ev[28]);
    ev[187]=QC[1]*ev[ 88]+WQ[1]*ev[106]+eta2*(ev[22]-re*ev[28])
            +2.e0*ze2*ev[79];
    ev[188]=QC[2]*ev[ 89]+WQ[2]*ev[107]+eta2*(ev[22]-re*ev[28]);
    ev[189]=QC[0]*ev[ 88]+WQ[0]*ev[106];
    ev[190]=QC[0]*ev[ 89]+WQ[0]*ev[107];
    ev[191]=QC[1]*ev[ 89]+WQ[1]*ev[107]+2.e0*ze2*ev[80];
    ev[192]=QC[0]*ev[ 90]+WQ[0]*ev[108]+eta2*(ev[23]-re*ev[29]);
    ev[193]=QC[1]*ev[ 91]+WQ[1]*ev[109]+eta2*(ev[23]-re*ev[29]);
    ev[194]=QC[2]*ev[ 92]+WQ[2]*ev[110]+eta2*(ev[23]-re*ev[29])
            +2.e0*ze2*ev[83];
    ev[195]=QC[0]*ev[ 91]+WQ[0]*ev[109];
    ev[196]=QC[0]*ev[ 92]+WQ[0]*ev[110];
    ev[197]=QC[1]*ev[ 92]+WQ[1]*ev[110];
    ev[198]=QC[0]*ev[ 93]+WQ[0]*ev[111]+eta2*(ev[24]-re*ev[30])
            +     ze2*ev[78];
    ev[199]=QC[1]*ev[ 94]+WQ[1]*ev[112]+eta2*(ev[24]-re*ev[30])
            +     ze2*ev[76];
    ev[200]=QC[2]*ev[ 95]+WQ[2]*ev[113]+eta2*(ev[24]-re*ev[30]);
    ev[201]=QC[0]*ev[ 94]+WQ[0]*ev[112]+     ze2*ev[79];
    ev[202]=QC[0]*ev[ 95]+WQ[0]*ev[113]+     ze2*ev[80];
    ev[203]=QC[1]*ev[ 95]+WQ[1]*ev[113]+     ze2*ev[77];
    ev[204]=QC[0]*ev[ 96]+WQ[0]*ev[114]+eta2*(ev[25]-re*ev[31])
            +     ze2*ev[81];
    ev[205]=QC[1]*ev[ 97]+WQ[1]*ev[115]+eta2*(ev[25]-re*ev[31]);
    ev[206]=QC[2]*ev[ 98]+WQ[2]*ev[116]+eta2*(ev[25]-re*ev[31])
            +     ze2*ev[77];
    ev[207]=QC[0]*ev[ 97]+WQ[0]*ev[115]+     ze2*ev[82];
    ev[208]=QC[0]*ev[ 98]+WQ[0]*ev[116]+     ze2*ev[83];
    ev[209]=QC[1]*ev[ 98]+WQ[1]*ev[116];
    ev[210]=QC[0]*ev[ 99]+WQ[0]*ev[117]+eta2*(ev[26]-re*ev[32]);
    ev[211]=QC[1]*ev[100]+WQ[1]*ev[118]+eta2*(ev[26]-re*ev[32])
            +     ze2*ev[82];
    ev[212]=QC[2]*ev[101]+WQ[2]*ev[119]+eta2*(ev[26]-re*ev[32])
            +     ze2*ev[80];
    ev[213]=QC[0]*ev[100]+WQ[0]*ev[118];
    ev[214]=QC[0]*ev[101]+WQ[0]*ev[119];
    ev[215]=QC[1]*ev[101]+WQ[1]*ev[119]+     ze2*ev[83];
    // (fs|ds) m=[0,0]
    ev[216]=QC[0]*ev[120]+WQ[0]*ev[150]+eta2*(ev[45]-re*ev[55])
            +3.e0*ze2*ev[102];
    ev[217]=QC[1]*ev[121]+WQ[1]*ev[151]+eta2*(ev[45]-re*ev[55]);
    ev[218]=QC[2]*ev[122]+WQ[2]*ev[152]+eta2*(ev[45]-re*ev[55]);
    ev[219]=QC[0]*ev[121]+WQ[0]*ev[151]+3.e0*ze2*ev[103];
    ev[220]=QC[0]*ev[122]+WQ[0]*ev[152]+3.e0*ze2*ev[104];
    ev[221]=QC[1]*ev[122]+WQ[1]*ev[152];
    ev[222]=QC[0]*ev[123]+WQ[0]*ev[153]+eta2*(ev[46]-re*ev[56]);
    ev[223]=QC[1]*ev[124]+WQ[1]*ev[154]+eta2*(ev[46]-re*ev[56])
            +3.e0*ze2*ev[106];
    ev[224]=QC[2]*ev[125]+WQ[2]*ev[155]+eta2*(ev[46]-re*ev[56]);
    ev[225]=QC[0]*ev[124]+WQ[0]*ev[154];
    ev[226]=QC[0]*ev[125]+WQ[0]*ev[155];
    ev[227]=QC[1]*ev[125]+WQ[1]*ev[155]+3.e0*ze2*ev[107];
    ev[228]=QC[0]*ev[126]+WQ[0]*ev[156]+eta2*(ev[47]-re*ev[57]);
    ev[229]=QC[1]*ev[127]+WQ[1]*ev[157]+eta2*(ev[47]-re*ev[57]);
    ev[230]=QC[2]*ev[128]+WQ[2]*ev[158]+eta2*(ev[47]-re*ev[57])
            +3.e0*ze2*ev[110];
    ev[231]=QC[0]*ev[127]+WQ[0]*ev[157];
    ev[232]=QC[0]*ev[128]+WQ[0]*ev[158];
    ev[233]=QC[1]*ev[128]+WQ[1]*ev[158];
    ev[234]=QC[0]*ev[129]+WQ[0]*ev[159]+eta2*(ev[48]-re*ev[58])
            +2.e0*ze2*ev[111];
    ev[235]=QC[1]*ev[130]+WQ[1]*ev[160]+eta2*(ev[48]-re*ev[58])
            +     ze2*ev[103];
    ev[236]=QC[2]*ev[131]+WQ[2]*ev[161]+eta2*(ev[48]-re*ev[58]);
    ev[237]=QC[0]*ev[130]+WQ[0]*ev[160]+2.e0*ze2*ev[112];
    ev[238]=QC[0]*ev[131]+WQ[0]*ev[161]+2.e0*ze2*ev[113];
    ev[239]=QC[1]*ev[131]+WQ[1]*ev[161]+     ze2*ev[104];
    ev[240]=QC[0]*ev[132]+WQ[0]*ev[162]+eta2*(ev[49]-re*ev[59])
            +2.e0*ze2*ev[114];
    ev[241]=QC[1]*ev[133]+WQ[1]*ev[163]+eta2*(ev[49]-re*ev[59]);
    ev[242]=QC[2]*ev[134]+WQ[2]*ev[164]+eta2*(ev[49]-re*ev[59])
            +     ze2*ev[104];
    ev[243]=QC[0]*ev[133]+WQ[0]*ev[163]+2.e0*ze2*ev[115];
    ev[244]=QC[0]*ev[134]+WQ[0]*ev[164]+2.e0*ze2*ev[116];
    ev[245]=QC[1]*ev[134]+WQ[1]*ev[164];
    ev[246]=QC[0]*ev[135]+WQ[0]*ev[165]+eta2*(ev[50]-re*ev[60])
            +     ze2*ev[105];
    ev[247]=QC[1]*ev[136]+WQ[1]*ev[166]+eta2*(ev[50]-re*ev[60])
            +2.e0*ze2*ev[112];
    ev[248]=QC[2]*ev[137]+WQ[2]*ev[167]+eta2*(ev[50]-re*ev[60]);
    ev[249]=QC[0]*ev[136]+WQ[0]*ev[166]+     ze2*ev[106];
    ev[250]=QC[0]*ev[137]+WQ[0]*ev[167]+     ze2*ev[107];
    ev[251]=QC[1]*ev[137]+WQ[1]*ev[167]+2.e0*ze2*ev[113];
    ev[252]=QC[0]*ev[138]+WQ[0]*ev[168]+eta2*(ev[51]-re*ev[61])
            +     ze2*ev[108];
    ev[253]=QC[1]*ev[139]+WQ[1]*ev[169]+eta2*(ev[51]-re*ev[61]);
    ev[254]=QC[2]*ev[140]+WQ[2]*ev[170]+eta2*(ev[51]-re*ev[61])
            +2.e0*ze2*ev[116];
    ev[255]=QC[0]*ev[139]+WQ[0]*ev[169]+     ze2*ev[109];
    ev[256]=QC[0]*ev[140]+WQ[0]*ev[170]+     ze2*ev[110];
    ev[257]=QC[1]*ev[140]+WQ[1]*ev[170];
    ev[258]=QC[0]*ev[141]+WQ[0]*ev[171]+eta2*(ev[52]-re*ev[62])
            +     ze2*ev[117];
    ev[259]=QC[1]*ev[142]+WQ[1]*ev[172]+eta2*(ev[52]-re*ev[62])
            +     ze2*ev[115];
    ev[260]=QC[2]*ev[143]+WQ[2]*ev[173]+eta2*(ev[52]-re*ev[62])
            +     ze2*ev[113];
    ev[261]=QC[0]*ev[142]+WQ[0]*ev[172]+     ze2*ev[118];
    ev[262]=QC[0]*ev[143]+WQ[0]*ev[173]+     ze2*ev[119];
    ev[263]=QC[1]*ev[143]+WQ[1]*ev[173]+     ze2*ev[116];
    ev[264]=QC[0]*ev[144]+WQ[0]*ev[174]+eta2*(ev[53]-re*ev[63]);
    ev[265]=QC[1]*ev[145]+WQ[1]*ev[175]+eta2*(ev[53]-re*ev[63])
            +2.e0*ze2*ev[118];
    ev[266]=QC[2]*ev[146]+WQ[2]*ev[176]+eta2*(ev[53]-re*ev[63])
            +     ze2*ev[107];
    ev[267]=QC[0]*ev[145]+WQ[0]*ev[175];
    ev[268]=QC[0]*ev[146]+WQ[0]*ev[176];
    ev[269]=QC[1]*ev[146]+WQ[1]*ev[176]+2.e0*ze2*ev[119];
    ev[270]=QC[0]*ev[147]+WQ[0]*ev[177]+eta2*(ev[54]-re*ev[64]);
    ev[271]=QC[1]*ev[148]+WQ[1]*ev[178]+eta2*(ev[54]-re*ev[64])
            +     ze2*ev[109];
    ev[272]=QC[2]*ev[149]+WQ[2]*ev[179]+eta2*(ev[54]-re*ev[64])
            +2.e0*ze2*ev[119];
    ev[273]=QC[0]*ev[148]+WQ[0]*ev[178];
    ev[274]=QC[0]*ev[149]+WQ[0]*ev[179];
    ev[275]=QC[1]*ev[149]+WQ[1]*ev[179]+     ze2*ev[110];
}

__device__ void gpu_vrr_cint_dpds( const double *ev, double *eh ) {
    int La=2, Lb=1, Lc=2, Ld=0;
    int i, ih, iv;
    // (DS|DS)
#pragma unroll
    for ( i=0, iv=180, ih=0; i<36; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|DS)
#pragma unroll
    for ( i=0, iv=216, ih=36; i<60; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dpds(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[276], eh[204];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

//    DFACT = ofmo_getadd_dfact();
    gpu_hrr_clear_dpds( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            re    = rho * eta;
            ze2 = rz * eta2;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_dpds(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_dpds( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_calc_dpds( BA, DC, eh );
    gpu_hrr_coef_dpds( eh, DINT );
}

#if 0
int ofmo_twoint_os_dpds(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*6*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*3*6*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dpds(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=6*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_dpds(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*6*1];
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();
    
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*3*6*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*ofmo_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dpds(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=6*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // if 0
// dpdp
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_dpdp( double *eh ) {
    int i;
    // (DS|DS)
#pragma unroll
    for ( i=0; i<(0+36); i++ ) eh[i] = 0.e0;
    // (DS|FS)
#pragma unroll
    for ( i=36; i<(36+60); i++ ) eh[i] = 0.e0;
    // (FS|DS)
#pragma unroll
    for ( i=96; i<(96+60); i++ ) eh[i] = 0.e0;
    // (FS|FS)
#pragma unroll
    for ( i=156; i<(156+100); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_calc_dpdp(
        const double BA[3], const double DC[3], double *eh ) {
    // (DP,DS)
    eh[ 256] = eh[  96] - BA[0]*eh[   0];
    eh[ 257] = eh[  97] - BA[0]*eh[   1];
    eh[ 258] = eh[  98] - BA[0]*eh[   2];
    eh[ 259] = eh[  99] - BA[0]*eh[   3];
    eh[ 260] = eh[ 100] - BA[0]*eh[   4];
    eh[ 261] = eh[ 101] - BA[0]*eh[   5];
    eh[ 262] = eh[ 114] - BA[1]*eh[   0];
    eh[ 263] = eh[ 115] - BA[1]*eh[   1];
    eh[ 264] = eh[ 116] - BA[1]*eh[   2];
    eh[ 265] = eh[ 117] - BA[1]*eh[   3];
    eh[ 266] = eh[ 118] - BA[1]*eh[   4];
    eh[ 267] = eh[ 119] - BA[1]*eh[   5];
    eh[ 268] = eh[ 120] - BA[2]*eh[   0];
    eh[ 269] = eh[ 121] - BA[2]*eh[   1];
    eh[ 270] = eh[ 122] - BA[2]*eh[   2];
    eh[ 271] = eh[ 123] - BA[2]*eh[   3];
    eh[ 272] = eh[ 124] - BA[2]*eh[   4];
    eh[ 273] = eh[ 125] - BA[2]*eh[   5];
    eh[ 274] = eh[ 126] - BA[0]*eh[   6];
    eh[ 275] = eh[ 127] - BA[0]*eh[   7];
    eh[ 276] = eh[ 128] - BA[0]*eh[   8];
    eh[ 277] = eh[ 129] - BA[0]*eh[   9];
    eh[ 278] = eh[ 130] - BA[0]*eh[  10];
    eh[ 279] = eh[ 131] - BA[0]*eh[  11];
    eh[ 280] = eh[ 102] - BA[1]*eh[   6];
    eh[ 281] = eh[ 103] - BA[1]*eh[   7];
    eh[ 282] = eh[ 104] - BA[1]*eh[   8];
    eh[ 283] = eh[ 105] - BA[1]*eh[   9];
    eh[ 284] = eh[ 106] - BA[1]*eh[  10];
    eh[ 285] = eh[ 107] - BA[1]*eh[  11];
    eh[ 286] = eh[ 144] - BA[2]*eh[   6];
    eh[ 287] = eh[ 145] - BA[2]*eh[   7];
    eh[ 288] = eh[ 146] - BA[2]*eh[   8];
    eh[ 289] = eh[ 147] - BA[2]*eh[   9];
    eh[ 290] = eh[ 148] - BA[2]*eh[  10];
    eh[ 291] = eh[ 149] - BA[2]*eh[  11];
    eh[ 292] = eh[ 132] - BA[0]*eh[  12];
    eh[ 293] = eh[ 133] - BA[0]*eh[  13];
    eh[ 294] = eh[ 134] - BA[0]*eh[  14];
    eh[ 295] = eh[ 135] - BA[0]*eh[  15];
    eh[ 296] = eh[ 136] - BA[0]*eh[  16];
    eh[ 297] = eh[ 137] - BA[0]*eh[  17];
    eh[ 298] = eh[ 150] - BA[1]*eh[  12];
    eh[ 299] = eh[ 151] - BA[1]*eh[  13];
    eh[ 300] = eh[ 152] - BA[1]*eh[  14];
    eh[ 301] = eh[ 153] - BA[1]*eh[  15];
    eh[ 302] = eh[ 154] - BA[1]*eh[  16];
    eh[ 303] = eh[ 155] - BA[1]*eh[  17];
    eh[ 304] = eh[ 108] - BA[2]*eh[  12];
    eh[ 305] = eh[ 109] - BA[2]*eh[  13];
    eh[ 306] = eh[ 110] - BA[2]*eh[  14];
    eh[ 307] = eh[ 111] - BA[2]*eh[  15];
    eh[ 308] = eh[ 112] - BA[2]*eh[  16];
    eh[ 309] = eh[ 113] - BA[2]*eh[  17];
    eh[ 310] = eh[ 114] - BA[0]*eh[  18];
    eh[ 311] = eh[ 115] - BA[0]*eh[  19];
    eh[ 312] = eh[ 116] - BA[0]*eh[  20];
    eh[ 313] = eh[ 117] - BA[0]*eh[  21];
    eh[ 314] = eh[ 118] - BA[0]*eh[  22];
    eh[ 315] = eh[ 119] - BA[0]*eh[  23];
    eh[ 316] = eh[ 126] - BA[1]*eh[  18];
    eh[ 317] = eh[ 127] - BA[1]*eh[  19];
    eh[ 318] = eh[ 128] - BA[1]*eh[  20];
    eh[ 319] = eh[ 129] - BA[1]*eh[  21];
    eh[ 320] = eh[ 130] - BA[1]*eh[  22];
    eh[ 321] = eh[ 131] - BA[1]*eh[  23];
    eh[ 322] = eh[ 138] - BA[2]*eh[  18];
    eh[ 323] = eh[ 139] - BA[2]*eh[  19];
    eh[ 324] = eh[ 140] - BA[2]*eh[  20];
    eh[ 325] = eh[ 141] - BA[2]*eh[  21];
    eh[ 326] = eh[ 142] - BA[2]*eh[  22];
    eh[ 327] = eh[ 143] - BA[2]*eh[  23];
    eh[ 328] = eh[ 120] - BA[0]*eh[  24];
    eh[ 329] = eh[ 121] - BA[0]*eh[  25];
    eh[ 330] = eh[ 122] - BA[0]*eh[  26];
    eh[ 331] = eh[ 123] - BA[0]*eh[  27];
    eh[ 332] = eh[ 124] - BA[0]*eh[  28];
    eh[ 333] = eh[ 125] - BA[0]*eh[  29];
    eh[ 334] = eh[ 138] - BA[1]*eh[  24];
    eh[ 335] = eh[ 139] - BA[1]*eh[  25];
    eh[ 336] = eh[ 140] - BA[1]*eh[  26];
    eh[ 337] = eh[ 141] - BA[1]*eh[  27];
    eh[ 338] = eh[ 142] - BA[1]*eh[  28];
    eh[ 339] = eh[ 143] - BA[1]*eh[  29];
    eh[ 340] = eh[ 132] - BA[2]*eh[  24];
    eh[ 341] = eh[ 133] - BA[2]*eh[  25];
    eh[ 342] = eh[ 134] - BA[2]*eh[  26];
    eh[ 343] = eh[ 135] - BA[2]*eh[  27];
    eh[ 344] = eh[ 136] - BA[2]*eh[  28];
    eh[ 345] = eh[ 137] - BA[2]*eh[  29];
    eh[ 346] = eh[ 138] - BA[0]*eh[  30];
    eh[ 347] = eh[ 139] - BA[0]*eh[  31];
    eh[ 348] = eh[ 140] - BA[0]*eh[  32];
    eh[ 349] = eh[ 141] - BA[0]*eh[  33];
    eh[ 350] = eh[ 142] - BA[0]*eh[  34];
    eh[ 351] = eh[ 143] - BA[0]*eh[  35];
    eh[ 352] = eh[ 144] - BA[1]*eh[  30];
    eh[ 353] = eh[ 145] - BA[1]*eh[  31];
    eh[ 354] = eh[ 146] - BA[1]*eh[  32];
    eh[ 355] = eh[ 147] - BA[1]*eh[  33];
    eh[ 356] = eh[ 148] - BA[1]*eh[  34];
    eh[ 357] = eh[ 149] - BA[1]*eh[  35];
    eh[ 358] = eh[ 150] - BA[2]*eh[  30];
    eh[ 359] = eh[ 151] - BA[2]*eh[  31];
    eh[ 360] = eh[ 152] - BA[2]*eh[  32];
    eh[ 361] = eh[ 153] - BA[2]*eh[  33];
    eh[ 362] = eh[ 154] - BA[2]*eh[  34];
    eh[ 363] = eh[ 155] - BA[2]*eh[  35];
    // (DP,FS)
    eh[ 364] = eh[ 156] - BA[0]*eh[  36];
    eh[ 365] = eh[ 157] - BA[0]*eh[  37];
    eh[ 366] = eh[ 158] - BA[0]*eh[  38];
    eh[ 367] = eh[ 159] - BA[0]*eh[  39];
    eh[ 368] = eh[ 160] - BA[0]*eh[  40];
    eh[ 369] = eh[ 161] - BA[0]*eh[  41];
    eh[ 370] = eh[ 162] - BA[0]*eh[  42];
    eh[ 371] = eh[ 163] - BA[0]*eh[  43];
    eh[ 372] = eh[ 164] - BA[0]*eh[  44];
    eh[ 373] = eh[ 165] - BA[0]*eh[  45];
    eh[ 374] = eh[ 186] - BA[1]*eh[  36];
    eh[ 375] = eh[ 187] - BA[1]*eh[  37];
    eh[ 376] = eh[ 188] - BA[1]*eh[  38];
    eh[ 377] = eh[ 189] - BA[1]*eh[  39];
    eh[ 378] = eh[ 190] - BA[1]*eh[  40];
    eh[ 379] = eh[ 191] - BA[1]*eh[  41];
    eh[ 380] = eh[ 192] - BA[1]*eh[  42];
    eh[ 381] = eh[ 193] - BA[1]*eh[  43];
    eh[ 382] = eh[ 194] - BA[1]*eh[  44];
    eh[ 383] = eh[ 195] - BA[1]*eh[  45];
    eh[ 384] = eh[ 196] - BA[2]*eh[  36];
    eh[ 385] = eh[ 197] - BA[2]*eh[  37];
    eh[ 386] = eh[ 198] - BA[2]*eh[  38];
    eh[ 387] = eh[ 199] - BA[2]*eh[  39];
    eh[ 388] = eh[ 200] - BA[2]*eh[  40];
    eh[ 389] = eh[ 201] - BA[2]*eh[  41];
    eh[ 390] = eh[ 202] - BA[2]*eh[  42];
    eh[ 391] = eh[ 203] - BA[2]*eh[  43];
    eh[ 392] = eh[ 204] - BA[2]*eh[  44];
    eh[ 393] = eh[ 205] - BA[2]*eh[  45];
    eh[ 394] = eh[ 206] - BA[0]*eh[  46];
    eh[ 395] = eh[ 207] - BA[0]*eh[  47];
    eh[ 396] = eh[ 208] - BA[0]*eh[  48];
    eh[ 397] = eh[ 209] - BA[0]*eh[  49];
    eh[ 398] = eh[ 210] - BA[0]*eh[  50];
    eh[ 399] = eh[ 211] - BA[0]*eh[  51];
    eh[ 400] = eh[ 212] - BA[0]*eh[  52];
    eh[ 401] = eh[ 213] - BA[0]*eh[  53];
    eh[ 402] = eh[ 214] - BA[0]*eh[  54];
    eh[ 403] = eh[ 215] - BA[0]*eh[  55];
    eh[ 404] = eh[ 166] - BA[1]*eh[  46];
    eh[ 405] = eh[ 167] - BA[1]*eh[  47];
    eh[ 406] = eh[ 168] - BA[1]*eh[  48];
    eh[ 407] = eh[ 169] - BA[1]*eh[  49];
    eh[ 408] = eh[ 170] - BA[1]*eh[  50];
    eh[ 409] = eh[ 171] - BA[1]*eh[  51];
    eh[ 410] = eh[ 172] - BA[1]*eh[  52];
    eh[ 411] = eh[ 173] - BA[1]*eh[  53];
    eh[ 412] = eh[ 174] - BA[1]*eh[  54];
    eh[ 413] = eh[ 175] - BA[1]*eh[  55];
    eh[ 414] = eh[ 236] - BA[2]*eh[  46];
    eh[ 415] = eh[ 237] - BA[2]*eh[  47];
    eh[ 416] = eh[ 238] - BA[2]*eh[  48];
    eh[ 417] = eh[ 239] - BA[2]*eh[  49];
    eh[ 418] = eh[ 240] - BA[2]*eh[  50];
    eh[ 419] = eh[ 241] - BA[2]*eh[  51];
    eh[ 420] = eh[ 242] - BA[2]*eh[  52];
    eh[ 421] = eh[ 243] - BA[2]*eh[  53];
    eh[ 422] = eh[ 244] - BA[2]*eh[  54];
    eh[ 423] = eh[ 245] - BA[2]*eh[  55];
    eh[ 424] = eh[ 216] - BA[0]*eh[  56];
    eh[ 425] = eh[ 217] - BA[0]*eh[  57];
    eh[ 426] = eh[ 218] - BA[0]*eh[  58];
    eh[ 427] = eh[ 219] - BA[0]*eh[  59];
    eh[ 428] = eh[ 220] - BA[0]*eh[  60];
    eh[ 429] = eh[ 221] - BA[0]*eh[  61];
    eh[ 430] = eh[ 222] - BA[0]*eh[  62];
    eh[ 431] = eh[ 223] - BA[0]*eh[  63];
    eh[ 432] = eh[ 224] - BA[0]*eh[  64];
    eh[ 433] = eh[ 225] - BA[0]*eh[  65];
    eh[ 434] = eh[ 246] - BA[1]*eh[  56];
    eh[ 435] = eh[ 247] - BA[1]*eh[  57];
    eh[ 436] = eh[ 248] - BA[1]*eh[  58];
    eh[ 437] = eh[ 249] - BA[1]*eh[  59];
    eh[ 438] = eh[ 250] - BA[1]*eh[  60];
    eh[ 439] = eh[ 251] - BA[1]*eh[  61];
    eh[ 440] = eh[ 252] - BA[1]*eh[  62];
    eh[ 441] = eh[ 253] - BA[1]*eh[  63];
    eh[ 442] = eh[ 254] - BA[1]*eh[  64];
    eh[ 443] = eh[ 255] - BA[1]*eh[  65];
    eh[ 444] = eh[ 176] - BA[2]*eh[  56];
    eh[ 445] = eh[ 177] - BA[2]*eh[  57];
    eh[ 446] = eh[ 178] - BA[2]*eh[  58];
    eh[ 447] = eh[ 179] - BA[2]*eh[  59];
    eh[ 448] = eh[ 180] - BA[2]*eh[  60];
    eh[ 449] = eh[ 181] - BA[2]*eh[  61];
    eh[ 450] = eh[ 182] - BA[2]*eh[  62];
    eh[ 451] = eh[ 183] - BA[2]*eh[  63];
    eh[ 452] = eh[ 184] - BA[2]*eh[  64];
    eh[ 453] = eh[ 185] - BA[2]*eh[  65];
    eh[ 454] = eh[ 186] - BA[0]*eh[  66];
    eh[ 455] = eh[ 187] - BA[0]*eh[  67];
    eh[ 456] = eh[ 188] - BA[0]*eh[  68];
    eh[ 457] = eh[ 189] - BA[0]*eh[  69];
    eh[ 458] = eh[ 190] - BA[0]*eh[  70];
    eh[ 459] = eh[ 191] - BA[0]*eh[  71];
    eh[ 460] = eh[ 192] - BA[0]*eh[  72];
    eh[ 461] = eh[ 193] - BA[0]*eh[  73];
    eh[ 462] = eh[ 194] - BA[0]*eh[  74];
    eh[ 463] = eh[ 195] - BA[0]*eh[  75];
    eh[ 464] = eh[ 206] - BA[1]*eh[  66];
    eh[ 465] = eh[ 207] - BA[1]*eh[  67];
    eh[ 466] = eh[ 208] - BA[1]*eh[  68];
    eh[ 467] = eh[ 209] - BA[1]*eh[  69];
    eh[ 468] = eh[ 210] - BA[1]*eh[  70];
    eh[ 469] = eh[ 211] - BA[1]*eh[  71];
    eh[ 470] = eh[ 212] - BA[1]*eh[  72];
    eh[ 471] = eh[ 213] - BA[1]*eh[  73];
    eh[ 472] = eh[ 214] - BA[1]*eh[  74];
    eh[ 473] = eh[ 215] - BA[1]*eh[  75];
    eh[ 474] = eh[ 226] - BA[2]*eh[  66];
    eh[ 475] = eh[ 227] - BA[2]*eh[  67];
    eh[ 476] = eh[ 228] - BA[2]*eh[  68];
    eh[ 477] = eh[ 229] - BA[2]*eh[  69];
    eh[ 478] = eh[ 230] - BA[2]*eh[  70];
    eh[ 479] = eh[ 231] - BA[2]*eh[  71];
    eh[ 480] = eh[ 232] - BA[2]*eh[  72];
    eh[ 481] = eh[ 233] - BA[2]*eh[  73];
    eh[ 482] = eh[ 234] - BA[2]*eh[  74];
    eh[ 483] = eh[ 235] - BA[2]*eh[  75];
    eh[ 484] = eh[ 196] - BA[0]*eh[  76];
    eh[ 485] = eh[ 197] - BA[0]*eh[  77];
    eh[ 486] = eh[ 198] - BA[0]*eh[  78];
    eh[ 487] = eh[ 199] - BA[0]*eh[  79];
    eh[ 488] = eh[ 200] - BA[0]*eh[  80];
    eh[ 489] = eh[ 201] - BA[0]*eh[  81];
    eh[ 490] = eh[ 202] - BA[0]*eh[  82];
    eh[ 491] = eh[ 203] - BA[0]*eh[  83];
    eh[ 492] = eh[ 204] - BA[0]*eh[  84];
    eh[ 493] = eh[ 205] - BA[0]*eh[  85];
    eh[ 494] = eh[ 226] - BA[1]*eh[  76];
    eh[ 495] = eh[ 227] - BA[1]*eh[  77];
    eh[ 496] = eh[ 228] - BA[1]*eh[  78];
    eh[ 497] = eh[ 229] - BA[1]*eh[  79];
    eh[ 498] = eh[ 230] - BA[1]*eh[  80];
    eh[ 499] = eh[ 231] - BA[1]*eh[  81];
    eh[ 500] = eh[ 232] - BA[1]*eh[  82];
    eh[ 501] = eh[ 233] - BA[1]*eh[  83];
    eh[ 502] = eh[ 234] - BA[1]*eh[  84];
    eh[ 503] = eh[ 235] - BA[1]*eh[  85];
    eh[ 504] = eh[ 216] - BA[2]*eh[  76];
    eh[ 505] = eh[ 217] - BA[2]*eh[  77];
    eh[ 506] = eh[ 218] - BA[2]*eh[  78];
    eh[ 507] = eh[ 219] - BA[2]*eh[  79];
    eh[ 508] = eh[ 220] - BA[2]*eh[  80];
    eh[ 509] = eh[ 221] - BA[2]*eh[  81];
    eh[ 510] = eh[ 222] - BA[2]*eh[  82];
    eh[ 511] = eh[ 223] - BA[2]*eh[  83];
    eh[ 512] = eh[ 224] - BA[2]*eh[  84];
    eh[ 513] = eh[ 225] - BA[2]*eh[  85];
    eh[ 514] = eh[ 226] - BA[0]*eh[  86];
    eh[ 515] = eh[ 227] - BA[0]*eh[  87];
    eh[ 516] = eh[ 228] - BA[0]*eh[  88];
    eh[ 517] = eh[ 229] - BA[0]*eh[  89];
    eh[ 518] = eh[ 230] - BA[0]*eh[  90];
    eh[ 519] = eh[ 231] - BA[0]*eh[  91];
    eh[ 520] = eh[ 232] - BA[0]*eh[  92];
    eh[ 521] = eh[ 233] - BA[0]*eh[  93];
    eh[ 522] = eh[ 234] - BA[0]*eh[  94];
    eh[ 523] = eh[ 235] - BA[0]*eh[  95];
    eh[ 524] = eh[ 236] - BA[1]*eh[  86];
    eh[ 525] = eh[ 237] - BA[1]*eh[  87];
    eh[ 526] = eh[ 238] - BA[1]*eh[  88];
    eh[ 527] = eh[ 239] - BA[1]*eh[  89];
    eh[ 528] = eh[ 240] - BA[1]*eh[  90];
    eh[ 529] = eh[ 241] - BA[1]*eh[  91];
    eh[ 530] = eh[ 242] - BA[1]*eh[  92];
    eh[ 531] = eh[ 243] - BA[1]*eh[  93];
    eh[ 532] = eh[ 244] - BA[1]*eh[  94];
    eh[ 533] = eh[ 245] - BA[1]*eh[  95];
    eh[ 534] = eh[ 246] - BA[2]*eh[  86];
    eh[ 535] = eh[ 247] - BA[2]*eh[  87];
    eh[ 536] = eh[ 248] - BA[2]*eh[  88];
    eh[ 537] = eh[ 249] - BA[2]*eh[  89];
    eh[ 538] = eh[ 250] - BA[2]*eh[  90];
    eh[ 539] = eh[ 251] - BA[2]*eh[  91];
    eh[ 540] = eh[ 252] - BA[2]*eh[  92];
    eh[ 541] = eh[ 253] - BA[2]*eh[  93];
    eh[ 542] = eh[ 254] - BA[2]*eh[  94];
    eh[ 543] = eh[ 255] - BA[2]*eh[  95];
    // HRR for (XX|XX)-type integral (center CD)
    // (DP,DP)
    eh[ 544] = eh[ 364] - DC[0]*eh[ 256];
    eh[ 545] = eh[ 367] - DC[1]*eh[ 256];
    eh[ 546] = eh[ 368] - DC[2]*eh[ 256];
    eh[ 547] = eh[ 369] - DC[0]*eh[ 257];
    eh[ 548] = eh[ 365] - DC[1]*eh[ 257];
    eh[ 549] = eh[ 372] - DC[2]*eh[ 257];
    eh[ 550] = eh[ 370] - DC[0]*eh[ 258];
    eh[ 551] = eh[ 373] - DC[1]*eh[ 258];
    eh[ 552] = eh[ 366] - DC[2]*eh[ 258];
    eh[ 553] = eh[ 367] - DC[0]*eh[ 259];
    eh[ 554] = eh[ 369] - DC[1]*eh[ 259];
    eh[ 555] = eh[ 371] - DC[2]*eh[ 259];
    eh[ 556] = eh[ 368] - DC[0]*eh[ 260];
    eh[ 557] = eh[ 371] - DC[1]*eh[ 260];
    eh[ 558] = eh[ 370] - DC[2]*eh[ 260];
    eh[ 559] = eh[ 371] - DC[0]*eh[ 261];
    eh[ 560] = eh[ 372] - DC[1]*eh[ 261];
    eh[ 561] = eh[ 373] - DC[2]*eh[ 261];
    eh[ 562] = eh[ 374] - DC[0]*eh[ 262];
    eh[ 563] = eh[ 377] - DC[1]*eh[ 262];
    eh[ 564] = eh[ 378] - DC[2]*eh[ 262];
    eh[ 565] = eh[ 379] - DC[0]*eh[ 263];
    eh[ 566] = eh[ 375] - DC[1]*eh[ 263];
    eh[ 567] = eh[ 382] - DC[2]*eh[ 263];
    eh[ 568] = eh[ 380] - DC[0]*eh[ 264];
    eh[ 569] = eh[ 383] - DC[1]*eh[ 264];
    eh[ 570] = eh[ 376] - DC[2]*eh[ 264];
    eh[ 571] = eh[ 377] - DC[0]*eh[ 265];
    eh[ 572] = eh[ 379] - DC[1]*eh[ 265];
    eh[ 573] = eh[ 381] - DC[2]*eh[ 265];
    eh[ 574] = eh[ 378] - DC[0]*eh[ 266];
    eh[ 575] = eh[ 381] - DC[1]*eh[ 266];
    eh[ 576] = eh[ 380] - DC[2]*eh[ 266];
    eh[ 577] = eh[ 381] - DC[0]*eh[ 267];
    eh[ 578] = eh[ 382] - DC[1]*eh[ 267];
    eh[ 579] = eh[ 383] - DC[2]*eh[ 267];
    eh[ 580] = eh[ 384] - DC[0]*eh[ 268];
    eh[ 581] = eh[ 387] - DC[1]*eh[ 268];
    eh[ 582] = eh[ 388] - DC[2]*eh[ 268];
    eh[ 583] = eh[ 389] - DC[0]*eh[ 269];
    eh[ 584] = eh[ 385] - DC[1]*eh[ 269];
    eh[ 585] = eh[ 392] - DC[2]*eh[ 269];
    eh[ 586] = eh[ 390] - DC[0]*eh[ 270];
    eh[ 587] = eh[ 393] - DC[1]*eh[ 270];
    eh[ 588] = eh[ 386] - DC[2]*eh[ 270];
    eh[ 589] = eh[ 387] - DC[0]*eh[ 271];
    eh[ 590] = eh[ 389] - DC[1]*eh[ 271];
    eh[ 591] = eh[ 391] - DC[2]*eh[ 271];
    eh[ 592] = eh[ 388] - DC[0]*eh[ 272];
    eh[ 593] = eh[ 391] - DC[1]*eh[ 272];
    eh[ 594] = eh[ 390] - DC[2]*eh[ 272];
    eh[ 595] = eh[ 391] - DC[0]*eh[ 273];
    eh[ 596] = eh[ 392] - DC[1]*eh[ 273];
    eh[ 597] = eh[ 393] - DC[2]*eh[ 273];
    eh[ 598] = eh[ 394] - DC[0]*eh[ 274];
    eh[ 599] = eh[ 397] - DC[1]*eh[ 274];
    eh[ 600] = eh[ 398] - DC[2]*eh[ 274];
    eh[ 601] = eh[ 399] - DC[0]*eh[ 275];
    eh[ 602] = eh[ 395] - DC[1]*eh[ 275];
    eh[ 603] = eh[ 402] - DC[2]*eh[ 275];
    eh[ 604] = eh[ 400] - DC[0]*eh[ 276];
    eh[ 605] = eh[ 403] - DC[1]*eh[ 276];
    eh[ 606] = eh[ 396] - DC[2]*eh[ 276];
    eh[ 607] = eh[ 397] - DC[0]*eh[ 277];
    eh[ 608] = eh[ 399] - DC[1]*eh[ 277];
    eh[ 609] = eh[ 401] - DC[2]*eh[ 277];
    eh[ 610] = eh[ 398] - DC[0]*eh[ 278];
    eh[ 611] = eh[ 401] - DC[1]*eh[ 278];
    eh[ 612] = eh[ 400] - DC[2]*eh[ 278];
    eh[ 613] = eh[ 401] - DC[0]*eh[ 279];
    eh[ 614] = eh[ 402] - DC[1]*eh[ 279];
    eh[ 615] = eh[ 403] - DC[2]*eh[ 279];
    eh[ 616] = eh[ 404] - DC[0]*eh[ 280];
    eh[ 617] = eh[ 407] - DC[1]*eh[ 280];
    eh[ 618] = eh[ 408] - DC[2]*eh[ 280];
    eh[ 619] = eh[ 409] - DC[0]*eh[ 281];
    eh[ 620] = eh[ 405] - DC[1]*eh[ 281];
    eh[ 621] = eh[ 412] - DC[2]*eh[ 281];
    eh[ 622] = eh[ 410] - DC[0]*eh[ 282];
    eh[ 623] = eh[ 413] - DC[1]*eh[ 282];
    eh[ 624] = eh[ 406] - DC[2]*eh[ 282];
    eh[ 625] = eh[ 407] - DC[0]*eh[ 283];
    eh[ 626] = eh[ 409] - DC[1]*eh[ 283];
    eh[ 627] = eh[ 411] - DC[2]*eh[ 283];
    eh[ 628] = eh[ 408] - DC[0]*eh[ 284];
    eh[ 629] = eh[ 411] - DC[1]*eh[ 284];
    eh[ 630] = eh[ 410] - DC[2]*eh[ 284];
    eh[ 631] = eh[ 411] - DC[0]*eh[ 285];
    eh[ 632] = eh[ 412] - DC[1]*eh[ 285];
    eh[ 633] = eh[ 413] - DC[2]*eh[ 285];
    eh[ 634] = eh[ 414] - DC[0]*eh[ 286];
    eh[ 635] = eh[ 417] - DC[1]*eh[ 286];
    eh[ 636] = eh[ 418] - DC[2]*eh[ 286];
    eh[ 637] = eh[ 419] - DC[0]*eh[ 287];
    eh[ 638] = eh[ 415] - DC[1]*eh[ 287];
    eh[ 639] = eh[ 422] - DC[2]*eh[ 287];
    eh[ 640] = eh[ 420] - DC[0]*eh[ 288];
    eh[ 641] = eh[ 423] - DC[1]*eh[ 288];
    eh[ 642] = eh[ 416] - DC[2]*eh[ 288];
    eh[ 643] = eh[ 417] - DC[0]*eh[ 289];
    eh[ 644] = eh[ 419] - DC[1]*eh[ 289];
    eh[ 645] = eh[ 421] - DC[2]*eh[ 289];
    eh[ 646] = eh[ 418] - DC[0]*eh[ 290];
    eh[ 647] = eh[ 421] - DC[1]*eh[ 290];
    eh[ 648] = eh[ 420] - DC[2]*eh[ 290];
    eh[ 649] = eh[ 421] - DC[0]*eh[ 291];
    eh[ 650] = eh[ 422] - DC[1]*eh[ 291];
    eh[ 651] = eh[ 423] - DC[2]*eh[ 291];
    eh[ 652] = eh[ 424] - DC[0]*eh[ 292];
    eh[ 653] = eh[ 427] - DC[1]*eh[ 292];
    eh[ 654] = eh[ 428] - DC[2]*eh[ 292];
    eh[ 655] = eh[ 429] - DC[0]*eh[ 293];
    eh[ 656] = eh[ 425] - DC[1]*eh[ 293];
    eh[ 657] = eh[ 432] - DC[2]*eh[ 293];
    eh[ 658] = eh[ 430] - DC[0]*eh[ 294];
    eh[ 659] = eh[ 433] - DC[1]*eh[ 294];
    eh[ 660] = eh[ 426] - DC[2]*eh[ 294];
    eh[ 661] = eh[ 427] - DC[0]*eh[ 295];
    eh[ 662] = eh[ 429] - DC[1]*eh[ 295];
    eh[ 663] = eh[ 431] - DC[2]*eh[ 295];
    eh[ 664] = eh[ 428] - DC[0]*eh[ 296];
    eh[ 665] = eh[ 431] - DC[1]*eh[ 296];
    eh[ 666] = eh[ 430] - DC[2]*eh[ 296];
    eh[ 667] = eh[ 431] - DC[0]*eh[ 297];
    eh[ 668] = eh[ 432] - DC[1]*eh[ 297];
    eh[ 669] = eh[ 433] - DC[2]*eh[ 297];
    eh[ 670] = eh[ 434] - DC[0]*eh[ 298];
    eh[ 671] = eh[ 437] - DC[1]*eh[ 298];
    eh[ 672] = eh[ 438] - DC[2]*eh[ 298];
    eh[ 673] = eh[ 439] - DC[0]*eh[ 299];
    eh[ 674] = eh[ 435] - DC[1]*eh[ 299];
    eh[ 675] = eh[ 442] - DC[2]*eh[ 299];
    eh[ 676] = eh[ 440] - DC[0]*eh[ 300];
    eh[ 677] = eh[ 443] - DC[1]*eh[ 300];
    eh[ 678] = eh[ 436] - DC[2]*eh[ 300];
    eh[ 679] = eh[ 437] - DC[0]*eh[ 301];
    eh[ 680] = eh[ 439] - DC[1]*eh[ 301];
    eh[ 681] = eh[ 441] - DC[2]*eh[ 301];
    eh[ 682] = eh[ 438] - DC[0]*eh[ 302];
    eh[ 683] = eh[ 441] - DC[1]*eh[ 302];
    eh[ 684] = eh[ 440] - DC[2]*eh[ 302];
    eh[ 685] = eh[ 441] - DC[0]*eh[ 303];
    eh[ 686] = eh[ 442] - DC[1]*eh[ 303];
    eh[ 687] = eh[ 443] - DC[2]*eh[ 303];
    eh[ 688] = eh[ 444] - DC[0]*eh[ 304];
    eh[ 689] = eh[ 447] - DC[1]*eh[ 304];
    eh[ 690] = eh[ 448] - DC[2]*eh[ 304];
    eh[ 691] = eh[ 449] - DC[0]*eh[ 305];
    eh[ 692] = eh[ 445] - DC[1]*eh[ 305];
    eh[ 693] = eh[ 452] - DC[2]*eh[ 305];
    eh[ 694] = eh[ 450] - DC[0]*eh[ 306];
    eh[ 695] = eh[ 453] - DC[1]*eh[ 306];
    eh[ 696] = eh[ 446] - DC[2]*eh[ 306];
    eh[ 697] = eh[ 447] - DC[0]*eh[ 307];
    eh[ 698] = eh[ 449] - DC[1]*eh[ 307];
    eh[ 699] = eh[ 451] - DC[2]*eh[ 307];
    eh[ 700] = eh[ 448] - DC[0]*eh[ 308];
    eh[ 701] = eh[ 451] - DC[1]*eh[ 308];
    eh[ 702] = eh[ 450] - DC[2]*eh[ 308];
    eh[ 703] = eh[ 451] - DC[0]*eh[ 309];
    eh[ 704] = eh[ 452] - DC[1]*eh[ 309];
    eh[ 705] = eh[ 453] - DC[2]*eh[ 309];
    eh[ 706] = eh[ 454] - DC[0]*eh[ 310];
    eh[ 707] = eh[ 457] - DC[1]*eh[ 310];
    eh[ 708] = eh[ 458] - DC[2]*eh[ 310];
    eh[ 709] = eh[ 459] - DC[0]*eh[ 311];
    eh[ 710] = eh[ 455] - DC[1]*eh[ 311];
    eh[ 711] = eh[ 462] - DC[2]*eh[ 311];
    eh[ 712] = eh[ 460] - DC[0]*eh[ 312];
    eh[ 713] = eh[ 463] - DC[1]*eh[ 312];
    eh[ 714] = eh[ 456] - DC[2]*eh[ 312];
    eh[ 715] = eh[ 457] - DC[0]*eh[ 313];
    eh[ 716] = eh[ 459] - DC[1]*eh[ 313];
    eh[ 717] = eh[ 461] - DC[2]*eh[ 313];
    eh[ 718] = eh[ 458] - DC[0]*eh[ 314];
    eh[ 719] = eh[ 461] - DC[1]*eh[ 314];
    eh[ 720] = eh[ 460] - DC[2]*eh[ 314];
    eh[ 721] = eh[ 461] - DC[0]*eh[ 315];
    eh[ 722] = eh[ 462] - DC[1]*eh[ 315];
    eh[ 723] = eh[ 463] - DC[2]*eh[ 315];
    eh[ 724] = eh[ 464] - DC[0]*eh[ 316];
    eh[ 725] = eh[ 467] - DC[1]*eh[ 316];
    eh[ 726] = eh[ 468] - DC[2]*eh[ 316];
    eh[ 727] = eh[ 469] - DC[0]*eh[ 317];
    eh[ 728] = eh[ 465] - DC[1]*eh[ 317];
    eh[ 729] = eh[ 472] - DC[2]*eh[ 317];
    eh[ 730] = eh[ 470] - DC[0]*eh[ 318];
    eh[ 731] = eh[ 473] - DC[1]*eh[ 318];
    eh[ 732] = eh[ 466] - DC[2]*eh[ 318];
    eh[ 733] = eh[ 467] - DC[0]*eh[ 319];
    eh[ 734] = eh[ 469] - DC[1]*eh[ 319];
    eh[ 735] = eh[ 471] - DC[2]*eh[ 319];
    eh[ 736] = eh[ 468] - DC[0]*eh[ 320];
    eh[ 737] = eh[ 471] - DC[1]*eh[ 320];
    eh[ 738] = eh[ 470] - DC[2]*eh[ 320];
    eh[ 739] = eh[ 471] - DC[0]*eh[ 321];
    eh[ 740] = eh[ 472] - DC[1]*eh[ 321];
    eh[ 741] = eh[ 473] - DC[2]*eh[ 321];
    eh[ 742] = eh[ 474] - DC[0]*eh[ 322];
    eh[ 743] = eh[ 477] - DC[1]*eh[ 322];
    eh[ 744] = eh[ 478] - DC[2]*eh[ 322];
    eh[ 745] = eh[ 479] - DC[0]*eh[ 323];
    eh[ 746] = eh[ 475] - DC[1]*eh[ 323];
    eh[ 747] = eh[ 482] - DC[2]*eh[ 323];
    eh[ 748] = eh[ 480] - DC[0]*eh[ 324];
    eh[ 749] = eh[ 483] - DC[1]*eh[ 324];
    eh[ 750] = eh[ 476] - DC[2]*eh[ 324];
    eh[ 751] = eh[ 477] - DC[0]*eh[ 325];
    eh[ 752] = eh[ 479] - DC[1]*eh[ 325];
    eh[ 753] = eh[ 481] - DC[2]*eh[ 325];
    eh[ 754] = eh[ 478] - DC[0]*eh[ 326];
    eh[ 755] = eh[ 481] - DC[1]*eh[ 326];
    eh[ 756] = eh[ 480] - DC[2]*eh[ 326];
    eh[ 757] = eh[ 481] - DC[0]*eh[ 327];
    eh[ 758] = eh[ 482] - DC[1]*eh[ 327];
    eh[ 759] = eh[ 483] - DC[2]*eh[ 327];
    eh[ 760] = eh[ 484] - DC[0]*eh[ 328];
    eh[ 761] = eh[ 487] - DC[1]*eh[ 328];
    eh[ 762] = eh[ 488] - DC[2]*eh[ 328];
    eh[ 763] = eh[ 489] - DC[0]*eh[ 329];
    eh[ 764] = eh[ 485] - DC[1]*eh[ 329];
    eh[ 765] = eh[ 492] - DC[2]*eh[ 329];
    eh[ 766] = eh[ 490] - DC[0]*eh[ 330];
    eh[ 767] = eh[ 493] - DC[1]*eh[ 330];
    eh[ 768] = eh[ 486] - DC[2]*eh[ 330];
    eh[ 769] = eh[ 487] - DC[0]*eh[ 331];
    eh[ 770] = eh[ 489] - DC[1]*eh[ 331];
    eh[ 771] = eh[ 491] - DC[2]*eh[ 331];
    eh[ 772] = eh[ 488] - DC[0]*eh[ 332];
    eh[ 773] = eh[ 491] - DC[1]*eh[ 332];
    eh[ 774] = eh[ 490] - DC[2]*eh[ 332];
    eh[ 775] = eh[ 491] - DC[0]*eh[ 333];
    eh[ 776] = eh[ 492] - DC[1]*eh[ 333];
    eh[ 777] = eh[ 493] - DC[2]*eh[ 333];
    eh[ 778] = eh[ 494] - DC[0]*eh[ 334];
    eh[ 779] = eh[ 497] - DC[1]*eh[ 334];
    eh[ 780] = eh[ 498] - DC[2]*eh[ 334];
    eh[ 781] = eh[ 499] - DC[0]*eh[ 335];
    eh[ 782] = eh[ 495] - DC[1]*eh[ 335];
    eh[ 783] = eh[ 502] - DC[2]*eh[ 335];
    eh[ 784] = eh[ 500] - DC[0]*eh[ 336];
    eh[ 785] = eh[ 503] - DC[1]*eh[ 336];
    eh[ 786] = eh[ 496] - DC[2]*eh[ 336];
    eh[ 787] = eh[ 497] - DC[0]*eh[ 337];
    eh[ 788] = eh[ 499] - DC[1]*eh[ 337];
    eh[ 789] = eh[ 501] - DC[2]*eh[ 337];
    eh[ 790] = eh[ 498] - DC[0]*eh[ 338];
    eh[ 791] = eh[ 501] - DC[1]*eh[ 338];
    eh[ 792] = eh[ 500] - DC[2]*eh[ 338];
    eh[ 793] = eh[ 501] - DC[0]*eh[ 339];
    eh[ 794] = eh[ 502] - DC[1]*eh[ 339];
    eh[ 795] = eh[ 503] - DC[2]*eh[ 339];
    eh[ 796] = eh[ 504] - DC[0]*eh[ 340];
    eh[ 797] = eh[ 507] - DC[1]*eh[ 340];
    eh[ 798] = eh[ 508] - DC[2]*eh[ 340];
    eh[ 799] = eh[ 509] - DC[0]*eh[ 341];
    eh[ 800] = eh[ 505] - DC[1]*eh[ 341];
    eh[ 801] = eh[ 512] - DC[2]*eh[ 341];
    eh[ 802] = eh[ 510] - DC[0]*eh[ 342];
    eh[ 803] = eh[ 513] - DC[1]*eh[ 342];
    eh[ 804] = eh[ 506] - DC[2]*eh[ 342];
    eh[ 805] = eh[ 507] - DC[0]*eh[ 343];
    eh[ 806] = eh[ 509] - DC[1]*eh[ 343];
    eh[ 807] = eh[ 511] - DC[2]*eh[ 343];
    eh[ 808] = eh[ 508] - DC[0]*eh[ 344];
    eh[ 809] = eh[ 511] - DC[1]*eh[ 344];
    eh[ 810] = eh[ 510] - DC[2]*eh[ 344];
    eh[ 811] = eh[ 511] - DC[0]*eh[ 345];
    eh[ 812] = eh[ 512] - DC[1]*eh[ 345];
    eh[ 813] = eh[ 513] - DC[2]*eh[ 345];
    eh[ 814] = eh[ 514] - DC[0]*eh[ 346];
    eh[ 815] = eh[ 517] - DC[1]*eh[ 346];
    eh[ 816] = eh[ 518] - DC[2]*eh[ 346];
    eh[ 817] = eh[ 519] - DC[0]*eh[ 347];
    eh[ 818] = eh[ 515] - DC[1]*eh[ 347];
    eh[ 819] = eh[ 522] - DC[2]*eh[ 347];
    eh[ 820] = eh[ 520] - DC[0]*eh[ 348];
    eh[ 821] = eh[ 523] - DC[1]*eh[ 348];
    eh[ 822] = eh[ 516] - DC[2]*eh[ 348];
    eh[ 823] = eh[ 517] - DC[0]*eh[ 349];
    eh[ 824] = eh[ 519] - DC[1]*eh[ 349];
    eh[ 825] = eh[ 521] - DC[2]*eh[ 349];
    eh[ 826] = eh[ 518] - DC[0]*eh[ 350];
    eh[ 827] = eh[ 521] - DC[1]*eh[ 350];
    eh[ 828] = eh[ 520] - DC[2]*eh[ 350];
    eh[ 829] = eh[ 521] - DC[0]*eh[ 351];
    eh[ 830] = eh[ 522] - DC[1]*eh[ 351];
    eh[ 831] = eh[ 523] - DC[2]*eh[ 351];
    eh[ 832] = eh[ 524] - DC[0]*eh[ 352];
    eh[ 833] = eh[ 527] - DC[1]*eh[ 352];
    eh[ 834] = eh[ 528] - DC[2]*eh[ 352];
    eh[ 835] = eh[ 529] - DC[0]*eh[ 353];
    eh[ 836] = eh[ 525] - DC[1]*eh[ 353];
    eh[ 837] = eh[ 532] - DC[2]*eh[ 353];
    eh[ 838] = eh[ 530] - DC[0]*eh[ 354];
    eh[ 839] = eh[ 533] - DC[1]*eh[ 354];
    eh[ 840] = eh[ 526] - DC[2]*eh[ 354];
    eh[ 841] = eh[ 527] - DC[0]*eh[ 355];
    eh[ 842] = eh[ 529] - DC[1]*eh[ 355];
    eh[ 843] = eh[ 531] - DC[2]*eh[ 355];
    eh[ 844] = eh[ 528] - DC[0]*eh[ 356];
    eh[ 845] = eh[ 531] - DC[1]*eh[ 356];
    eh[ 846] = eh[ 530] - DC[2]*eh[ 356];
    eh[ 847] = eh[ 531] - DC[0]*eh[ 357];
    eh[ 848] = eh[ 532] - DC[1]*eh[ 357];
    eh[ 849] = eh[ 533] - DC[2]*eh[ 357];
    eh[ 850] = eh[ 534] - DC[0]*eh[ 358];
    eh[ 851] = eh[ 537] - DC[1]*eh[ 358];
    eh[ 852] = eh[ 538] - DC[2]*eh[ 358];
    eh[ 853] = eh[ 539] - DC[0]*eh[ 359];
    eh[ 854] = eh[ 535] - DC[1]*eh[ 359];
    eh[ 855] = eh[ 542] - DC[2]*eh[ 359];
    eh[ 856] = eh[ 540] - DC[0]*eh[ 360];
    eh[ 857] = eh[ 543] - DC[1]*eh[ 360];
    eh[ 858] = eh[ 536] - DC[2]*eh[ 360];
    eh[ 859] = eh[ 537] - DC[0]*eh[ 361];
    eh[ 860] = eh[ 539] - DC[1]*eh[ 361];
    eh[ 861] = eh[ 541] - DC[2]*eh[ 361];
    eh[ 862] = eh[ 538] - DC[0]*eh[ 362];
    eh[ 863] = eh[ 541] - DC[1]*eh[ 362];
    eh[ 864] = eh[ 540] - DC[2]*eh[ 362];
    eh[ 865] = eh[ 541] - DC[0]*eh[ 363];
    eh[ 866] = eh[ 542] - DC[1]*eh[ 363];
    eh[ 867] = eh[ 543] - DC[2]*eh[ 363];
}

__device__ void gpu_hrr_coef_dpdp(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 544;
    iy = 0;

#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
#pragma unroll
        for ( j=0, jao=1; j<3; j++, jao++ ) {
            coef_ab = coef_a * LDG(DFACT[jao]);
#pragma unroll
            for ( k=0, kao=4; k<6; k++, kao++ ) {
                coef_abc = coef_ab * LDG(DFACT[kao]);
#pragma unroll
                for ( l=0, lao=1; l<3; l++, lao++ ) {
                    DINT[iy] = coef_abc * LDG(DFACT[lao]) * eh[ix];
                    iy++;
                    ix++;
                }
            }
        }
    }
}

__device__ void gpu_vrr_calc_dpdp(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
    // (ss|ss) m=0,6
    //fmt( &ev[0], 6, T, cssss );
    //OFMO_FMT( &ev[0], 6, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt6_method3( T, cssss, ev );
#elif CUDA_FMT_M == 2
    gpu_fmt6_method2( T, cssss, ev );
#elif CUDA_FMT_M == 1
    gpu_fmt6_method1( T, cssss, ev );
#else
    gpu_fmt6( ev, T, cssss );
#endif
    // (ps|ss) m=0,5
    ev[ 7]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[ 8]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[ 9]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[10]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[11]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[12]=PA[2]*ev[1]+WP[2]*ev[2];
    ev[13]=PA[0]*ev[2]+WP[0]*ev[3];
    ev[14]=PA[1]*ev[2]+WP[1]*ev[3];
    ev[15]=PA[2]*ev[2]+WP[2]*ev[3];
    ev[16]=PA[0]*ev[3]+WP[0]*ev[4];
    ev[17]=PA[1]*ev[3]+WP[1]*ev[4];
    ev[18]=PA[2]*ev[3]+WP[2]*ev[4];
    ev[19]=PA[0]*ev[4]+WP[0]*ev[5];
    ev[20]=PA[1]*ev[4]+WP[1]*ev[5];
    ev[21]=PA[2]*ev[4]+WP[2]*ev[5];
    ev[22]=PA[0]*ev[5]+WP[0]*ev[6];
    ev[23]=PA[1]*ev[5]+WP[1]*ev[6];
    ev[24]=PA[2]*ev[5]+WP[2]*ev[6];
    // (ds|ss) m=0,4
    ev[25]=PA[0]*ev[ 7]+WP[0]*ev[10]+zeta2*(ev[0]-rz*ev[1]);
    ev[26]=PA[1]*ev[ 8]+WP[1]*ev[11]+zeta2*(ev[0]-rz*ev[1]);
    ev[27]=PA[2]*ev[ 9]+WP[2]*ev[12]+zeta2*(ev[0]-rz*ev[1]);
    ev[28]=PA[0]*ev[ 8]+WP[0]*ev[11];
    ev[29]=PA[0]*ev[ 9]+WP[0]*ev[12];
    ev[30]=PA[1]*ev[ 9]+WP[1]*ev[12];
    ev[31]=PA[0]*ev[10]+WP[0]*ev[13]+zeta2*(ev[1]-rz*ev[2]);
    ev[32]=PA[1]*ev[11]+WP[1]*ev[14]+zeta2*(ev[1]-rz*ev[2]);
    ev[33]=PA[2]*ev[12]+WP[2]*ev[15]+zeta2*(ev[1]-rz*ev[2]);
    ev[34]=PA[0]*ev[11]+WP[0]*ev[14];
    ev[35]=PA[0]*ev[12]+WP[0]*ev[15];
    ev[36]=PA[1]*ev[12]+WP[1]*ev[15];
    ev[37]=PA[0]*ev[13]+WP[0]*ev[16]+zeta2*(ev[2]-rz*ev[3]);
    ev[38]=PA[1]*ev[14]+WP[1]*ev[17]+zeta2*(ev[2]-rz*ev[3]);
    ev[39]=PA[2]*ev[15]+WP[2]*ev[18]+zeta2*(ev[2]-rz*ev[3]);
    ev[40]=PA[0]*ev[14]+WP[0]*ev[17];
    ev[41]=PA[0]*ev[15]+WP[0]*ev[18];
    ev[42]=PA[1]*ev[15]+WP[1]*ev[18];
    ev[43]=PA[0]*ev[16]+WP[0]*ev[19]+zeta2*(ev[3]-rz*ev[4]);
    ev[44]=PA[1]*ev[17]+WP[1]*ev[20]+zeta2*(ev[3]-rz*ev[4]);
    ev[45]=PA[2]*ev[18]+WP[2]*ev[21]+zeta2*(ev[3]-rz*ev[4]);
    ev[46]=PA[0]*ev[17]+WP[0]*ev[20];
    ev[47]=PA[0]*ev[18]+WP[0]*ev[21];
    ev[48]=PA[1]*ev[18]+WP[1]*ev[21];
    ev[49]=PA[0]*ev[19]+WP[0]*ev[22]+zeta2*(ev[4]-rz*ev[5]);
    ev[50]=PA[1]*ev[20]+WP[1]*ev[23]+zeta2*(ev[4]-rz*ev[5]);
    ev[51]=PA[2]*ev[21]+WP[2]*ev[24]+zeta2*(ev[4]-rz*ev[5]);
    ev[52]=PA[0]*ev[20]+WP[0]*ev[23];
    ev[53]=PA[0]*ev[21]+WP[0]*ev[24];
    ev[54]=PA[1]*ev[21]+WP[1]*ev[24];
    // (fs|ss) m=0,3
    ev[55]=PA[0]*ev[25]+WP[0]*ev[31]+2.e0*zeta2*(ev[ 7]-rz*ev[10]);
    ev[56]=PA[1]*ev[26]+WP[1]*ev[32]+2.e0*zeta2*(ev[ 8]-rz*ev[11]);
    ev[57]=PA[2]*ev[27]+WP[2]*ev[33]+2.e0*zeta2*(ev[ 9]-rz*ev[12]);
    ev[58]=PA[1]*ev[25]+WP[1]*ev[31];
    ev[59]=PA[2]*ev[25]+WP[2]*ev[31];
    ev[60]=PA[0]*ev[26]+WP[0]*ev[32];
    ev[61]=PA[0]*ev[27]+WP[0]*ev[33];
    ev[62]=PA[0]*ev[30]+WP[0]*ev[36];
    ev[63]=PA[2]*ev[26]+WP[2]*ev[32];
    ev[64]=PA[1]*ev[27]+WP[1]*ev[33];
    ev[65]=PA[0]*ev[31]+WP[0]*ev[37]+2.e0*zeta2*(ev[10]-rz*ev[13]);
    ev[66]=PA[1]*ev[32]+WP[1]*ev[38]+2.e0*zeta2*(ev[11]-rz*ev[14]);
    ev[67]=PA[2]*ev[33]+WP[2]*ev[39]+2.e0*zeta2*(ev[12]-rz*ev[15]);
    ev[68]=PA[1]*ev[31]+WP[1]*ev[37];
    ev[69]=PA[2]*ev[31]+WP[2]*ev[37];
    ev[70]=PA[0]*ev[32]+WP[0]*ev[38];
    ev[71]=PA[0]*ev[33]+WP[0]*ev[39];
    ev[72]=PA[0]*ev[36]+WP[0]*ev[42];
    ev[73]=PA[2]*ev[32]+WP[2]*ev[38];
    ev[74]=PA[1]*ev[33]+WP[1]*ev[39];
    ev[75]=PA[0]*ev[37]+WP[0]*ev[43]+2.e0*zeta2*(ev[13]-rz*ev[16]);
    ev[76]=PA[1]*ev[38]+WP[1]*ev[44]+2.e0*zeta2*(ev[14]-rz*ev[17]);
    ev[77]=PA[2]*ev[39]+WP[2]*ev[45]+2.e0*zeta2*(ev[15]-rz*ev[18]);
    ev[78]=PA[1]*ev[37]+WP[1]*ev[43];
    ev[79]=PA[2]*ev[37]+WP[2]*ev[43];
    ev[80]=PA[0]*ev[38]+WP[0]*ev[44];
    ev[81]=PA[0]*ev[39]+WP[0]*ev[45];
    ev[82]=PA[0]*ev[42]+WP[0]*ev[48];
    ev[83]=PA[2]*ev[38]+WP[2]*ev[44];
    ev[84]=PA[1]*ev[39]+WP[1]*ev[45];
    ev[85]=PA[0]*ev[43]+WP[0]*ev[49]+2.e0*zeta2*(ev[16]-rz*ev[19]);
    ev[86]=PA[1]*ev[44]+WP[1]*ev[50]+2.e0*zeta2*(ev[17]-rz*ev[20]);
    ev[87]=PA[2]*ev[45]+WP[2]*ev[51]+2.e0*zeta2*(ev[18]-rz*ev[21]);
    ev[88]=PA[1]*ev[43]+WP[1]*ev[49];
    ev[89]=PA[2]*ev[43]+WP[2]*ev[49];
    ev[90]=PA[0]*ev[44]+WP[0]*ev[50];
    ev[91]=PA[0]*ev[45]+WP[0]*ev[51];
    ev[92]=PA[0]*ev[48]+WP[0]*ev[54];
    ev[93]=PA[2]*ev[44]+WP[2]*ev[50];
    ev[94]=PA[1]*ev[45]+WP[1]*ev[51];
    // (ss|ps) m=[2,2]
    ev[95]=QC[0]*ev[2]+WQ[0]*ev[3];
    ev[96]=QC[1]*ev[2]+WQ[1]*ev[3];
    ev[97]=QC[2]*ev[2]+WQ[2]*ev[3];
    // (ps|ps) m=[1,2]
    ev[ 98]=QC[0]*ev[10]+WQ[0]*ev[13]+ze2*ev[2];
    ev[ 99]=QC[1]*ev[10]+WQ[1]*ev[13];
    ev[100]=QC[2]*ev[10]+WQ[2]*ev[13];
    ev[101]=QC[0]*ev[11]+WQ[0]*ev[14];
    ev[102]=QC[1]*ev[11]+WQ[1]*ev[14]+ze2*ev[2];
    ev[103]=QC[2]*ev[11]+WQ[2]*ev[14];
    ev[104]=QC[0]*ev[12]+WQ[0]*ev[15];
    ev[105]=QC[1]*ev[12]+WQ[1]*ev[15];
    ev[106]=QC[2]*ev[12]+WQ[2]*ev[15]+ze2*ev[2];
    ev[107]=QC[0]*ev[13]+WQ[0]*ev[16]+ze2*ev[3];
    ev[108]=QC[1]*ev[13]+WQ[1]*ev[16];
    ev[109]=QC[2]*ev[13]+WQ[2]*ev[16];
    ev[110]=QC[0]*ev[14]+WQ[0]*ev[17];
    ev[111]=QC[1]*ev[14]+WQ[1]*ev[17]+ze2*ev[3];
    ev[112]=QC[2]*ev[14]+WQ[2]*ev[17];
    ev[113]=QC[0]*ev[15]+WQ[0]*ev[18];
    ev[114]=QC[1]*ev[15]+WQ[1]*ev[18];
    ev[115]=QC[2]*ev[15]+WQ[2]*ev[18]+ze2*ev[3];
    // (ds|ps) m=[0,2]
    ev[116]=QC[0]*ev[25]+WQ[0]*ev[31]+2.e0*ze2*ev[10];
    ev[117]=QC[1]*ev[25]+WQ[1]*ev[31];
    ev[118]=QC[2]*ev[25]+WQ[2]*ev[31];
    ev[119]=QC[0]*ev[26]+WQ[0]*ev[32];
    ev[120]=QC[1]*ev[26]+WQ[1]*ev[32]+2.e0*ze2*ev[11];
    ev[121]=QC[2]*ev[26]+WQ[2]*ev[32];
    ev[122]=QC[0]*ev[27]+WQ[0]*ev[33];
    ev[123]=QC[1]*ev[27]+WQ[1]*ev[33];
    ev[124]=QC[2]*ev[27]+WQ[2]*ev[33]+2.e0*ze2*ev[12];
    ev[125]=QC[0]*ev[28]+WQ[0]*ev[34]+     ze2*ev[11];
    ev[126]=QC[1]*ev[28]+WQ[1]*ev[34]+     ze2*ev[10];
    ev[127]=QC[2]*ev[28]+WQ[2]*ev[34];
    ev[128]=QC[0]*ev[29]+WQ[0]*ev[35]+     ze2*ev[12];
    ev[129]=QC[1]*ev[29]+WQ[1]*ev[35];
    ev[130]=QC[2]*ev[29]+WQ[2]*ev[35]+     ze2*ev[10];
    ev[131]=QC[0]*ev[30]+WQ[0]*ev[36];
    ev[132]=QC[1]*ev[30]+WQ[1]*ev[36]+     ze2*ev[12];
    ev[133]=QC[2]*ev[30]+WQ[2]*ev[36]+     ze2*ev[11];
    ev[134]=QC[0]*ev[31]+WQ[0]*ev[37]+2.e0*ze2*ev[13];
    ev[135]=QC[1]*ev[31]+WQ[1]*ev[37];
    ev[136]=QC[2]*ev[31]+WQ[2]*ev[37];
    ev[137]=QC[0]*ev[32]+WQ[0]*ev[38];
    ev[138]=QC[1]*ev[32]+WQ[1]*ev[38]+2.e0*ze2*ev[14];
    ev[139]=QC[2]*ev[32]+WQ[2]*ev[38];
    ev[140]=QC[0]*ev[33]+WQ[0]*ev[39];
    ev[141]=QC[1]*ev[33]+WQ[1]*ev[39];
    ev[142]=QC[2]*ev[33]+WQ[2]*ev[39]+2.e0*ze2*ev[15];
    ev[143]=QC[0]*ev[34]+WQ[0]*ev[40]+     ze2*ev[14];
    ev[144]=QC[1]*ev[34]+WQ[1]*ev[40]+     ze2*ev[13];
    ev[145]=QC[2]*ev[34]+WQ[2]*ev[40];
    ev[146]=QC[0]*ev[35]+WQ[0]*ev[41]+     ze2*ev[15];
    ev[147]=QC[1]*ev[35]+WQ[1]*ev[41];
    ev[148]=QC[2]*ev[35]+WQ[2]*ev[41]+     ze2*ev[13];
    ev[149]=QC[0]*ev[36]+WQ[0]*ev[42];
    ev[150]=QC[1]*ev[36]+WQ[1]*ev[42]+     ze2*ev[15];
    ev[151]=QC[2]*ev[36]+WQ[2]*ev[42]+     ze2*ev[14];
    ev[152]=QC[0]*ev[37]+WQ[0]*ev[43]+2.e0*ze2*ev[16];
    ev[153]=QC[1]*ev[37]+WQ[1]*ev[43];
    ev[154]=QC[2]*ev[37]+WQ[2]*ev[43];
    ev[155]=QC[0]*ev[38]+WQ[0]*ev[44];
    ev[156]=QC[1]*ev[38]+WQ[1]*ev[44]+2.e0*ze2*ev[17];
    ev[157]=QC[2]*ev[38]+WQ[2]*ev[44];
    ev[158]=QC[0]*ev[39]+WQ[0]*ev[45];
    ev[159]=QC[1]*ev[39]+WQ[1]*ev[45];
    ev[160]=QC[2]*ev[39]+WQ[2]*ev[45]+2.e0*ze2*ev[18];
    ev[161]=QC[0]*ev[40]+WQ[0]*ev[46]+     ze2*ev[17];
    ev[162]=QC[1]*ev[40]+WQ[1]*ev[46]+     ze2*ev[16];
    ev[163]=QC[2]*ev[40]+WQ[2]*ev[46];
    ev[164]=QC[0]*ev[41]+WQ[0]*ev[47]+     ze2*ev[18];
    ev[165]=QC[1]*ev[41]+WQ[1]*ev[47];
    ev[166]=QC[2]*ev[41]+WQ[2]*ev[47]+     ze2*ev[16];
    ev[167]=QC[0]*ev[42]+WQ[0]*ev[48];
    ev[168]=QC[1]*ev[42]+WQ[1]*ev[48]+     ze2*ev[18];
    ev[169]=QC[2]*ev[42]+WQ[2]*ev[48]+     ze2*ev[17];
    // (fs|ps) m=[0,2]
    ev[170]=QC[0]*ev[55]+WQ[0]*ev[65]+3.e0*ze2*ev[31];
    ev[171]=QC[1]*ev[55]+WQ[1]*ev[65];
    ev[172]=QC[2]*ev[55]+WQ[2]*ev[65];
    ev[173]=QC[0]*ev[56]+WQ[0]*ev[66];
    ev[174]=QC[1]*ev[56]+WQ[1]*ev[66]+3.e0*ze2*ev[32];
    ev[175]=QC[2]*ev[56]+WQ[2]*ev[66];
    ev[176]=QC[0]*ev[57]+WQ[0]*ev[67];
    ev[177]=QC[1]*ev[57]+WQ[1]*ev[67];
    ev[178]=QC[2]*ev[57]+WQ[2]*ev[67]+3.e0*ze2*ev[33];
    ev[179]=QC[0]*ev[58]+WQ[0]*ev[68]+2.e0*ze2*ev[34];
    ev[180]=QC[1]*ev[58]+WQ[1]*ev[68]+     ze2*ev[31];
    ev[181]=QC[2]*ev[58]+WQ[2]*ev[68];
    ev[182]=QC[0]*ev[59]+WQ[0]*ev[69]+2.e0*ze2*ev[35];
    ev[183]=QC[1]*ev[59]+WQ[1]*ev[69];
    ev[184]=QC[2]*ev[59]+WQ[2]*ev[69]+     ze2*ev[31];
    ev[185]=QC[0]*ev[60]+WQ[0]*ev[70]+     ze2*ev[32];
    ev[186]=QC[1]*ev[60]+WQ[1]*ev[70]+2.e0*ze2*ev[34];
    ev[187]=QC[2]*ev[60]+WQ[2]*ev[70];
    ev[188]=QC[0]*ev[61]+WQ[0]*ev[71]+     ze2*ev[33];
    ev[189]=QC[1]*ev[61]+WQ[1]*ev[71];
    ev[190]=QC[2]*ev[61]+WQ[2]*ev[71]+2.e0*ze2*ev[35];
    ev[191]=QC[0]*ev[62]+WQ[0]*ev[72]+     ze2*ev[36];
    ev[192]=QC[1]*ev[62]+WQ[1]*ev[72]+     ze2*ev[35];
    ev[193]=QC[2]*ev[62]+WQ[2]*ev[72]+     ze2*ev[34];
    ev[194]=QC[0]*ev[63]+WQ[0]*ev[73];
    ev[195]=QC[1]*ev[63]+WQ[1]*ev[73]+2.e0*ze2*ev[36];
    ev[196]=QC[2]*ev[63]+WQ[2]*ev[73]+     ze2*ev[32];
    ev[197]=QC[0]*ev[64]+WQ[0]*ev[74];
    ev[198]=QC[1]*ev[64]+WQ[1]*ev[74]+     ze2*ev[33];
    ev[199]=QC[2]*ev[64]+WQ[2]*ev[74]+2.e0*ze2*ev[36];
    ev[200]=QC[0]*ev[65]+WQ[0]*ev[75]+3.e0*ze2*ev[37];
    ev[201]=QC[1]*ev[65]+WQ[1]*ev[75];
    ev[202]=QC[2]*ev[65]+WQ[2]*ev[75];
    ev[203]=QC[0]*ev[66]+WQ[0]*ev[76];
    ev[204]=QC[1]*ev[66]+WQ[1]*ev[76]+3.e0*ze2*ev[38];
    ev[205]=QC[2]*ev[66]+WQ[2]*ev[76];
    ev[206]=QC[0]*ev[67]+WQ[0]*ev[77];
    ev[207]=QC[1]*ev[67]+WQ[1]*ev[77];
    ev[208]=QC[2]*ev[67]+WQ[2]*ev[77]+3.e0*ze2*ev[39];
    ev[209]=QC[0]*ev[68]+WQ[0]*ev[78]+2.e0*ze2*ev[40];
    ev[210]=QC[1]*ev[68]+WQ[1]*ev[78]+     ze2*ev[37];
    ev[211]=QC[2]*ev[68]+WQ[2]*ev[78];
    ev[212]=QC[0]*ev[69]+WQ[0]*ev[79]+2.e0*ze2*ev[41];
    ev[213]=QC[1]*ev[69]+WQ[1]*ev[79];
    ev[214]=QC[2]*ev[69]+WQ[2]*ev[79]+     ze2*ev[37];
    ev[215]=QC[0]*ev[70]+WQ[0]*ev[80]+     ze2*ev[38];
    ev[216]=QC[1]*ev[70]+WQ[1]*ev[80]+2.e0*ze2*ev[40];
    ev[217]=QC[2]*ev[70]+WQ[2]*ev[80];
    ev[218]=QC[0]*ev[71]+WQ[0]*ev[81]+     ze2*ev[39];
    ev[219]=QC[1]*ev[71]+WQ[1]*ev[81];
    ev[220]=QC[2]*ev[71]+WQ[2]*ev[81]+2.e0*ze2*ev[41];
    ev[221]=QC[0]*ev[72]+WQ[0]*ev[82]+     ze2*ev[42];
    ev[222]=QC[1]*ev[72]+WQ[1]*ev[82]+     ze2*ev[41];
    ev[223]=QC[2]*ev[72]+WQ[2]*ev[82]+     ze2*ev[40];
    ev[224]=QC[0]*ev[73]+WQ[0]*ev[83];
    ev[225]=QC[1]*ev[73]+WQ[1]*ev[83]+2.e0*ze2*ev[42];
    ev[226]=QC[2]*ev[73]+WQ[2]*ev[83]+     ze2*ev[38];
    ev[227]=QC[0]*ev[74]+WQ[0]*ev[84];
    ev[228]=QC[1]*ev[74]+WQ[1]*ev[84]+     ze2*ev[39];
    ev[229]=QC[2]*ev[74]+WQ[2]*ev[84]+2.e0*ze2*ev[42];
    ev[230]=QC[0]*ev[75]+WQ[0]*ev[85]+3.e0*ze2*ev[43];
    ev[231]=QC[1]*ev[75]+WQ[1]*ev[85];
    ev[232]=QC[2]*ev[75]+WQ[2]*ev[85];
    ev[233]=QC[0]*ev[76]+WQ[0]*ev[86];
    ev[234]=QC[1]*ev[76]+WQ[1]*ev[86]+3.e0*ze2*ev[44];
    ev[235]=QC[2]*ev[76]+WQ[2]*ev[86];
    ev[236]=QC[0]*ev[77]+WQ[0]*ev[87];
    ev[237]=QC[1]*ev[77]+WQ[1]*ev[87];
    ev[238]=QC[2]*ev[77]+WQ[2]*ev[87]+3.e0*ze2*ev[45];
    ev[239]=QC[0]*ev[78]+WQ[0]*ev[88]+2.e0*ze2*ev[46];
    ev[240]=QC[1]*ev[78]+WQ[1]*ev[88]+     ze2*ev[43];
    ev[241]=QC[2]*ev[78]+WQ[2]*ev[88];
    ev[242]=QC[0]*ev[79]+WQ[0]*ev[89]+2.e0*ze2*ev[47];
    ev[243]=QC[1]*ev[79]+WQ[1]*ev[89];
    ev[244]=QC[2]*ev[79]+WQ[2]*ev[89]+     ze2*ev[43];
    ev[245]=QC[0]*ev[80]+WQ[0]*ev[90]+     ze2*ev[44];
    ev[246]=QC[1]*ev[80]+WQ[1]*ev[90]+2.e0*ze2*ev[46];
    ev[247]=QC[2]*ev[80]+WQ[2]*ev[90];
    ev[248]=QC[0]*ev[81]+WQ[0]*ev[91]+     ze2*ev[45];
    ev[249]=QC[1]*ev[81]+WQ[1]*ev[91];
    ev[250]=QC[2]*ev[81]+WQ[2]*ev[91]+2.e0*ze2*ev[47];
    ev[251]=QC[0]*ev[82]+WQ[0]*ev[92]+     ze2*ev[48];
    ev[252]=QC[1]*ev[82]+WQ[1]*ev[92]+     ze2*ev[47];
    ev[253]=QC[2]*ev[82]+WQ[2]*ev[92]+     ze2*ev[46];
    ev[254]=QC[0]*ev[83]+WQ[0]*ev[93];
    ev[255]=QC[1]*ev[83]+WQ[1]*ev[93]+2.e0*ze2*ev[48];
    ev[256]=QC[2]*ev[83]+WQ[2]*ev[93]+     ze2*ev[44];
    ev[257]=QC[0]*ev[84]+WQ[0]*ev[94];
    ev[258]=QC[1]*ev[84]+WQ[1]*ev[94]+     ze2*ev[45];
    ev[259]=QC[2]*ev[84]+WQ[2]*ev[94]+2.e0*ze2*ev[48];
    // (ps|ds) m=[1,1]
    ev[260]=QC[0]*ev[ 98]+WQ[0]*ev[107]+eta2*(ev[10]-re*ev[13])+ze2*ev[95]
            ;
    ev[261]=QC[1]*ev[ 99]+WQ[1]*ev[108]+eta2*(ev[10]-re*ev[13]);
    ev[262]=QC[2]*ev[100]+WQ[2]*ev[109]+eta2*(ev[10]-re*ev[13]);
    ev[263]=QC[0]*ev[ 99]+WQ[0]*ev[108]+ze2*ev[96];
    ev[264]=QC[0]*ev[100]+WQ[0]*ev[109]+ze2*ev[97];
    ev[265]=QC[1]*ev[100]+WQ[1]*ev[109];
    ev[266]=QC[0]*ev[101]+WQ[0]*ev[110]+eta2*(ev[11]-re*ev[14]);
    ev[267]=QC[1]*ev[102]+WQ[1]*ev[111]+eta2*(ev[11]-re*ev[14])+ze2*ev[96]
            ;
    ev[268]=QC[2]*ev[103]+WQ[2]*ev[112]+eta2*(ev[11]-re*ev[14]);
    ev[269]=QC[0]*ev[102]+WQ[0]*ev[111];
    ev[270]=QC[0]*ev[103]+WQ[0]*ev[112];
    ev[271]=QC[1]*ev[103]+WQ[1]*ev[112]+ze2*ev[97];
    ev[272]=QC[0]*ev[104]+WQ[0]*ev[113]+eta2*(ev[12]-re*ev[15]);
    ev[273]=QC[1]*ev[105]+WQ[1]*ev[114]+eta2*(ev[12]-re*ev[15]);
    ev[274]=QC[2]*ev[106]+WQ[2]*ev[115]+eta2*(ev[12]-re*ev[15])+ze2*ev[97]
            ;
    ev[275]=QC[0]*ev[105]+WQ[0]*ev[114];
    ev[276]=QC[0]*ev[106]+WQ[0]*ev[115];
    ev[277]=QC[1]*ev[106]+WQ[1]*ev[115];
    // (ds|ds) m=[0,1]
    ev[278]=QC[0]*ev[116]+WQ[0]*ev[134]+eta2*(ev[25]-re*ev[31])
            +2.e0*ze2*ev[ 98];
    ev[279]=QC[1]*ev[117]+WQ[1]*ev[135]+eta2*(ev[25]-re*ev[31]);
    ev[280]=QC[2]*ev[118]+WQ[2]*ev[136]+eta2*(ev[25]-re*ev[31]);
    ev[281]=QC[0]*ev[117]+WQ[0]*ev[135]+2.e0*ze2*ev[ 99];
    ev[282]=QC[0]*ev[118]+WQ[0]*ev[136]+2.e0*ze2*ev[100];
    ev[283]=QC[1]*ev[118]+WQ[1]*ev[136];
    ev[284]=QC[0]*ev[119]+WQ[0]*ev[137]+eta2*(ev[26]-re*ev[32]);
    ev[285]=QC[1]*ev[120]+WQ[1]*ev[138]+eta2*(ev[26]-re*ev[32])
            +2.e0*ze2*ev[102];
    ev[286]=QC[2]*ev[121]+WQ[2]*ev[139]+eta2*(ev[26]-re*ev[32]);
    ev[287]=QC[0]*ev[120]+WQ[0]*ev[138];
    ev[288]=QC[0]*ev[121]+WQ[0]*ev[139];
    ev[289]=QC[1]*ev[121]+WQ[1]*ev[139]+2.e0*ze2*ev[103];
    ev[290]=QC[0]*ev[122]+WQ[0]*ev[140]+eta2*(ev[27]-re*ev[33]);
    ev[291]=QC[1]*ev[123]+WQ[1]*ev[141]+eta2*(ev[27]-re*ev[33]);
    ev[292]=QC[2]*ev[124]+WQ[2]*ev[142]+eta2*(ev[27]-re*ev[33])
            +2.e0*ze2*ev[106];
    ev[293]=QC[0]*ev[123]+WQ[0]*ev[141];
    ev[294]=QC[0]*ev[124]+WQ[0]*ev[142];
    ev[295]=QC[1]*ev[124]+WQ[1]*ev[142];
    ev[296]=QC[0]*ev[125]+WQ[0]*ev[143]+eta2*(ev[28]-re*ev[34])
            +     ze2*ev[101];
    ev[297]=QC[1]*ev[126]+WQ[1]*ev[144]+eta2*(ev[28]-re*ev[34])
            +     ze2*ev[ 99];
    ev[298]=QC[2]*ev[127]+WQ[2]*ev[145]+eta2*(ev[28]-re*ev[34]);
    ev[299]=QC[0]*ev[126]+WQ[0]*ev[144]+     ze2*ev[102];
    ev[300]=QC[0]*ev[127]+WQ[0]*ev[145]+     ze2*ev[103];
    ev[301]=QC[1]*ev[127]+WQ[1]*ev[145]+     ze2*ev[100];
    ev[302]=QC[0]*ev[128]+WQ[0]*ev[146]+eta2*(ev[29]-re*ev[35])
            +     ze2*ev[104];
    ev[303]=QC[1]*ev[129]+WQ[1]*ev[147]+eta2*(ev[29]-re*ev[35]);
    ev[304]=QC[2]*ev[130]+WQ[2]*ev[148]+eta2*(ev[29]-re*ev[35])
            +     ze2*ev[100];
    ev[305]=QC[0]*ev[129]+WQ[0]*ev[147]+     ze2*ev[105];
    ev[306]=QC[0]*ev[130]+WQ[0]*ev[148]+     ze2*ev[106];
    ev[307]=QC[1]*ev[130]+WQ[1]*ev[148];
    ev[308]=QC[0]*ev[131]+WQ[0]*ev[149]+eta2*(ev[30]-re*ev[36]);
    ev[309]=QC[1]*ev[132]+WQ[1]*ev[150]+eta2*(ev[30]-re*ev[36])
            +     ze2*ev[105];
    ev[310]=QC[2]*ev[133]+WQ[2]*ev[151]+eta2*(ev[30]-re*ev[36])
            +     ze2*ev[103];
    ev[311]=QC[0]*ev[132]+WQ[0]*ev[150];
    ev[312]=QC[0]*ev[133]+WQ[0]*ev[151];
    ev[313]=QC[1]*ev[133]+WQ[1]*ev[151]+     ze2*ev[106];
    ev[314]=QC[0]*ev[134]+WQ[0]*ev[152]+eta2*(ev[31]-re*ev[37])
            +2.e0*ze2*ev[107];
    ev[315]=QC[1]*ev[135]+WQ[1]*ev[153]+eta2*(ev[31]-re*ev[37]);
    ev[316]=QC[2]*ev[136]+WQ[2]*ev[154]+eta2*(ev[31]-re*ev[37]);
    ev[317]=QC[0]*ev[135]+WQ[0]*ev[153]+2.e0*ze2*ev[108];
    ev[318]=QC[0]*ev[136]+WQ[0]*ev[154]+2.e0*ze2*ev[109];
    ev[319]=QC[1]*ev[136]+WQ[1]*ev[154];
    ev[320]=QC[0]*ev[137]+WQ[0]*ev[155]+eta2*(ev[32]-re*ev[38]);
    ev[321]=QC[1]*ev[138]+WQ[1]*ev[156]+eta2*(ev[32]-re*ev[38])
            +2.e0*ze2*ev[111];
    ev[322]=QC[2]*ev[139]+WQ[2]*ev[157]+eta2*(ev[32]-re*ev[38]);
    ev[323]=QC[0]*ev[138]+WQ[0]*ev[156];
    ev[324]=QC[0]*ev[139]+WQ[0]*ev[157];
    ev[325]=QC[1]*ev[139]+WQ[1]*ev[157]+2.e0*ze2*ev[112];
    ev[326]=QC[0]*ev[140]+WQ[0]*ev[158]+eta2*(ev[33]-re*ev[39]);
    ev[327]=QC[1]*ev[141]+WQ[1]*ev[159]+eta2*(ev[33]-re*ev[39]);
    ev[328]=QC[2]*ev[142]+WQ[2]*ev[160]+eta2*(ev[33]-re*ev[39])
            +2.e0*ze2*ev[115];
    ev[329]=QC[0]*ev[141]+WQ[0]*ev[159];
    ev[330]=QC[0]*ev[142]+WQ[0]*ev[160];
    ev[331]=QC[1]*ev[142]+WQ[1]*ev[160];
    ev[332]=QC[0]*ev[143]+WQ[0]*ev[161]+eta2*(ev[34]-re*ev[40])
            +     ze2*ev[110];
    ev[333]=QC[1]*ev[144]+WQ[1]*ev[162]+eta2*(ev[34]-re*ev[40])
            +     ze2*ev[108];
    ev[334]=QC[2]*ev[145]+WQ[2]*ev[163]+eta2*(ev[34]-re*ev[40]);
    ev[335]=QC[0]*ev[144]+WQ[0]*ev[162]+     ze2*ev[111];
    ev[336]=QC[0]*ev[145]+WQ[0]*ev[163]+     ze2*ev[112];
    ev[337]=QC[1]*ev[145]+WQ[1]*ev[163]+     ze2*ev[109];
    ev[338]=QC[0]*ev[146]+WQ[0]*ev[164]+eta2*(ev[35]-re*ev[41])
            +     ze2*ev[113];
    ev[339]=QC[1]*ev[147]+WQ[1]*ev[165]+eta2*(ev[35]-re*ev[41]);
    ev[340]=QC[2]*ev[148]+WQ[2]*ev[166]+eta2*(ev[35]-re*ev[41])
            +     ze2*ev[109];
    ev[341]=QC[0]*ev[147]+WQ[0]*ev[165]+     ze2*ev[114];
    ev[342]=QC[0]*ev[148]+WQ[0]*ev[166]+     ze2*ev[115];
    ev[343]=QC[1]*ev[148]+WQ[1]*ev[166];
    ev[344]=QC[0]*ev[149]+WQ[0]*ev[167]+eta2*(ev[36]-re*ev[42]);
    ev[345]=QC[1]*ev[150]+WQ[1]*ev[168]+eta2*(ev[36]-re*ev[42])
            +     ze2*ev[114];
    ev[346]=QC[2]*ev[151]+WQ[2]*ev[169]+eta2*(ev[36]-re*ev[42])
            +     ze2*ev[112];
    ev[347]=QC[0]*ev[150]+WQ[0]*ev[168];
    ev[348]=QC[0]*ev[151]+WQ[0]*ev[169];
    ev[349]=QC[1]*ev[151]+WQ[1]*ev[169]+     ze2*ev[115];
    // (fs|ds) m=[0,1]
    ev[350]=QC[0]*ev[170]+WQ[0]*ev[200]+eta2*(ev[55]-re*ev[65])
            +3.e0*ze2*ev[134];
    ev[351]=QC[1]*ev[171]+WQ[1]*ev[201]+eta2*(ev[55]-re*ev[65]);
    ev[352]=QC[2]*ev[172]+WQ[2]*ev[202]+eta2*(ev[55]-re*ev[65]);
    ev[353]=QC[0]*ev[171]+WQ[0]*ev[201]+3.e0*ze2*ev[135];
    ev[354]=QC[0]*ev[172]+WQ[0]*ev[202]+3.e0*ze2*ev[136];
    ev[355]=QC[1]*ev[172]+WQ[1]*ev[202];
    ev[356]=QC[0]*ev[173]+WQ[0]*ev[203]+eta2*(ev[56]-re*ev[66]);
    ev[357]=QC[1]*ev[174]+WQ[1]*ev[204]+eta2*(ev[56]-re*ev[66])
            +3.e0*ze2*ev[138];
    ev[358]=QC[2]*ev[175]+WQ[2]*ev[205]+eta2*(ev[56]-re*ev[66]);
    ev[359]=QC[0]*ev[174]+WQ[0]*ev[204];
    ev[360]=QC[0]*ev[175]+WQ[0]*ev[205];
    ev[361]=QC[1]*ev[175]+WQ[1]*ev[205]+3.e0*ze2*ev[139];
    ev[362]=QC[0]*ev[176]+WQ[0]*ev[206]+eta2*(ev[57]-re*ev[67]);
    ev[363]=QC[1]*ev[177]+WQ[1]*ev[207]+eta2*(ev[57]-re*ev[67]);
    ev[364]=QC[2]*ev[178]+WQ[2]*ev[208]+eta2*(ev[57]-re*ev[67])
            +3.e0*ze2*ev[142];
    ev[365]=QC[0]*ev[177]+WQ[0]*ev[207];
    ev[366]=QC[0]*ev[178]+WQ[0]*ev[208];
    ev[367]=QC[1]*ev[178]+WQ[1]*ev[208];
    ev[368]=QC[0]*ev[179]+WQ[0]*ev[209]+eta2*(ev[58]-re*ev[68])
            +2.e0*ze2*ev[143];
    ev[369]=QC[1]*ev[180]+WQ[1]*ev[210]+eta2*(ev[58]-re*ev[68])
            +     ze2*ev[135];
    ev[370]=QC[2]*ev[181]+WQ[2]*ev[211]+eta2*(ev[58]-re*ev[68]);
    ev[371]=QC[0]*ev[180]+WQ[0]*ev[210]+2.e0*ze2*ev[144];
    ev[372]=QC[0]*ev[181]+WQ[0]*ev[211]+2.e0*ze2*ev[145];
    ev[373]=QC[1]*ev[181]+WQ[1]*ev[211]+     ze2*ev[136];
    ev[374]=QC[0]*ev[182]+WQ[0]*ev[212]+eta2*(ev[59]-re*ev[69])
            +2.e0*ze2*ev[146];
    ev[375]=QC[1]*ev[183]+WQ[1]*ev[213]+eta2*(ev[59]-re*ev[69]);
    ev[376]=QC[2]*ev[184]+WQ[2]*ev[214]+eta2*(ev[59]-re*ev[69])
            +     ze2*ev[136];
    ev[377]=QC[0]*ev[183]+WQ[0]*ev[213]+2.e0*ze2*ev[147];
    ev[378]=QC[0]*ev[184]+WQ[0]*ev[214]+2.e0*ze2*ev[148];
    ev[379]=QC[1]*ev[184]+WQ[1]*ev[214];
    ev[380]=QC[0]*ev[185]+WQ[0]*ev[215]+eta2*(ev[60]-re*ev[70])
            +     ze2*ev[137];
    ev[381]=QC[1]*ev[186]+WQ[1]*ev[216]+eta2*(ev[60]-re*ev[70])
            +2.e0*ze2*ev[144];
    ev[382]=QC[2]*ev[187]+WQ[2]*ev[217]+eta2*(ev[60]-re*ev[70]);
    ev[383]=QC[0]*ev[186]+WQ[0]*ev[216]+     ze2*ev[138];
    ev[384]=QC[0]*ev[187]+WQ[0]*ev[217]+     ze2*ev[139];
    ev[385]=QC[1]*ev[187]+WQ[1]*ev[217]+2.e0*ze2*ev[145];
    ev[386]=QC[0]*ev[188]+WQ[0]*ev[218]+eta2*(ev[61]-re*ev[71])
            +     ze2*ev[140];
    ev[387]=QC[1]*ev[189]+WQ[1]*ev[219]+eta2*(ev[61]-re*ev[71]);
    ev[388]=QC[2]*ev[190]+WQ[2]*ev[220]+eta2*(ev[61]-re*ev[71])
            +2.e0*ze2*ev[148];
    ev[389]=QC[0]*ev[189]+WQ[0]*ev[219]+     ze2*ev[141];
    ev[390]=QC[0]*ev[190]+WQ[0]*ev[220]+     ze2*ev[142];
    ev[391]=QC[1]*ev[190]+WQ[1]*ev[220];
    ev[392]=QC[0]*ev[191]+WQ[0]*ev[221]+eta2*(ev[62]-re*ev[72])
            +     ze2*ev[149];
    ev[393]=QC[1]*ev[192]+WQ[1]*ev[222]+eta2*(ev[62]-re*ev[72])
            +     ze2*ev[147];
    ev[394]=QC[2]*ev[193]+WQ[2]*ev[223]+eta2*(ev[62]-re*ev[72])
            +     ze2*ev[145];
    ev[395]=QC[0]*ev[192]+WQ[0]*ev[222]+     ze2*ev[150];
    ev[396]=QC[0]*ev[193]+WQ[0]*ev[223]+     ze2*ev[151];
    ev[397]=QC[1]*ev[193]+WQ[1]*ev[223]+     ze2*ev[148];
    ev[398]=QC[0]*ev[194]+WQ[0]*ev[224]+eta2*(ev[63]-re*ev[73]);
    ev[399]=QC[1]*ev[195]+WQ[1]*ev[225]+eta2*(ev[63]-re*ev[73])
            +2.e0*ze2*ev[150];
    ev[400]=QC[2]*ev[196]+WQ[2]*ev[226]+eta2*(ev[63]-re*ev[73])
            +     ze2*ev[139];
    ev[401]=QC[0]*ev[195]+WQ[0]*ev[225];
    ev[402]=QC[0]*ev[196]+WQ[0]*ev[226];
    ev[403]=QC[1]*ev[196]+WQ[1]*ev[226]+2.e0*ze2*ev[151];
    ev[404]=QC[0]*ev[197]+WQ[0]*ev[227]+eta2*(ev[64]-re*ev[74]);
    ev[405]=QC[1]*ev[198]+WQ[1]*ev[228]+eta2*(ev[64]-re*ev[74])
            +     ze2*ev[141];
    ev[406]=QC[2]*ev[199]+WQ[2]*ev[229]+eta2*(ev[64]-re*ev[74])
            +2.e0*ze2*ev[151];
    ev[407]=QC[0]*ev[198]+WQ[0]*ev[228];
    ev[408]=QC[0]*ev[199]+WQ[0]*ev[229];
    ev[409]=QC[1]*ev[199]+WQ[1]*ev[229]+     ze2*ev[142];
    ev[410]=QC[0]*ev[200]+WQ[0]*ev[230]+eta2*(ev[65]-re*ev[75])
            +3.e0*ze2*ev[152];
    ev[411]=QC[1]*ev[201]+WQ[1]*ev[231]+eta2*(ev[65]-re*ev[75]);
    ev[412]=QC[2]*ev[202]+WQ[2]*ev[232]+eta2*(ev[65]-re*ev[75]);
    ev[413]=QC[0]*ev[201]+WQ[0]*ev[231]+3.e0*ze2*ev[153];
    ev[414]=QC[0]*ev[202]+WQ[0]*ev[232]+3.e0*ze2*ev[154];
    ev[415]=QC[1]*ev[202]+WQ[1]*ev[232];
    ev[416]=QC[0]*ev[203]+WQ[0]*ev[233]+eta2*(ev[66]-re*ev[76]);
    ev[417]=QC[1]*ev[204]+WQ[1]*ev[234]+eta2*(ev[66]-re*ev[76])
            +3.e0*ze2*ev[156];
    ev[418]=QC[2]*ev[205]+WQ[2]*ev[235]+eta2*(ev[66]-re*ev[76]);
    ev[419]=QC[0]*ev[204]+WQ[0]*ev[234];
    ev[420]=QC[0]*ev[205]+WQ[0]*ev[235];
    ev[421]=QC[1]*ev[205]+WQ[1]*ev[235]+3.e0*ze2*ev[157];
    ev[422]=QC[0]*ev[206]+WQ[0]*ev[236]+eta2*(ev[67]-re*ev[77]);
    ev[423]=QC[1]*ev[207]+WQ[1]*ev[237]+eta2*(ev[67]-re*ev[77]);
    ev[424]=QC[2]*ev[208]+WQ[2]*ev[238]+eta2*(ev[67]-re*ev[77])
            +3.e0*ze2*ev[160];
    ev[425]=QC[0]*ev[207]+WQ[0]*ev[237];
    ev[426]=QC[0]*ev[208]+WQ[0]*ev[238];
    ev[427]=QC[1]*ev[208]+WQ[1]*ev[238];
    ev[428]=QC[0]*ev[209]+WQ[0]*ev[239]+eta2*(ev[68]-re*ev[78])
            +2.e0*ze2*ev[161];
    ev[429]=QC[1]*ev[210]+WQ[1]*ev[240]+eta2*(ev[68]-re*ev[78])
            +     ze2*ev[153];
    ev[430]=QC[2]*ev[211]+WQ[2]*ev[241]+eta2*(ev[68]-re*ev[78]);
    ev[431]=QC[0]*ev[210]+WQ[0]*ev[240]+2.e0*ze2*ev[162];
    ev[432]=QC[0]*ev[211]+WQ[0]*ev[241]+2.e0*ze2*ev[163];
    ev[433]=QC[1]*ev[211]+WQ[1]*ev[241]+     ze2*ev[154];
    ev[434]=QC[0]*ev[212]+WQ[0]*ev[242]+eta2*(ev[69]-re*ev[79])
            +2.e0*ze2*ev[164];
    ev[435]=QC[1]*ev[213]+WQ[1]*ev[243]+eta2*(ev[69]-re*ev[79]);
    ev[436]=QC[2]*ev[214]+WQ[2]*ev[244]+eta2*(ev[69]-re*ev[79])
            +     ze2*ev[154];
    ev[437]=QC[0]*ev[213]+WQ[0]*ev[243]+2.e0*ze2*ev[165];
    ev[438]=QC[0]*ev[214]+WQ[0]*ev[244]+2.e0*ze2*ev[166];
    ev[439]=QC[1]*ev[214]+WQ[1]*ev[244];
    ev[440]=QC[0]*ev[215]+WQ[0]*ev[245]+eta2*(ev[70]-re*ev[80])
            +     ze2*ev[155];
    ev[441]=QC[1]*ev[216]+WQ[1]*ev[246]+eta2*(ev[70]-re*ev[80])
            +2.e0*ze2*ev[162];
    ev[442]=QC[2]*ev[217]+WQ[2]*ev[247]+eta2*(ev[70]-re*ev[80]);
    ev[443]=QC[0]*ev[216]+WQ[0]*ev[246]+     ze2*ev[156];
    ev[444]=QC[0]*ev[217]+WQ[0]*ev[247]+     ze2*ev[157];
    ev[445]=QC[1]*ev[217]+WQ[1]*ev[247]+2.e0*ze2*ev[163];
    ev[446]=QC[0]*ev[218]+WQ[0]*ev[248]+eta2*(ev[71]-re*ev[81])
            +     ze2*ev[158];
    ev[447]=QC[1]*ev[219]+WQ[1]*ev[249]+eta2*(ev[71]-re*ev[81]);
    ev[448]=QC[2]*ev[220]+WQ[2]*ev[250]+eta2*(ev[71]-re*ev[81])
            +2.e0*ze2*ev[166];
    ev[449]=QC[0]*ev[219]+WQ[0]*ev[249]+     ze2*ev[159];
    ev[450]=QC[0]*ev[220]+WQ[0]*ev[250]+     ze2*ev[160];
    ev[451]=QC[1]*ev[220]+WQ[1]*ev[250];
    ev[452]=QC[0]*ev[221]+WQ[0]*ev[251]+eta2*(ev[72]-re*ev[82])
            +     ze2*ev[167];
    ev[453]=QC[1]*ev[222]+WQ[1]*ev[252]+eta2*(ev[72]-re*ev[82])
            +     ze2*ev[165];
    ev[454]=QC[2]*ev[223]+WQ[2]*ev[253]+eta2*(ev[72]-re*ev[82])
            +     ze2*ev[163];
    ev[455]=QC[0]*ev[222]+WQ[0]*ev[252]+     ze2*ev[168];
    ev[456]=QC[0]*ev[223]+WQ[0]*ev[253]+     ze2*ev[169];
    ev[457]=QC[1]*ev[223]+WQ[1]*ev[253]+     ze2*ev[166];
    ev[458]=QC[0]*ev[224]+WQ[0]*ev[254]+eta2*(ev[73]-re*ev[83]);
    ev[459]=QC[1]*ev[225]+WQ[1]*ev[255]+eta2*(ev[73]-re*ev[83])
            +2.e0*ze2*ev[168];
    ev[460]=QC[2]*ev[226]+WQ[2]*ev[256]+eta2*(ev[73]-re*ev[83])
            +     ze2*ev[157];
    ev[461]=QC[0]*ev[225]+WQ[0]*ev[255];
    ev[462]=QC[0]*ev[226]+WQ[0]*ev[256];
    ev[463]=QC[1]*ev[226]+WQ[1]*ev[256]+2.e0*ze2*ev[169];
    ev[464]=QC[0]*ev[227]+WQ[0]*ev[257]+eta2*(ev[74]-re*ev[84]);
    ev[465]=QC[1]*ev[228]+WQ[1]*ev[258]+eta2*(ev[74]-re*ev[84])
            +     ze2*ev[159];
    ev[466]=QC[2]*ev[229]+WQ[2]*ev[259]+eta2*(ev[74]-re*ev[84])
            +2.e0*ze2*ev[169];
    ev[467]=QC[0]*ev[228]+WQ[0]*ev[258];
    ev[468]=QC[0]*ev[229]+WQ[0]*ev[259];
    ev[469]=QC[1]*ev[229]+WQ[1]*ev[259]+     ze2*ev[160];
    // (ds|fs) m=[0,0]
    ev[470]=QC[0]*ev[278]+WQ[0]*ev[314]+2.e0*eta2*(ev[116]-re*ev[134])
            +2.e0*ze2*ev[260];
    ev[471]=QC[1]*ev[279]+WQ[1]*ev[315]+2.e0*eta2*(ev[117]-re*ev[135]);
    ev[472]=QC[2]*ev[280]+WQ[2]*ev[316]+2.e0*eta2*(ev[118]-re*ev[136]);
    ev[473]=QC[1]*ev[278]+WQ[1]*ev[314];
    ev[474]=QC[2]*ev[278]+WQ[2]*ev[314];
    ev[475]=QC[0]*ev[279]+WQ[0]*ev[315]+2.e0*ze2*ev[261];
    ev[476]=QC[0]*ev[280]+WQ[0]*ev[316]+2.e0*ze2*ev[262];
    ev[477]=QC[0]*ev[283]+WQ[0]*ev[319]+2.e0*ze2*ev[265];
    ev[478]=QC[2]*ev[279]+WQ[2]*ev[315];
    ev[479]=QC[1]*ev[280]+WQ[1]*ev[316];
    ev[480]=QC[0]*ev[284]+WQ[0]*ev[320]+2.e0*eta2*(ev[119]-re*ev[137]);
    ev[481]=QC[1]*ev[285]+WQ[1]*ev[321]+2.e0*eta2*(ev[120]-re*ev[138])
            +2.e0*ze2*ev[267];
    ev[482]=QC[2]*ev[286]+WQ[2]*ev[322]+2.e0*eta2*(ev[121]-re*ev[139]);
    ev[483]=QC[1]*ev[284]+WQ[1]*ev[320]+2.e0*ze2*ev[266];
    ev[484]=QC[2]*ev[284]+WQ[2]*ev[320];
    ev[485]=QC[0]*ev[285]+WQ[0]*ev[321];
    ev[486]=QC[0]*ev[286]+WQ[0]*ev[322];
    ev[487]=QC[0]*ev[289]+WQ[0]*ev[325];
    ev[488]=QC[2]*ev[285]+WQ[2]*ev[321];
    ev[489]=QC[1]*ev[286]+WQ[1]*ev[322]+2.e0*ze2*ev[268];
    ev[490]=QC[0]*ev[290]+WQ[0]*ev[326]+2.e0*eta2*(ev[122]-re*ev[140]);
    ev[491]=QC[1]*ev[291]+WQ[1]*ev[327]+2.e0*eta2*(ev[123]-re*ev[141]);
    ev[492]=QC[2]*ev[292]+WQ[2]*ev[328]+2.e0*eta2*(ev[124]-re*ev[142])
            +2.e0*ze2*ev[274];
    ev[493]=QC[1]*ev[290]+WQ[1]*ev[326];
    ev[494]=QC[2]*ev[290]+WQ[2]*ev[326]+2.e0*ze2*ev[272];
    ev[495]=QC[0]*ev[291]+WQ[0]*ev[327];
    ev[496]=QC[0]*ev[292]+WQ[0]*ev[328];
    ev[497]=QC[0]*ev[295]+WQ[0]*ev[331];
    ev[498]=QC[2]*ev[291]+WQ[2]*ev[327]+2.e0*ze2*ev[273];
    ev[499]=QC[1]*ev[292]+WQ[1]*ev[328];
    ev[500]=QC[0]*ev[296]+WQ[0]*ev[332]+2.e0*eta2*(ev[125]-re*ev[143])
            +     ze2*ev[266];
    ev[501]=QC[1]*ev[297]+WQ[1]*ev[333]+2.e0*eta2*(ev[126]-re*ev[144])
            +     ze2*ev[261];
    ev[502]=QC[2]*ev[298]+WQ[2]*ev[334]+2.e0*eta2*(ev[127]-re*ev[145]);
    ev[503]=QC[1]*ev[296]+WQ[1]*ev[332]+     ze2*ev[260];
    ev[504]=QC[2]*ev[296]+WQ[2]*ev[332];
    ev[505]=QC[0]*ev[297]+WQ[0]*ev[333]+     ze2*ev[267];
    ev[506]=QC[0]*ev[298]+WQ[0]*ev[334]+     ze2*ev[268];
    ev[507]=QC[0]*ev[301]+WQ[0]*ev[337]+     ze2*ev[271];
    ev[508]=QC[2]*ev[297]+WQ[2]*ev[333];
    ev[509]=QC[1]*ev[298]+WQ[1]*ev[334]+     ze2*ev[262];
    ev[510]=QC[0]*ev[302]+WQ[0]*ev[338]+2.e0*eta2*(ev[128]-re*ev[146])
            +     ze2*ev[272];
    ev[511]=QC[1]*ev[303]+WQ[1]*ev[339]+2.e0*eta2*(ev[129]-re*ev[147]);
    ev[512]=QC[2]*ev[304]+WQ[2]*ev[340]+2.e0*eta2*(ev[130]-re*ev[148])
            +     ze2*ev[262];
    ev[513]=QC[1]*ev[302]+WQ[1]*ev[338];
    ev[514]=QC[2]*ev[302]+WQ[2]*ev[338]+     ze2*ev[260];
    ev[515]=QC[0]*ev[303]+WQ[0]*ev[339]+     ze2*ev[273];
    ev[516]=QC[0]*ev[304]+WQ[0]*ev[340]+     ze2*ev[274];
    ev[517]=QC[0]*ev[307]+WQ[0]*ev[343]+     ze2*ev[277];
    ev[518]=QC[2]*ev[303]+WQ[2]*ev[339]+     ze2*ev[261];
    ev[519]=QC[1]*ev[304]+WQ[1]*ev[340];
    ev[520]=QC[0]*ev[308]+WQ[0]*ev[344]+2.e0*eta2*(ev[131]-re*ev[149]);
    ev[521]=QC[1]*ev[309]+WQ[1]*ev[345]+2.e0*eta2*(ev[132]-re*ev[150])
            +     ze2*ev[273];
    ev[522]=QC[2]*ev[310]+WQ[2]*ev[346]+2.e0*eta2*(ev[133]-re*ev[151])
            +     ze2*ev[268];
    ev[523]=QC[1]*ev[308]+WQ[1]*ev[344]+     ze2*ev[272];
    ev[524]=QC[2]*ev[308]+WQ[2]*ev[344]+     ze2*ev[266];
    ev[525]=QC[0]*ev[309]+WQ[0]*ev[345];
    ev[526]=QC[0]*ev[310]+WQ[0]*ev[346];
    ev[527]=QC[0]*ev[313]+WQ[0]*ev[349];
    ev[528]=QC[2]*ev[309]+WQ[2]*ev[345]+     ze2*ev[267];
    ev[529]=QC[1]*ev[310]+WQ[1]*ev[346]+     ze2*ev[274];
    // (fs|fs) m=[0,0]
    ev[530]=QC[0]*ev[350]+WQ[0]*ev[410]+2.e0*eta2*(ev[170]-re*ev[200])
            +3.e0*ze2*ev[314];
    ev[531]=QC[1]*ev[351]+WQ[1]*ev[411]+2.e0*eta2*(ev[171]-re*ev[201]);
    ev[532]=QC[2]*ev[352]+WQ[2]*ev[412]+2.e0*eta2*(ev[172]-re*ev[202]);
    ev[533]=QC[1]*ev[350]+WQ[1]*ev[410];
    ev[534]=QC[2]*ev[350]+WQ[2]*ev[410];
    ev[535]=QC[0]*ev[351]+WQ[0]*ev[411]+3.e0*ze2*ev[315];
    ev[536]=QC[0]*ev[352]+WQ[0]*ev[412]+3.e0*ze2*ev[316];
    ev[537]=QC[0]*ev[355]+WQ[0]*ev[415]+3.e0*ze2*ev[319];
    ev[538]=QC[2]*ev[351]+WQ[2]*ev[411];
    ev[539]=QC[1]*ev[352]+WQ[1]*ev[412];
    ev[540]=QC[0]*ev[356]+WQ[0]*ev[416]+2.e0*eta2*(ev[173]-re*ev[203]);
    ev[541]=QC[1]*ev[357]+WQ[1]*ev[417]+2.e0*eta2*(ev[174]-re*ev[204])
            +3.e0*ze2*ev[321];
    ev[542]=QC[2]*ev[358]+WQ[2]*ev[418]+2.e0*eta2*(ev[175]-re*ev[205]);
    ev[543]=QC[1]*ev[356]+WQ[1]*ev[416]+3.e0*ze2*ev[320];
    ev[544]=QC[2]*ev[356]+WQ[2]*ev[416];
    ev[545]=QC[0]*ev[357]+WQ[0]*ev[417];
    ev[546]=QC[0]*ev[358]+WQ[0]*ev[418];
    ev[547]=QC[0]*ev[361]+WQ[0]*ev[421];
    ev[548]=QC[2]*ev[357]+WQ[2]*ev[417];
    ev[549]=QC[1]*ev[358]+WQ[1]*ev[418]+3.e0*ze2*ev[322];
    ev[550]=QC[0]*ev[362]+WQ[0]*ev[422]+2.e0*eta2*(ev[176]-re*ev[206]);
    ev[551]=QC[1]*ev[363]+WQ[1]*ev[423]+2.e0*eta2*(ev[177]-re*ev[207]);
    ev[552]=QC[2]*ev[364]+WQ[2]*ev[424]+2.e0*eta2*(ev[178]-re*ev[208])
            +3.e0*ze2*ev[328];
    ev[553]=QC[1]*ev[362]+WQ[1]*ev[422];
    ev[554]=QC[2]*ev[362]+WQ[2]*ev[422]+3.e0*ze2*ev[326];
    ev[555]=QC[0]*ev[363]+WQ[0]*ev[423];
    ev[556]=QC[0]*ev[364]+WQ[0]*ev[424];
    ev[557]=QC[0]*ev[367]+WQ[0]*ev[427];
    ev[558]=QC[2]*ev[363]+WQ[2]*ev[423]+3.e0*ze2*ev[327];
    ev[559]=QC[1]*ev[364]+WQ[1]*ev[424];
    ev[560]=QC[0]*ev[368]+WQ[0]*ev[428]+2.e0*eta2*(ev[179]-re*ev[209])
            +2.e0*ze2*ev[332];
    ev[561]=QC[1]*ev[369]+WQ[1]*ev[429]+2.e0*eta2*(ev[180]-re*ev[210])
            +     ze2*ev[315];
    ev[562]=QC[2]*ev[370]+WQ[2]*ev[430]+2.e0*eta2*(ev[181]-re*ev[211]);
    ev[563]=QC[1]*ev[368]+WQ[1]*ev[428]+     ze2*ev[314];
    ev[564]=QC[2]*ev[368]+WQ[2]*ev[428];
    ev[565]=QC[0]*ev[369]+WQ[0]*ev[429]+2.e0*ze2*ev[333];
    ev[566]=QC[0]*ev[370]+WQ[0]*ev[430]+2.e0*ze2*ev[334];
    ev[567]=QC[0]*ev[373]+WQ[0]*ev[433]+2.e0*ze2*ev[337];
    ev[568]=QC[2]*ev[369]+WQ[2]*ev[429];
    ev[569]=QC[1]*ev[370]+WQ[1]*ev[430]+     ze2*ev[316];
    ev[570]=QC[0]*ev[374]+WQ[0]*ev[434]+2.e0*eta2*(ev[182]-re*ev[212])
            +2.e0*ze2*ev[338];
    ev[571]=QC[1]*ev[375]+WQ[1]*ev[435]+2.e0*eta2*(ev[183]-re*ev[213]);
    ev[572]=QC[2]*ev[376]+WQ[2]*ev[436]+2.e0*eta2*(ev[184]-re*ev[214])
            +     ze2*ev[316];
    ev[573]=QC[1]*ev[374]+WQ[1]*ev[434];
    ev[574]=QC[2]*ev[374]+WQ[2]*ev[434]+     ze2*ev[314];
    ev[575]=QC[0]*ev[375]+WQ[0]*ev[435]+2.e0*ze2*ev[339];
    ev[576]=QC[0]*ev[376]+WQ[0]*ev[436]+2.e0*ze2*ev[340];
    ev[577]=QC[0]*ev[379]+WQ[0]*ev[439]+2.e0*ze2*ev[343];
    ev[578]=QC[2]*ev[375]+WQ[2]*ev[435]+     ze2*ev[315];
    ev[579]=QC[1]*ev[376]+WQ[1]*ev[436];
    ev[580]=QC[0]*ev[380]+WQ[0]*ev[440]+2.e0*eta2*(ev[185]-re*ev[215])
            +     ze2*ev[320];
    ev[581]=QC[1]*ev[381]+WQ[1]*ev[441]+2.e0*eta2*(ev[186]-re*ev[216])
            +2.e0*ze2*ev[333];
    ev[582]=QC[2]*ev[382]+WQ[2]*ev[442]+2.e0*eta2*(ev[187]-re*ev[217]);
    ev[583]=QC[1]*ev[380]+WQ[1]*ev[440]+2.e0*ze2*ev[332];
    ev[584]=QC[2]*ev[380]+WQ[2]*ev[440];
    ev[585]=QC[0]*ev[381]+WQ[0]*ev[441]+     ze2*ev[321];
    ev[586]=QC[0]*ev[382]+WQ[0]*ev[442]+     ze2*ev[322];
    ev[587]=QC[0]*ev[385]+WQ[0]*ev[445]+     ze2*ev[325];
    ev[588]=QC[2]*ev[381]+WQ[2]*ev[441];
    ev[589]=QC[1]*ev[382]+WQ[1]*ev[442]+2.e0*ze2*ev[334];
    ev[590]=QC[0]*ev[386]+WQ[0]*ev[446]+2.e0*eta2*(ev[188]-re*ev[218])
            +     ze2*ev[326];
    ev[591]=QC[1]*ev[387]+WQ[1]*ev[447]+2.e0*eta2*(ev[189]-re*ev[219]);
    ev[592]=QC[2]*ev[388]+WQ[2]*ev[448]+2.e0*eta2*(ev[190]-re*ev[220])
            +2.e0*ze2*ev[340];
    ev[593]=QC[1]*ev[386]+WQ[1]*ev[446];
    ev[594]=QC[2]*ev[386]+WQ[2]*ev[446]+2.e0*ze2*ev[338];
    ev[595]=QC[0]*ev[387]+WQ[0]*ev[447]+     ze2*ev[327];
    ev[596]=QC[0]*ev[388]+WQ[0]*ev[448]+     ze2*ev[328];
    ev[597]=QC[0]*ev[391]+WQ[0]*ev[451]+     ze2*ev[331];
    ev[598]=QC[2]*ev[387]+WQ[2]*ev[447]+2.e0*ze2*ev[339];
    ev[599]=QC[1]*ev[388]+WQ[1]*ev[448];
    ev[600]=QC[0]*ev[392]+WQ[0]*ev[452]+2.e0*eta2*(ev[191]-re*ev[221])
            +     ze2*ev[344];
    ev[601]=QC[1]*ev[393]+WQ[1]*ev[453]+2.e0*eta2*(ev[192]-re*ev[222])
            +     ze2*ev[339];
    ev[602]=QC[2]*ev[394]+WQ[2]*ev[454]+2.e0*eta2*(ev[193]-re*ev[223])
            +     ze2*ev[334];
    ev[603]=QC[1]*ev[392]+WQ[1]*ev[452]+     ze2*ev[338];
    ev[604]=QC[2]*ev[392]+WQ[2]*ev[452]+     ze2*ev[332];
    ev[605]=QC[0]*ev[393]+WQ[0]*ev[453]+     ze2*ev[345];
    ev[606]=QC[0]*ev[394]+WQ[0]*ev[454]+     ze2*ev[346];
    ev[607]=QC[0]*ev[397]+WQ[0]*ev[457]+     ze2*ev[349];
    ev[608]=QC[2]*ev[393]+WQ[2]*ev[453]+     ze2*ev[333];
    ev[609]=QC[1]*ev[394]+WQ[1]*ev[454]+     ze2*ev[340];
    ev[610]=QC[0]*ev[398]+WQ[0]*ev[458]+2.e0*eta2*(ev[194]-re*ev[224]);
    ev[611]=QC[1]*ev[399]+WQ[1]*ev[459]+2.e0*eta2*(ev[195]-re*ev[225])
            +2.e0*ze2*ev[345];
    ev[612]=QC[2]*ev[400]+WQ[2]*ev[460]+2.e0*eta2*(ev[196]-re*ev[226])
            +     ze2*ev[322];
    ev[613]=QC[1]*ev[398]+WQ[1]*ev[458]+2.e0*ze2*ev[344];
    ev[614]=QC[2]*ev[398]+WQ[2]*ev[458]+     ze2*ev[320];
    ev[615]=QC[0]*ev[399]+WQ[0]*ev[459];
    ev[616]=QC[0]*ev[400]+WQ[0]*ev[460];
    ev[617]=QC[0]*ev[403]+WQ[0]*ev[463];
    ev[618]=QC[2]*ev[399]+WQ[2]*ev[459]+     ze2*ev[321];
    ev[619]=QC[1]*ev[400]+WQ[1]*ev[460]+2.e0*ze2*ev[346];
    ev[620]=QC[0]*ev[404]+WQ[0]*ev[464]+2.e0*eta2*(ev[197]-re*ev[227]);
    ev[621]=QC[1]*ev[405]+WQ[1]*ev[465]+2.e0*eta2*(ev[198]-re*ev[228])
            +     ze2*ev[327];
    ev[622]=QC[2]*ev[406]+WQ[2]*ev[466]+2.e0*eta2*(ev[199]-re*ev[229])
            +2.e0*ze2*ev[346];
    ev[623]=QC[1]*ev[404]+WQ[1]*ev[464]+     ze2*ev[326];
    ev[624]=QC[2]*ev[404]+WQ[2]*ev[464]+2.e0*ze2*ev[344];
    ev[625]=QC[0]*ev[405]+WQ[0]*ev[465];
    ev[626]=QC[0]*ev[406]+WQ[0]*ev[466];
    ev[627]=QC[0]*ev[409]+WQ[0]*ev[469];
    ev[628]=QC[2]*ev[405]+WQ[2]*ev[465]+2.e0*ze2*ev[345];
    ev[629]=QC[1]*ev[406]+WQ[1]*ev[466]+     ze2*ev[328];
}

__device__ void gpu_vrr_cint_dpdp( const double *ev, double *eh ) {
    int La=2, Lb=1, Lc=2, Ld=1;
    int i, ih, iv;
    // (DS|DS)
#pragma unroll
    for ( i=0, iv=278, ih=0; i<36; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (DS|FS)
#pragma unroll
    for ( i=0, iv=470, ih=36; i<60; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|DS)
#pragma unroll
    for ( i=0, iv=350, ih=96; i<60; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|FS)
#pragma unroll
    for ( i=0, iv=530, ih=156; i<100; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_dpdp(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[630], eh[868];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

//    DFACT = ofmo_getadd_dfact();
    gpu_hrr_clear_dpdp( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            re    = rho * eta;
            ze2 = rz * eta2;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
                WQ[i] = rz*QP[i] - QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_dpdp(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_dpdp( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_calc_dpdp( BA, DC, eh );
    gpu_hrr_coef_dpdp( eh, DINT );
}

#if 0
int ofmo_twoint_os_dpdp(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*6*3];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*3*6*3;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dpdp(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
#ifdef SORT_CSP
            int ijgekl = (ics>kcs);
            if (ics==kcs) ijgekl = (jcs>=lcs);
            if (!ijgekl) ipat = ( (ics==kcs && jcs<lcs) ? true : false);
#endif
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=6*3; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
#ifndef SORT_CSP
                                if ( IJ >= KL ) {
#else
                                if ((ijgekl&&IJ>=KL) || (!ijgekl&&KL>=IJ)) {
#endif
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_dpdp(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*3*6*3];
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*3*6*3;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*ofmo_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_dpdp(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
#ifdef SORT_CSP
            int ijgekl = (ics>kcs);
            if (ics==kcs) ijgekl = (jcs>=lcs);
            if (!ijgekl) ipat = ( (ics==kcs && jcs<lcs) ? true : false);
#endif
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=6*3; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
#ifndef SORT_CSP
                                if ( IJ >= KL ) {
#else
                                if ((ijgekl&&IJ>=KL) || (!ijgekl&&KL>=IJ)) {
#endif
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
// ddss
#include "cuda-twoint-core-os.h"

__device__ void gpu_hrr_clear_ddss( double *eh ) {
    int i;
    // (DS|SS)
#pragma unroll
    for ( i=0; i<(0+6); i++ ) eh[i] = 0.e0;
    // (FS|SS)
#pragma unroll
    for ( i=6; i<(6+10); i++ ) eh[i] = 0.e0;
    // (GS|SS)
#pragma unroll
    for ( i=16; i<(16+15); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_calc_ddss(
        const double BA[3], const double DC[3], double *eh ) {
    // (DP,SS)
    eh[  31] = eh[   6] - BA[0]*eh[   0];
    eh[  32] = eh[   9] - BA[1]*eh[   0];
    eh[  33] = eh[  10] - BA[2]*eh[   0];
    eh[  34] = eh[  11] - BA[0]*eh[   1];
    eh[  35] = eh[   7] - BA[1]*eh[   1];
    eh[  36] = eh[  14] - BA[2]*eh[   1];
    eh[  37] = eh[  12] - BA[0]*eh[   2];
    eh[  38] = eh[  15] - BA[1]*eh[   2];
    eh[  39] = eh[   8] - BA[2]*eh[   2];
    eh[  40] = eh[   9] - BA[0]*eh[   3];
    eh[  41] = eh[  11] - BA[1]*eh[   3];
    eh[  42] = eh[  13] - BA[2]*eh[   3];
    eh[  43] = eh[  10] - BA[0]*eh[   4];
    eh[  44] = eh[  13] - BA[1]*eh[   4];
    eh[  45] = eh[  12] - BA[2]*eh[   4];
    eh[  46] = eh[  13] - BA[0]*eh[   5];
    eh[  47] = eh[  14] - BA[1]*eh[   5];
    eh[  48] = eh[  15] - BA[2]*eh[   5];
    // (FP,SS)
    eh[  49] = eh[  16] - BA[0]*eh[   6];
    eh[  50] = eh[  19] - BA[1]*eh[   6];
    eh[  51] = eh[  20] - BA[2]*eh[   6];
    eh[  52] = eh[  24] - BA[0]*eh[   7];
    eh[  53] = eh[  17] - BA[1]*eh[   7];
    eh[  54] = eh[  28] - BA[2]*eh[   7];
    eh[  55] = eh[  25] - BA[0]*eh[   8];
    eh[  56] = eh[  29] - BA[1]*eh[   8];
    eh[  57] = eh[  18] - BA[2]*eh[   8];
    eh[  58] = eh[  19] - BA[0]*eh[   9];
    eh[  59] = eh[  21] - BA[1]*eh[   9];
    eh[  60] = eh[  23] - BA[2]*eh[   9];
    eh[  61] = eh[  20] - BA[0]*eh[  10];
    eh[  62] = eh[  23] - BA[1]*eh[  10];
    eh[  63] = eh[  22] - BA[2]*eh[  10];
    eh[  64] = eh[  21] - BA[0]*eh[  11];
    eh[  65] = eh[  24] - BA[1]*eh[  11];
    eh[  66] = eh[  26] - BA[2]*eh[  11];
    eh[  67] = eh[  22] - BA[0]*eh[  12];
    eh[  68] = eh[  27] - BA[1]*eh[  12];
    eh[  69] = eh[  25] - BA[2]*eh[  12];
    eh[  70] = eh[  23] - BA[0]*eh[  13];
    eh[  71] = eh[  26] - BA[1]*eh[  13];
    eh[  72] = eh[  27] - BA[2]*eh[  13];
    eh[  73] = eh[  26] - BA[0]*eh[  14];
    eh[  74] = eh[  28] - BA[1]*eh[  14];
    eh[  75] = eh[  30] - BA[2]*eh[  14];
    eh[  76] = eh[  27] - BA[0]*eh[  15];
    eh[  77] = eh[  30] - BA[1]*eh[  15];
    eh[  78] = eh[  29] - BA[2]*eh[  15];
    // (DD,SS)
    eh[  79] = eh[  49] - BA[0]*eh[  31];
    eh[  80] = eh[  59] - BA[1]*eh[  32];
    eh[  81] = eh[  63] - BA[2]*eh[  33];
    eh[  82] = eh[  50] - BA[0]*eh[  32];
    eh[  83] = eh[  51] - BA[0]*eh[  33];
    eh[  84] = eh[  60] - BA[1]*eh[  33];
    eh[  85] = eh[  64] - BA[0]*eh[  34];
    eh[  86] = eh[  53] - BA[1]*eh[  35];
    eh[  87] = eh[  75] - BA[2]*eh[  36];
    eh[  88] = eh[  65] - BA[0]*eh[  35];
    eh[  89] = eh[  66] - BA[0]*eh[  36];
    eh[  90] = eh[  54] - BA[1]*eh[  36];
    eh[  91] = eh[  67] - BA[0]*eh[  37];
    eh[  92] = eh[  77] - BA[1]*eh[  38];
    eh[  93] = eh[  57] - BA[2]*eh[  39];
    eh[  94] = eh[  68] - BA[0]*eh[  38];
    eh[  95] = eh[  69] - BA[0]*eh[  39];
    eh[  96] = eh[  78] - BA[1]*eh[  39];
    eh[  97] = eh[  58] - BA[0]*eh[  40];
    eh[  98] = eh[  65] - BA[1]*eh[  41];
    eh[  99] = eh[  72] - BA[2]*eh[  42];
    eh[ 100] = eh[  59] - BA[0]*eh[  41];
    eh[ 101] = eh[  60] - BA[0]*eh[  42];
    eh[ 102] = eh[  66] - BA[1]*eh[  42];
    eh[ 103] = eh[  61] - BA[0]*eh[  43];
    eh[ 104] = eh[  71] - BA[1]*eh[  44];
    eh[ 105] = eh[  69] - BA[2]*eh[  45];
    eh[ 106] = eh[  62] - BA[0]*eh[  44];
    eh[ 107] = eh[  63] - BA[0]*eh[  45];
    eh[ 108] = eh[  72] - BA[1]*eh[  45];
    eh[ 109] = eh[  70] - BA[0]*eh[  46];
    eh[ 110] = eh[  74] - BA[1]*eh[  47];
    eh[ 111] = eh[  78] - BA[2]*eh[  48];
    eh[ 112] = eh[  71] - BA[0]*eh[  47];
    eh[ 113] = eh[  72] - BA[0]*eh[  48];
    eh[ 114] = eh[  75] - BA[1]*eh[  48];
    // HRR for (XX|XX)-type integral (center CD)
}

__device__ void gpu_hrr_coef_ddss(
        const double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix, iy;
    double coef_a, coef_ab, coef_abc;
    ix = 79;
    iy = 0;

#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = LDG(DFACT[iao]);
#pragma unroll
        for ( j=0, jao=4; j<6; j++, jao++ ) {
            coef_ab = coef_a * LDG(DFACT[jao]);
            coef_abc = coef_ab;
            DINT[iy] = coef_abc * eh[ix];
            iy++;
            ix++;
        }
    }
}

__device__ void gpu_vrr_calc_ddss(
        const double T, const double cssss,
        const double zeta2, const double eta2, const double ze2,
        const double rz, const double re,
        const double PA[3], const double WP[3],
        const double QC[3], const double WQ[3],
        double *ev ) {
    // (ss|ss) m=0,4
    //fmt( &ev[0], 4, T, cssss );
    //OFMO_FMT( &ev[0], 4, T, cssss );
#if   CUDA_FMT_M == 3
    gpu_fmt4_method3( T, cssss, ev );
#elif CUDA_FMT_M == 2
    gpu_fmt4_method2( T, cssss, ev );
#elif CUDA_FMT_M == 1
    gpu_fmt4_method1( T, cssss, ev );
#else
    gpu_fmt4( ev, T, cssss );
#endif
    // (ps|ss) m=0,3
    ev[ 5]=PA[0]*ev[0]+WP[0]*ev[1];
    ev[ 6]=PA[1]*ev[0]+WP[1]*ev[1];
    ev[ 7]=PA[2]*ev[0]+WP[2]*ev[1];
    ev[ 8]=PA[0]*ev[1]+WP[0]*ev[2];
    ev[ 9]=PA[1]*ev[1]+WP[1]*ev[2];
    ev[10]=PA[2]*ev[1]+WP[2]*ev[2];
    ev[11]=PA[0]*ev[2]+WP[0]*ev[3];
    ev[12]=PA[1]*ev[2]+WP[1]*ev[3];
    ev[13]=PA[2]*ev[2]+WP[2]*ev[3];
    ev[14]=PA[0]*ev[3]+WP[0]*ev[4];
    ev[15]=PA[1]*ev[3]+WP[1]*ev[4];
    ev[16]=PA[2]*ev[3]+WP[2]*ev[4];
    // (ds|ss) m=0,2
    ev[17]=PA[0]*ev[ 5]+WP[0]*ev[ 8]+zeta2*(ev[0]-rz*ev[1]);
    ev[18]=PA[1]*ev[ 6]+WP[1]*ev[ 9]+zeta2*(ev[0]-rz*ev[1]);
    ev[19]=PA[2]*ev[ 7]+WP[2]*ev[10]+zeta2*(ev[0]-rz*ev[1]);
    ev[20]=PA[0]*ev[ 6]+WP[0]*ev[ 9];
    ev[21]=PA[0]*ev[ 7]+WP[0]*ev[10];
    ev[22]=PA[1]*ev[ 7]+WP[1]*ev[10];
    ev[23]=PA[0]*ev[ 8]+WP[0]*ev[11]+zeta2*(ev[1]-rz*ev[2]);
    ev[24]=PA[1]*ev[ 9]+WP[1]*ev[12]+zeta2*(ev[1]-rz*ev[2]);
    ev[25]=PA[2]*ev[10]+WP[2]*ev[13]+zeta2*(ev[1]-rz*ev[2]);
    ev[26]=PA[0]*ev[ 9]+WP[0]*ev[12];
    ev[27]=PA[0]*ev[10]+WP[0]*ev[13];
    ev[28]=PA[1]*ev[10]+WP[1]*ev[13];
    ev[29]=PA[0]*ev[11]+WP[0]*ev[14]+zeta2*(ev[2]-rz*ev[3]);
    ev[30]=PA[1]*ev[12]+WP[1]*ev[15]+zeta2*(ev[2]-rz*ev[3]);
    ev[31]=PA[2]*ev[13]+WP[2]*ev[16]+zeta2*(ev[2]-rz*ev[3]);
    ev[32]=PA[0]*ev[12]+WP[0]*ev[15];
    ev[33]=PA[0]*ev[13]+WP[0]*ev[16];
    ev[34]=PA[1]*ev[13]+WP[1]*ev[16];
    // (fs|ss) m=0,1
    ev[35]=PA[0]*ev[17]+WP[0]*ev[23]+2.e0*zeta2*(ev[ 5]-rz*ev[ 8]);
    ev[36]=PA[1]*ev[18]+WP[1]*ev[24]+2.e0*zeta2*(ev[ 6]-rz*ev[ 9]);
    ev[37]=PA[2]*ev[19]+WP[2]*ev[25]+2.e0*zeta2*(ev[ 7]-rz*ev[10]);
    ev[38]=PA[1]*ev[17]+WP[1]*ev[23];
    ev[39]=PA[2]*ev[17]+WP[2]*ev[23];
    ev[40]=PA[0]*ev[18]+WP[0]*ev[24];
    ev[41]=PA[0]*ev[19]+WP[0]*ev[25];
    ev[42]=PA[0]*ev[22]+WP[0]*ev[28];
    ev[43]=PA[2]*ev[18]+WP[2]*ev[24];
    ev[44]=PA[1]*ev[19]+WP[1]*ev[25];
    ev[45]=PA[0]*ev[23]+WP[0]*ev[29]+2.e0*zeta2*(ev[ 8]-rz*ev[11]);
    ev[46]=PA[1]*ev[24]+WP[1]*ev[30]+2.e0*zeta2*(ev[ 9]-rz*ev[12]);
    ev[47]=PA[2]*ev[25]+WP[2]*ev[31]+2.e0*zeta2*(ev[10]-rz*ev[13]);
    ev[48]=PA[1]*ev[23]+WP[1]*ev[29];
    ev[49]=PA[2]*ev[23]+WP[2]*ev[29];
    ev[50]=PA[0]*ev[24]+WP[0]*ev[30];
    ev[51]=PA[0]*ev[25]+WP[0]*ev[31];
    ev[52]=PA[0]*ev[28]+WP[0]*ev[34];
    ev[53]=PA[2]*ev[24]+WP[2]*ev[30];
    ev[54]=PA[1]*ev[25]+WP[1]*ev[31];
    // (gs|ss) m=0,0
    ev[55]=PA[0]*ev[35]+WP[0]*ev[45]+3.e0*zeta2*(ev[17]-rz*ev[23]);
    ev[56]=PA[1]*ev[36]+WP[1]*ev[46]+3.e0*zeta2*(ev[18]-rz*ev[24]);
    ev[57]=PA[2]*ev[37]+WP[2]*ev[47]+3.e0*zeta2*(ev[19]-rz*ev[25]);
    ev[58]=PA[1]*ev[35]+WP[1]*ev[45];
    ev[59]=PA[2]*ev[35]+WP[2]*ev[45];
    ev[60]=PA[0]*ev[40]+WP[0]*ev[50]+     zeta2*(ev[18]-rz*ev[24]);
    ev[61]=PA[0]*ev[41]+WP[0]*ev[51]+     zeta2*(ev[19]-rz*ev[25]);
    ev[62]=PA[1]*ev[39]+WP[1]*ev[49];
    ev[63]=PA[0]*ev[36]+WP[0]*ev[46];
    ev[64]=PA[0]*ev[37]+WP[0]*ev[47];
    ev[65]=PA[0]*ev[43]+WP[0]*ev[53];
    ev[66]=PA[0]*ev[44]+WP[0]*ev[54];
    ev[67]=PA[2]*ev[36]+WP[2]*ev[46];
    ev[68]=PA[1]*ev[37]+WP[1]*ev[47];
    ev[69]=PA[1]*ev[44]+WP[1]*ev[54]+     zeta2*(ev[19]-rz*ev[25]);
}

__device__ void gpu_vrr_cint_ddss( const double *ev, double *eh ) {
    int La=2, Lb=2, Lc=0, Ld=0;
    int i, ih, iv;
    // (DS|SS)
#pragma unroll
    for ( i=0, iv=17, ih=0; i<6; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (FS|SS)
#pragma unroll
    for ( i=0, iv=35, ih=6; i<10; i++, iv++, ih++ ) eh[ih]+=ev[iv];
    // (GS|SS)
#pragma unroll
    for ( i=0, iv=55, ih=16; i<15; i++, iv++, ih++ ) eh[ih]+=ev[iv];
}

__device__ void gpu_twoint_core_os_ddss(
//        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *nijps, const double vzeta[], const double vdkab[],
        const double vxiza[], const double BA[3],
        const int *nklps, const double veta[], const double vdkcd[],
        const double vxizc[], const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, ze2, rz, re, PA[3], WP[3], QC[3], WQ[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double ev[70], eh[115];
//    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;

//    DFACT = ofmo_getadd_dfact();
    gpu_hrr_clear_ddss( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = LDG(vzeta[ijps]);
        dkab  = LDG(vdkab[ijps]);
        xiza  = LDG(vxiza[ijps]);
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = LDG(veta[klps]);
            dk   = dkab * LDG(vdkcd[klps]);
            xizc = LDG(vxizc[klps]);
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            sqrho = sqrt(1.e0/(zeta+eta));
            rho   = sqrho*sqrho;
            rz    = rho * zeta;
            ze2 = rz * eta * HALF;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                WP[i] = rz*QP[i];
            }
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_vrr_calc_ddss(
                    T, cssss, zeta2, eta2, ze2, rz, re, PA, WP, QC, WQ,
                    ev );
            gpu_vrr_cint_ddss( ev, eh );
        }	// for (klps)
    }	// for (ijps)
    gpu_hrr_calc_ddss( BA, DC, eh );
    gpu_hrr_coef_ddss( eh, DINT );
}

#if 0
int ofmo_twoint_os_ddss(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*6*1*1];
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*6*1*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }

    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_ddss(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<6; j++, jao++ ) {
                    if ( jao>iao ) { ix+=1*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<1; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }	// for (klcs)
    }	// for (ijcs)
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int ofmo_twoint_direct_os_ddss(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DINTEG[6*6*1*1];
    int mythread;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    mythread = omp_get_thread_num();
    if ( DFACT == NULL ) DFACT = ofmo_getadd_dfact();

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }

    max_nzeri -= 6*6*1*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }

    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < eps_ps4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            if ( val_ab*val_cd*ofmo_twoint_dmax6(ics,jcs,kcs,lcs) < eps_sch ) continue;
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            ofmo_twoint_core_os_ddss(
                    &La, &Lb, &Lc, &Ld,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd)||(ics==kcs && jcs>lcs) ? true : false );
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<6; j++, jao++ ) {
                    if ( jao>iao ) { ix+=1*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<1; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > eps_eri ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }	// l
                    }	// k
                }	// j
            }	// i
            if ( nzeri >= max_nzeri ) {
                ofmo_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }	// for (klcs)
        klcs = klcs0;
    }	// for (ijcs)
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // if 0
#include "cuda-twoint-core-rys.h"
#include "cuda-root.h"

__device__ void gpu_hrr_clear_rys_ppps( double *eh ) {
    int i;
    // (PS|PS)
#pragma unroll
    for ( i=0; i<(0+9); i++ ) eh[i] = 0.e0;
    // (DS|PS)
#pragma unroll
    for ( i=9; i<(9+18); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_coef_rys_ppps(
        double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix;
    double coef_a, coef_ab, coef_abc;
    double *th;
    th = &eh[27];
    ix = 0;
#pragma unroll
    for ( i=0, iao=1; i<3; i++, iao++ ) {
        coef_a = DFACT[iao];
#pragma unroll
        for ( j=0, jao=1; j<3; j++, jao++ ) {
            coef_ab = coef_a * DFACT[jao];
#pragma unroll
            for ( k=0, kao=1; k<3; k++, kao++ ) {
                coef_abc = coef_ab * DFACT[kao];
#pragma unroll
                for ( l=0, lao=0; l<1; l++, lao++ ) {
                    DINT[ix] = coef_abc * DFACT[lao] * th[ix];
                    ix++;
                }
            }
        }
    }
}

__device__ void gpu_hrr_calc_rys_ppps( double *eh,
        const double BA[3], const double DC[3] ) {
    // HRR for (XX|XS)-type integral (center AB)
    // (PP,PS)
    eh[  27] = eh[   9] - BA[0]*eh[   0];
    eh[  28] = eh[  10] - BA[0]*eh[   1];
    eh[  29] = eh[  11] - BA[0]*eh[   2];
    eh[  30] = eh[  18] - BA[1]*eh[   0];
    eh[  31] = eh[  19] - BA[1]*eh[   1];
    eh[  32] = eh[  20] - BA[1]*eh[   2];
    eh[  33] = eh[  21] - BA[2]*eh[   0];
    eh[  34] = eh[  22] - BA[2]*eh[   1];
    eh[  35] = eh[  23] - BA[2]*eh[   2];
    eh[  36] = eh[  18] - BA[0]*eh[   3];
    eh[  37] = eh[  19] - BA[0]*eh[   4];
    eh[  38] = eh[  20] - BA[0]*eh[   5];
    eh[  39] = eh[  12] - BA[1]*eh[   3];
    eh[  40] = eh[  13] - BA[1]*eh[   4];
    eh[  41] = eh[  14] - BA[1]*eh[   5];
    eh[  42] = eh[  24] - BA[2]*eh[   3];
    eh[  43] = eh[  25] - BA[2]*eh[   4];
    eh[  44] = eh[  26] - BA[2]*eh[   5];
    eh[  45] = eh[  21] - BA[0]*eh[   6];
    eh[  46] = eh[  22] - BA[0]*eh[   7];
    eh[  47] = eh[  23] - BA[0]*eh[   8];
    eh[  48] = eh[  24] - BA[1]*eh[   6];
    eh[  49] = eh[  25] - BA[1]*eh[   7];
    eh[  50] = eh[  26] - BA[1]*eh[   8];
    eh[  51] = eh[  15] - BA[2]*eh[   6];
    eh[  52] = eh[  16] - BA[2]*eh[   7];
    eh[  53] = eh[  17] - BA[2]*eh[   8];
}

__device__ void gpu_xyzint_rys_ppps(
        const double *F00, const double *B00, const double *B10,
        const double *B01, const double *C00, const double *CP00,
        double *xint, double *yint, double *zint ) {
    int Lab, Lcd;
    int m, m3, N, M, ix3, ix2, ix1, ix0, nroot;
    double C10[2], CP10[2], CP01[2], C01[2];
    // (0,0)
    xint[  0]=1.e0;
    yint[  0]=1.e0;
    zint[  0]=F00[0];
    xint[  1]=1.e0;
    yint[  1]=1.e0;
    zint[  1]=F00[1];
    // (1,0)
    xint[  4]=C00[ 0];
    yint[  4]=C00[ 1];
    zint[  4]=C00[ 2]*F00[0];
    xint[  5]=C00[ 3];
    yint[  5]=C00[ 4];
    zint[  5]=C00[ 5]*F00[1];
    // (0,1)
    xint[  2]=CP00[ 0];
    yint[  2]=CP00[ 1];
    zint[  2]=CP00[ 2]*F00[0];
    xint[  3]=CP00[ 3];
    yint[  3]=CP00[ 4];
    zint[  3]=CP00[ 5]*F00[1];
    // (1,1)
    xint[  6]=CP00[ 0]*xint[  4]+B00[0];
    yint[  6]=CP00[ 1]*yint[  4]+B00[0];
    zint[  6]=CP00[ 2]*zint[  4]+B00[0]*F00[0];
    xint[  7]=CP00[ 3]*xint[  5]+B00[1];
    yint[  7]=CP00[ 4]*yint[  5]+B00[1];
    zint[  7]=CP00[ 5]*zint[  5]+B00[1]*F00[1];
    // (N,0) and (N,1)
#pragma unroll
    for ( m=0; m<2; m++ ) {
        C10[m]  = 0.e0;
        CP10[m] = B00[m];
    }
    // (2,0)
    C10[0] += B10[0];
    xint[  8]=C00[ 0]*xint[  4]+C10[0]*xint[  0];
    yint[  8]=C00[ 1]*yint[  4]+C10[0]*yint[  0];
    zint[  8]=C00[ 2]*zint[  4]+C10[0]*zint[  0];
    C10[1] += B10[1];
    xint[  9]=C00[ 3]*xint[  5]+C10[1]*xint[  1];
    yint[  9]=C00[ 4]*yint[  5]+C10[1]*yint[  1];
    zint[  9]=C00[ 5]*zint[  5]+C10[1]*zint[  1];
    // (2,1)
    CP10[0] += B00[0];
    xint[ 10]=CP00[ 0]*xint[  8]+CP10[0]*xint[  4];
    yint[ 10]=CP00[ 1]*yint[  8]+CP10[0]*yint[  4];
    zint[ 10]=CP00[ 2]*zint[  8]+CP10[0]*zint[  4];
    CP10[1] += B00[1];
    xint[ 11]=CP00[ 3]*xint[  9]+CP10[1]*xint[  5];
    yint[ 11]=CP00[ 4]*yint[  9]+CP10[1]*yint[  5];
    zint[ 11]=CP00[ 5]*zint[  9]+CP10[1]*zint[  5];
}

__device__ void gpu_form_rys_ppps(
        const double *xint, const double *yint, const double *zint,
        double *eh ) {
    // (PS|PS)
    eh[   0] += xint[  6]*yint[  0]*zint[  0];
    eh[   0] += xint[  7]*yint[  1]*zint[  1];
    eh[   1] += xint[  4]*yint[  2]*zint[  0];
    eh[   1] += xint[  5]*yint[  3]*zint[  1];
    eh[   2] += xint[  4]*yint[  0]*zint[  2];
    eh[   2] += xint[  5]*yint[  1]*zint[  3];
    eh[   3] += xint[  2]*yint[  4]*zint[  0];
    eh[   3] += xint[  3]*yint[  5]*zint[  1];
    eh[   4] += xint[  0]*yint[  6]*zint[  0];
    eh[   4] += xint[  1]*yint[  7]*zint[  1];
    eh[   5] += xint[  0]*yint[  4]*zint[  2];
    eh[   5] += xint[  1]*yint[  5]*zint[  3];
    eh[   6] += xint[  2]*yint[  0]*zint[  4];
    eh[   6] += xint[  3]*yint[  1]*zint[  5];
    eh[   7] += xint[  0]*yint[  2]*zint[  4];
    eh[   7] += xint[  1]*yint[  3]*zint[  5];
    eh[   8] += xint[  0]*yint[  0]*zint[  6];
    eh[   8] += xint[  1]*yint[  1]*zint[  7];
    // (DS|PS)
    eh[   9] += xint[ 10]*yint[  0]*zint[  0];
    eh[   9] += xint[ 11]*yint[  1]*zint[  1];
    eh[  10] += xint[  8]*yint[  2]*zint[  0];
    eh[  10] += xint[  9]*yint[  3]*zint[  1];
    eh[  11] += xint[  8]*yint[  0]*zint[  2];
    eh[  11] += xint[  9]*yint[  1]*zint[  3];
    eh[  12] += xint[  2]*yint[  8]*zint[  0];
    eh[  12] += xint[  3]*yint[  9]*zint[  1];
    eh[  13] += xint[  0]*yint[ 10]*zint[  0];
    eh[  13] += xint[  1]*yint[ 11]*zint[  1];
    eh[  14] += xint[  0]*yint[  8]*zint[  2];
    eh[  14] += xint[  1]*yint[  9]*zint[  3];
    eh[  15] += xint[  2]*yint[  0]*zint[  8];
    eh[  15] += xint[  3]*yint[  1]*zint[  9];
    eh[  16] += xint[  0]*yint[  2]*zint[  8];
    eh[  16] += xint[  1]*yint[  3]*zint[  9];
    eh[  17] += xint[  0]*yint[  0]*zint[ 10];
    eh[  17] += xint[  1]*yint[  1]*zint[ 11];
    eh[  18] += xint[  6]*yint[  4]*zint[  0];
    eh[  18] += xint[  7]*yint[  5]*zint[  1];
    eh[  19] += xint[  4]*yint[  6]*zint[  0];
    eh[  19] += xint[  5]*yint[  7]*zint[  1];
    eh[  20] += xint[  4]*yint[  4]*zint[  2];
    eh[  20] += xint[  5]*yint[  5]*zint[  3];
    eh[  21] += xint[  6]*yint[  0]*zint[  4];
    eh[  21] += xint[  7]*yint[  1]*zint[  5];
    eh[  22] += xint[  4]*yint[  2]*zint[  4];
    eh[  22] += xint[  5]*yint[  3]*zint[  5];
    eh[  23] += xint[  4]*yint[  0]*zint[  6];
    eh[  23] += xint[  5]*yint[  1]*zint[  7];
    eh[  24] += xint[  2]*yint[  4]*zint[  4];
    eh[  24] += xint[  3]*yint[  5]*zint[  5];
    eh[  25] += xint[  0]*yint[  6]*zint[  4];
    eh[  25] += xint[  1]*yint[  7]*zint[  5];
    eh[  26] += xint[  0]*yint[  4]*zint[  6];
    eh[  26] += xint[  1]*yint[  5]*zint[  7];
}

__device__ void gpu_twoint_core_rys_ppps(
        const int *nijps, const double *vzeta, const double *vdkab,
        const double vxiza[], const double BA[3],
        const int *nklps, const double *veta, const double *vdkcd,
        const double *vxizc, const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, rz, PA[3], QC[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double C00[6], CP00[6], B00[2], B10[2], B01[2], F00[2];
    //double rrho, rze, W[13], U[13];
    double rrho, rze, W[2], U[2];
    double u2, duminv, dm2inv, dum;
    int m, m3;
    /*
    double *xint, *yint, *zint, *eh;
    xint = gpu_integ_getadd_xint( mythread );
    yint = gpu_integ_getadd_yint( mythread );
    zint = gpu_integ_getadd_zint( mythread );
    eh   = gpu_integ_getadd_eh( mythread );
    */
    double xint[12], yint[12], zint[12];
    double eh[54];

    gpu_hrr_clear_rys_ppps( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = vzeta[ijps];
        dkab  = vdkab[ijps];
        xiza  = vxiza[ijps];
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = veta[klps];
            dk   = dkab * vdkcd[klps];
            xizc = vxizc[klps];
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            rrho  = zeta + eta;
            rze   = zeta * eta;
            sqrho = sqrt(1.e0/rrho);
            rho   = sqrho * sqrho;
            rz    = rho * zeta;
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_calc_root( 2, T, U, W );
#pragma unroll
            for ( m=m3=0; m<2; m++, m3+=3 ) {
                u2     = rho * U[m];
                F00[m] = cssss * W[m];
                duminv = 1.e0 / ( 1.e0 + rrho * u2 );
                dm2inv = 0.5e0 * duminv;
                B00[m] = dm2inv * rze * u2;
                B10[m] = dm2inv * ( zeta + rze*u2 );
                B01[m] = dm2inv * ( eta  + rze*u2 );
                dum    = zeta * u2 * duminv;
#pragma unroll
                for ( i=0; i<3; i++ ) C00[m3+i]  = PA[i] + dum * QP[i];
                dum    = eta * u2 * duminv;
#pragma unroll
                for ( i=0; i<3; i++ ) CP00[m3+i] = QC[i] - dum * QP[i];
            }
            gpu_xyzint_rys_ppps( F00, B00, B10, B01, C00, CP00,
                     xint, yint, zint );
            gpu_form_rys_ppps( xint, yint, zint, eh );
        }
    }
    gpu_hrr_calc_rys_ppps( eh, BA, DC );
    gpu_hrr_coef_rys_ppps( eh, DINT );
}

#if 0
int gpu_twoint_rys_ppps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *shel_atm, const int *shel_ini,
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double *DINTEG;
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    DFACT = gpu_getadd_dfact();
    mythread = omp_get_thread_num();
    DINTEG = gpu_integ_getadd_eri( mythread );
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 3*3*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }
    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_rys_ppps( mythread,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd) || (ics==kcs && jcs>lcs) ? true : false);
            for ( i=0, iao=iao0, ix=0; i<3; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }
                    }
                }
            }
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }
    }
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int gpu_twoint_direct_rys_ppps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *shel_atm, const int *shel_ini,
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double *DINTEG;
    int mythread;
    DFACT = gpu_getadd_dfact();
    mythread = omp_get_thread_num();
    DINTEG = gpu_integ_getadd_eri( mythread );
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }
    max_nzeri -= 3*3*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }
    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_rys_ppps( mythread,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd) || (ics==kcs && jcs>lcs) ? true : false);
            for ( i=0, iao=iao0, ix=0; i<3; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<3; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }
                    }
                }
            }
            if ( nzeri >= max_nzeri ) {
                gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }
        klcs = klcs0;
    }
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif
#include "cuda-twoint-core-rys.h"
#include "cuda-root.h"

__device__ void gpu_hrr_clear_rys_dsps( double *eh ) {
    int i;
    // (DS|PS)
#pragma unroll
    for ( i=0; i<(0+18); i++ ) eh[i] = 0.e0;
}

__device__ void gpu_hrr_coef_rys_dsps(
        double *eh, double *DINT ) {
    int i, j, k, l, iao, jao, kao, lao, ix;
    double coef_a, coef_ab, coef_abc;
    double *th;
    th = &eh[0];
    ix = 0;
#pragma unroll
    for ( i=0, iao=4; i<6; i++, iao++ ) {
        coef_a = DFACT[iao];
#pragma unroll
        for ( j=0, jao=0; j<1; j++, jao++ ) {
            coef_ab = coef_a * DFACT[jao];
#pragma unroll
            for ( k=0, kao=1; k<3; k++, kao++ ) {
                coef_abc = coef_ab * DFACT[kao];
#pragma unroll
                for ( l=0, lao=0; l<1; l++, lao++ ) {
                    DINT[ix] = coef_abc * DFACT[lao] * th[ix];
                    ix++;
                }
            }
        }
    }
}

__device__ void gpu_hrr_calc_rys_dsps( double *eh,
        const double BA[3], const double DC[3] ) {
    // HRR for (XX|XS)-type integral (center AB)
}

__device__ void gpu_xyzint_rys_dsps(
        const double *F00, const double *B00, const double *B10,
        const double *B01, const double *C00, const double *CP00,
        double *xint, double *yint, double *zint ) {
    int Lab, Lcd;
    int m, m3, N, M, ix3, ix2, ix1, ix0, nroot;
    double C10[2], CP10[2], CP01[2], C01[2];
    // (0,0)
    xint[  0]=1.e0;
    yint[  0]=1.e0;
    zint[  0]=F00[0];
    xint[  1]=1.e0;
    yint[  1]=1.e0;
    zint[  1]=F00[1];
    // (1,0)
    xint[  4]=C00[ 0];
    yint[  4]=C00[ 1];
    zint[  4]=C00[ 2]*F00[0];
    xint[  5]=C00[ 3];
    yint[  5]=C00[ 4];
    zint[  5]=C00[ 5]*F00[1];
    // (0,1)
    xint[  2]=CP00[ 0];
    yint[  2]=CP00[ 1];
    zint[  2]=CP00[ 2]*F00[0];
    xint[  3]=CP00[ 3];
    yint[  3]=CP00[ 4];
    zint[  3]=CP00[ 5]*F00[1];
    // (1,1)
    xint[  6]=CP00[ 0]*xint[  4]+B00[0];
    yint[  6]=CP00[ 1]*yint[  4]+B00[0];
    zint[  6]=CP00[ 2]*zint[  4]+B00[0]*F00[0];
    xint[  7]=CP00[ 3]*xint[  5]+B00[1];
    yint[  7]=CP00[ 4]*yint[  5]+B00[1];
    zint[  7]=CP00[ 5]*zint[  5]+B00[1]*F00[1];
    // (N,0) and (N,1)
#pragma unroll
    for ( m=0; m<2; m++ ) {
        C10[m]  = 0.e0;
        CP10[m] = B00[m];
    }
    // (2,0)
    C10[0] += B10[0];
    xint[  8]=C00[ 0]*xint[  4]+C10[0]*xint[  0];
    yint[  8]=C00[ 1]*yint[  4]+C10[0]*yint[  0];
    zint[  8]=C00[ 2]*zint[  4]+C10[0]*zint[  0];
    C10[1] += B10[1];
    xint[  9]=C00[ 3]*xint[  5]+C10[1]*xint[  1];
    yint[  9]=C00[ 4]*yint[  5]+C10[1]*yint[  1];
    zint[  9]=C00[ 5]*zint[  5]+C10[1]*zint[  1];
    // (2,1)
    CP10[0] += B00[0];
    xint[ 10]=CP00[ 0]*xint[  8]+CP10[0]*xint[  4];
    yint[ 10]=CP00[ 1]*yint[  8]+CP10[0]*yint[  4];
    zint[ 10]=CP00[ 2]*zint[  8]+CP10[0]*zint[  4];
    CP10[1] += B00[1];
    xint[ 11]=CP00[ 3]*xint[  9]+CP10[1]*xint[  5];
    yint[ 11]=CP00[ 4]*yint[  9]+CP10[1]*yint[  5];
    zint[ 11]=CP00[ 5]*zint[  9]+CP10[1]*zint[  5];
}

__device__ void gpu_form_rys_dsps(
        const double *xint, const double *yint, const double *zint,
        double *eh ) {
    // (DS|PS)
    eh[   0] += xint[ 10]*yint[  0]*zint[  0];
    eh[   0] += xint[ 11]*yint[  1]*zint[  1];
    eh[   1] += xint[  8]*yint[  2]*zint[  0];
    eh[   1] += xint[  9]*yint[  3]*zint[  1];
    eh[   2] += xint[  8]*yint[  0]*zint[  2];
    eh[   2] += xint[  9]*yint[  1]*zint[  3];
    eh[   3] += xint[  2]*yint[  8]*zint[  0];
    eh[   3] += xint[  3]*yint[  9]*zint[  1];
    eh[   4] += xint[  0]*yint[ 10]*zint[  0];
    eh[   4] += xint[  1]*yint[ 11]*zint[  1];
    eh[   5] += xint[  0]*yint[  8]*zint[  2];
    eh[   5] += xint[  1]*yint[  9]*zint[  3];
    eh[   6] += xint[  2]*yint[  0]*zint[  8];
    eh[   6] += xint[  3]*yint[  1]*zint[  9];
    eh[   7] += xint[  0]*yint[  2]*zint[  8];
    eh[   7] += xint[  1]*yint[  3]*zint[  9];
    eh[   8] += xint[  0]*yint[  0]*zint[ 10];
    eh[   8] += xint[  1]*yint[  1]*zint[ 11];
    eh[   9] += xint[  6]*yint[  4]*zint[  0];
    eh[   9] += xint[  7]*yint[  5]*zint[  1];
    eh[  10] += xint[  4]*yint[  6]*zint[  0];
    eh[  10] += xint[  5]*yint[  7]*zint[  1];
    eh[  11] += xint[  4]*yint[  4]*zint[  2];
    eh[  11] += xint[  5]*yint[  5]*zint[  3];
    eh[  12] += xint[  6]*yint[  0]*zint[  4];
    eh[  12] += xint[  7]*yint[  1]*zint[  5];
    eh[  13] += xint[  4]*yint[  2]*zint[  4];
    eh[  13] += xint[  5]*yint[  3]*zint[  5];
    eh[  14] += xint[  4]*yint[  0]*zint[  6];
    eh[  14] += xint[  5]*yint[  1]*zint[  7];
    eh[  15] += xint[  2]*yint[  4]*zint[  4];
    eh[  15] += xint[  3]*yint[  5]*zint[  5];
    eh[  16] += xint[  0]*yint[  6]*zint[  4];
    eh[  16] += xint[  1]*yint[  7]*zint[  5];
    eh[  17] += xint[  0]*yint[  4]*zint[  6];
    eh[  17] += xint[  1]*yint[  5]*zint[  7];
}

__device__ void gpu_twoint_core_rys_dsps(
        const int *nijps, const double *vzeta, const double *vdkab,
        const double vxiza[], const double BA[3],
        const int *nklps, const double *veta, const double *vdkcd,
        const double *vxizc, const double DC[3], const double AC[3],
        double *DINT ) {
    int ijps, klps, i;
    double cssss, zeta, dkab, xiza, eta, xizc, dk, T;
    double zeta2, eta2, rz, PA[3], QC[3];
    double PQ2, sqrho, rho, PC[3], QP[3];
    double C00[6], CP00[6], B00[2], B10[2], B01[2], F00[2];
    //double rrho, rze, W[13], U[13];
    double rrho, rze, W[2], U[2];
    double u2, duminv, dm2inv, dum;
    int m, m3;
    /*
    double *xint, *yint, *zint, *eh;
    xint = gpu_integ_getadd_xint( mythread );
    yint = gpu_integ_getadd_yint( mythread );
    zint = gpu_integ_getadd_zint( mythread );
    eh   = gpu_integ_getadd_eh( mythread );
    */
    double xint[12], yint[12], zint[12];
    double eh[18];

    gpu_hrr_clear_rys_dsps( eh );
    for ( ijps=0; ijps<(*nijps); ijps++ ) {
        zeta  = vzeta[ijps];
        dkab  = vdkab[ijps];
        xiza  = vxiza[ijps];
        zeta2 = HALF * zeta;
#pragma unroll
        for ( i=0; i<3; i++ ) {
            PC[i] = AC[i] + xiza*BA[i];
            PA[i] = xiza * BA[i];
        }
        for ( klps=0; klps<(*nklps); klps++ ) {
            eta  = veta[klps];
            dk   = dkab * vdkcd[klps];
            xizc = vxizc[klps];
            eta2 = HALF * eta;
            PQ2  = ZERO;
#pragma unroll
            for ( i=0; i<3; i++ ) {
                QC[i] = xizc*DC[i];
                QP[i] = xizc*DC[i] - PC[i];
                PQ2  += QP[i]*QP[i];
            }
            rrho  = zeta + eta;
            rze   = zeta * eta;
            sqrho = sqrt(1.e0/rrho);
            rho   = sqrho * sqrho;
            rz    = rho * zeta;
            T     = rho * PQ2;
            cssss = sqrho * dk;
            gpu_calc_root( 2, T, U, W );
#pragma unroll
            for ( m=m3=0; m<2; m++, m3+=3 ) {
                u2     = rho * U[m];
                F00[m] = cssss * W[m];
                duminv = 1.e0 / ( 1.e0 + rrho * u2 );
                dm2inv = 0.5e0 * duminv;
                B00[m] = dm2inv * rze * u2;
                B10[m] = dm2inv * ( zeta + rze*u2 );
                B01[m] = dm2inv * ( eta  + rze*u2 );
                dum    = zeta * u2 * duminv;
#pragma unroll
                for ( i=0; i<3; i++ ) C00[m3+i]  = PA[i] + dum * QP[i];
                dum    = eta * u2 * duminv;
#pragma unroll
                for ( i=0; i<3; i++ ) CP00[m3+i] = QC[i] - dum * QP[i];
            }
            gpu_xyzint_rys_dsps( F00, B00, B10, B01, C00, CP00,
                     xint, yint, zint );
            gpu_form_rys_dsps( xint, yint, zint, eh );
        }
    }
    gpu_hrr_calc_rys_dsps( eh, BA, DC );
    gpu_hrr_coef_rys_dsps( eh, DINT );
}

#if 0
int gpu_twoint_rys_dsps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *shel_atm, const int *shel_ini,
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for partially direct SCF
        const long *pebuf_max_nzeri, long *ebuf_non_zero_eri,
        double ebuf_val[], short int ebuf_ind4[],
        int *last_ijcs, int *last_klcs ) {
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double *DINTEG;
    long nzeri, max_nzeri, nzeri4;
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    long ebuf_max_nzeri = *pebuf_max_nzeri;
    int mythread;
    DFACT = gpu_getadd_dfact();
    mythread = omp_get_thread_num();
    DINTEG = gpu_integ_getadd_eri( mythread );
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    nzeri     = *ebuf_non_zero_eri;
    max_nzeri = ebuf_max_nzeri - 6*1*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        *last_ijcs = ijcs0+workerid;
        *last_klcs = klcs0 - 1;
        *ebuf_non_zero_eri = nzeri;
        return OFMO_EBUF_FULL;
    }
    for ( ijcs=ijcs0+workerid; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( klcs=klcs0; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_rys_dsps( mythread,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd) || (ics==kcs && jcs>lcs) ? true : false);
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)iao;
                                    ebuf_ind4[nzeri4+1] = (short int)jao;
                                    ebuf_ind4[nzeri4+2] = (short int)kao;
                                    ebuf_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    ebuf_val[nzeri]     = coe*DINTEG[ix];
                                    ebuf_ind4[nzeri4+0] = (short int)kao;
                                    ebuf_ind4[nzeri4+1] = (short int)lao;
                                    ebuf_ind4[nzeri4+2] = (short int)iao;
                                    ebuf_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }
                    }
                }
            }
            if ( nzeri >= max_nzeri ) {
                *last_ijcs = ijcs;
                *last_klcs = klcs;
                *ebuf_non_zero_eri = nzeri;
                return OFMO_EBUF_FULL;
            }
        }
    }
    *ebuf_non_zero_eri = nzeri;
    return OFMO_EBUF_NOFULL;
}

int gpu_twoint_direct_rys_dsps(
        const int *pnworkers, const int *pworkerid,
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        const int *shel_atm, const int *shel_ini,
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // for direct SCF
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) {
    int nworkers=*pnworkers, workerid=*pworkerid;
    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int last_ijcs=*plast_ijcs, last_klcs=*plast_klcs, nao=*pnao;
    long max_nzeri=*petmp_max_nzeri;
    long nzeri4, nzeri=*petmp_non_zero_eri;
    //
    int Lab, Lcd, i, j, k, l, ipat, ix;
    int I2, IJ, K2, KL;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, max_klcs;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double *DINTEG;
    int mythread;
    DFACT = gpu_getadd_dfact();
    mythread = omp_get_thread_num();
    DINTEG = gpu_integ_getadd_eri( mythread );
    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
        ijcs = last_ijcs;
        klcs = last_klcs+1;
    } else {
        ijcs = leading_cs_pair[Lab] + workerid;
        klcs = klcs0;
    }
    max_nzeri -= 6*1*3*1;
    nzeri4    = nzeri*4;
    if ( nzeri >= max_nzeri ) {
        gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4, Ds, G );
        nzeri = nzeri4 = 0;
    }
    for ( ; ijcs<ijcs1; ijcs+=nworkers ) {
        val_ab = csp_schwarz[ijcs];
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        ijps0  = csp_leading_ps_pair[ijcs];
        nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
        iat    = shel_atm[ics];
        jat    = shel_atm[jcs];
        iao0   = shel_ini[ics];
        jao0   = shel_ini[jcs];
        A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
        B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
        for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        max_klcs = ( Lab == Lcd ? ijcs+1 : klcs1 );
        for ( ; klcs<max_klcs; klcs++ ) {
            val_cd = csp_schwarz[klcs];
            if ( val_ab*val_cd < EPS_PS4 ) continue;
            kcs    = csp_ics[klcs];
            lcs    = csp_jcs[klcs];
            klps0  = csp_leading_ps_pair[klcs];
            nklps  = csp_leading_ps_pair[klcs+1]-klps0;
            kat    = shel_atm[kcs];
            lat    = shel_atm[lcs];
            kao0   = shel_ini[kcs];
            lao0   = shel_ini[lcs];
            C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
            D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
            for ( i=0; i<3; i++ ) {
                AC[i] = A[i] - C[i];
                DC[i] = D[i] - C[i];
            }
            gpu_twoint_core_rys_dsps( mythread,
                    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
                    &psp_xiza[ijps0], BA,
                    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
                    &psp_xiza[klps0], DC,   AC,      DINTEG );
            ipat=((Lab != Lcd) || (ics==kcs && jcs>lcs) ? true : false);
            for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                I2 = (iao*iao+iao)>>1;
                for ( j=0, jao=jao0; j<1; j++, jao++ ) {
                    if ( jao>iao ) { ix+=3*1; continue; }
                    IJ = I2 + jao;
                    coe0 = ( iao==jao ? HALF : ONE );
                    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
                        K2 = (kao*kao+kao)>>1;
                        for ( l=0, lao=lao0; l<1; l++, lao++, ix++ ) {
                            if ( lao>kao ) continue;
                            if ( fabs(DINTEG[ix]) > EPS_ERI ) {
                                KL = K2 + lao;
                                if ( IJ >= KL ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe *= HALF;
                                    if ( KL == IJ ) coe *= HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)iao;
                                    etmp_ind4[nzeri4+1] = (short int)jao;
                                    etmp_ind4[nzeri4+2] = (short int)kao;
                                    etmp_ind4[nzeri4+3] = (short int)lao;
                                    nzeri++;
                                    nzeri4+=4;
                                } else if ( ipat ) {
                                    coe = coe0;
                                    if ( kao==lao ) coe*=HALF;
                                    etmp_val[nzeri]     = coe*DINTEG[ix];
                                    etmp_ind4[nzeri4+0] = (short int)kao;
                                    etmp_ind4[nzeri4+1] = (short int)lao;
                                    etmp_ind4[nzeri4+2] = (short int)iao;
                                    etmp_ind4[nzeri4+3] = (short int)jao;
                                    nzeri++;
                                    nzeri4+=4;
                                }
                            }
                        }
                    }
                }
            }
            if ( nzeri >= max_nzeri ) {
                gpu_integ_add_fock( nao, nzeri, etmp_val, etmp_ind4,
                        Ds, G );
                nzeri = nzeri4= 0;
            }
        }
        klcs = klcs0;
    }
    *petmp_non_zero_eri = nzeri;
    return 0;
}
#endif // 0
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifdef __cplusplus
extern "C" {
#endif
#include "ofmo-def.h"
#ifdef __cplusplus
}
#endif
#include "cudalib.h"
#include "cuda-twoint-direct.h"
#include "cuda-twoint-core.h"
#include "cuda-twoint-core-os.h"
#include "cuda-twoint-core-rys.h"
#include "cuda-utils.h"
#ifdef CUDA_FMT_M
#include "cuda-fmt-m.h"
#endif

/*
//#define EPS_PS4 1.e-30
//#define EPS_ERI	1.e-15
//#define EPS_PS4 1.e-20
#define EPS_PS4 1.e-20F
#define EPS_ERI	1.e-15
//#define EPS_SCH	5.e-11
#define EPS_SCH	1e-12F
*/

#ifndef ZERO
#define ZERO	0.e0
#endif
#ifndef ONE
#define ONE	1.e0
#endif
#ifndef HALF
#define HALF	.5e0
#endif

#ifndef MIN2
#define MIN2(a, b) (((a)<(b))? (a): (b))
#endif
#ifndef MAX2
#define MAX2(a, b) (((a)>(b))? (a): (b))
#endif

#define NKLBUF 8

extern __shared__ double shared[];
//__device__ int ijcounter[21];

#ifndef WORK
#define WORK(a) work[nthb*(a)+tidx]
#endif

//#if CUDA_ARCH >= 350
#if defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 350
#define NREGS_064 __launch_bounds__(128,8)
#define NREGS_128 __launch_bounds__(128,4)
#define NREGS_255 __launch_bounds__(128,2)
#else
#define NREGS_064
#define NREGS_128
#define NREGS_255
#endif

//#define GPU_TWOINT_OS
//#define GPU_TWOINT_RYS

/* ------------------------------------- */

__global__ void gpu_twoint_direct_counter_init(int Labcd, int counter)
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int bidx = blockIdx.x;
  __syncthreads();
  __threadfence();
  if (bidx==0 && tidx==0) {
    ijcounter[Labcd] = counter;
  }
  __syncthreads();
  __threadfence();

  return;
}

/* ------------------------------------- */

__device__ float gpu_dmax6(const int i, const int j,
    const int k, const int l)
{
  float dmax = 1.0;
  /*
  int i2 = i * ncs;
  int j2 = j * ncs;
  int k2 = k * ncs;
  dmax = MAX2(Dcs[i2+j], Dcs[k2+l]) * 4;
  dmax = MAX2(Dcs[i2+k], dmax);
  dmax = MAX2(Dcs[i2+l], dmax);
  dmax = MAX2(Dcs[j2+k], dmax);
  dmax = MAX2(Dcs[j2+l], dmax);
  */
  int i2 = i * ncs;
  dmax = MAX2(LDG(Dcs[i2+j]), LDG(Dcs[k*ncs+l])) * 4;
  dmax = MAX2(LDG(Dcs[i2+k]), dmax);
  dmax = MAX2(LDG(Dcs[i2+l]), dmax);
  i2 = j * ncs;
  dmax = MAX2(LDG(Dcs[i2+k]), dmax);
  dmax = MAX2(LDG(Dcs[i2+l]), dmax);

  return dmax;
}

/* ------------------------------------- */

/** (ss,ss)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_064
gpu_twoint_direct_ssss_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=0, Lb=0, Lc=0, Ld=0;
    int Lab, Lcd;
    int Labcd = 0;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1, ijao;
//    int klcs, klcs0, klcs1, klao;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
//    int ics, iat, iao, jcs, jat, jao, kcs, kat, kao, lcs, lat, lao;
    int ics, iat, iao, jcs, jat, jao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
    __shared__ double BA[3];
//    __shared__ double A[3];
//    __shared__ double sSSSS[NTHREADS];
//    __shared__ double sGij[NTHREADS];
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[0];
    double *tbl = FMT_m_table0;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    //double SSSS[1];
    //double Gij[1];
    //double *SSSS = &shared[tsize+1+tidx];
    //double *Gij = &shared[tsize+1+tidx+nthb];
    size_t sOffset = tsize;
    double *Gij = &shared[tsize+tidx];
    double *SSSS = &shared[tsize+tidx+nthb];
    tsize += nthb*2;
    //double *Gij = &shared[tsize+1+tidx];
#else
    size_t sOffset = 0;
    double *Gij = &shared[tidx];
    double *SSSS = &shared[nthb+tidx];
    size_t tsize = nthb*3;
#endif
#ifdef DLB_KL_SSSS
    //__shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
    //volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif

    mincs = MIN2(leading_cs[Lc], leading_cs[Ld]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[Lc+1], leading_cs[Ld+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;
//    if(tidx==0) printf("ssss:(%3d/%3d) %d %d %d %16.10g\n", iwkblk, nwkblk, workerid, idev, bidx, G[0]);

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
//    if(tidx==0) printf("ssss:(%1d/%1d) ijcs0 = %d\n", iwkblk, nwkblk, ijcs0);

#ifndef USE_ATOMIC
    /*
    for ( i=0; i<nao; i++ ) Gi[i]=ZERO;
    for ( i=0; i<nao; i++ ) Gj[i]=ZERO;
    */
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*2; i+=nthb) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0); i+=nthb ) Gkl[i]=ZERO;
    __syncthreads();
#endif

//    if (tidx==0) ijcsw = ijcs0 + atomicAdd(p_ijcounter,1);
#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx;
      nijcsw = 0;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (ijcs=ijcs0+iwkblk; ijcs<ijcs1; ijcs+=nwkblk ) {
#endif
        int klcs0a;
//        int n2ei = 0;
//        double Gij;
//        double A[3],BA[3];
        double A[3];
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs1 - 1 - (ijcsw - ijcs0);
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#endif
#ifdef DLB_KL_SSSS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
        klcs0a = klcs0;
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else
        {
	  float val_ab = csp_schwarz[ijcs];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
//	  for (int klcs = klcs0a+tidx ; klcs<=ijcs; klcs+=nthb) {
	  for (int klcs = ijcs-tidx; klcs>=klcs0a ; klcs-=nthb) {
//	  for (int klcs = klcs0a ; klcs<=ijcs; klcs++) {
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif
//        Gij = ZERO;
//        sGij[tidx] = ZERO;
        *Gij = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao    = shel_ini[ics];
	jao    = shel_ini[jcs];
	ijao   = iao*(iao+1)/2+jao;
        /*
        {
          double B[3];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
#pragma unroll
//	for ( i=tidx; i<3; i+=nthb ) BA[i] = B[i] - A[i];
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
  __threadfence_block();
        }
        */
        __syncthreads();
        BA[0] = LDG(atom_x[jat]) - (A[0] = LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) - (A[1] = LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) - (A[2] = LDG(atom_z[iat]));
	
//	for ( ; klcs<=ijcs; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs = klcs0a+tidx ; klcs<=ijcs; klcs+=nthb ) {
#else
#ifndef DLB_KL_SSSS
        for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
#else
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
          while(iklcs<nklcs) {
#endif /* DLB_KL */
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao, lcs, lat, lao;
            int klps0, nklps;
            int klao;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
            {
	    float val_abcd = val_ab * csp_schwarz[klcs];
            float dmax;
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
            }
#else
            int klcs;
            klcs = sklcs[iklcs];
#endif
            klcs2 = klcs - klcs0;
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao    = LDG(shel_ini[kcs]);
	    lao    = LDG(shel_ini[lcs]);
	    klao   = kao*(kao+1)/2+lao;
            {
            /*
            double C[3], D[3];
            double DC[3],AC[3];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            double dtmp;
            double DC[3],AC[3];
            AC[0] = A[0] - (dtmp = LDG(atom_x[kat]));
            DC[0] = LDG(atom_x[lat]) - dtmp;
            AC[1] = A[1] - (dtmp = LDG(atom_y[kat]));
            DC[1] = LDG(atom_y[lat]) - dtmp;
            AC[2] = A[2] - (dtmp = LDG(atom_z[kat]));
            DC[2] = LDG(atom_z[lat]) - dtmp;

	    gpu_twoint_core_ssss_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      SSSS );
//		    &psp_xiza[klps0], DC,   AC,      &sSSSS[tidx] );
            }
//	    if ( fabs(sSSSS[tidx]) > eps_eri ) {
	    if ( fabs(SSSS[0]) > eps_eri ) {
		double x, x4;
		int ij, ik, il, jk, jl, kl, i0, j0;
                double coe;
                double dx;
		coe = ONE;
		if ( iao == jao ) coe = HALF;
		if ( kao == lao ) coe *= HALF;
		if ( ijao == klao ) coe *= HALF;
		x  = coe * SSSS[0];
		x4 = 4.0 * x;
                x *= -x_coef;
//		x  = coe * sSSSS[tidx];

		i0 = iao*nao;
		j0 = jao*nao;
		ij = i0 + jao;
		ik = i0 + kao;
		il = i0 + lao;
		jk = j0 + kao;
		jl = j0 + lao;
		kl = kao*nao + lao;
                /*
		G[ij] += x4*Ds[kl];
		G[kl] += x4*Ds[ij];
		G[ik] -=  x*Ds[jl];
		G[il] -=  x*Ds[jk];
		G[jk] -=  x*Ds[il];
		G[jl] -=  x*Ds[ik];
                */
#ifdef USE_ATOMIC
                dx = x*LDG(Ds[jl]);
                atomicAdd(&G[ik],dx);
                dx = x*LDG(Ds[jk]);
                atomicAdd(&G[il],dx);
                dx = x*LDG(Ds[il]);
                atomicAdd(&G[jk],dx);
                dx = x*LDG(Ds[ik]);
                atomicAdd(&G[jl],dx);

                *Gij += x4*LDG(Ds[kl]);
                dx = x4*LDG(Ds[ij]);
                atomicAdd(&G[kl],dx);
#else
                Gi[kao] += x*LDG(Ds[jl]);
                Gi[lao] += x*LDG(Ds[jk]);
                Gj[kao] += x*LDG(Ds[il]);
                Gj[lao] += x*LDG(Ds[ik]);

                Gkl[klcs2] += x4*LDG(Ds[ij]);
                *Gij += x4*LDG(Ds[kl]);
#endif
//                n2ei++;
	    }	// if ( fabs(SSSS[0]) > eps_eri )
#ifdef DLB_KL_SSSS
          if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
          iklcs = klcsw[widx] + tidw;
          }; // while (iklcs)
#endif
	}	// for ( klcs );
//    if(tidx==0&&iwkblk==1) printf("ssss:(%1d/%1d) %d %d %d\n", iwkblk, nwkblk, ijcs, nklcs, n2ei);
//	klcs = klcs0;
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
        atomicAdd(&G[iao*nao+jao], *Gij);
#else
          { // Reduce Gij within warp
            //double *sGij = &shared[widx*WARP_SIZE];
            double *sGij = &shared[sOffset+widx*WARP_SIZE];
            warpReduce(sGij, tidw);
          }
          __syncthreads();
          if (tidx==0) { // Reduce Gij for warp masters
            //double *sGij = &shared[0];
            double *sGij = &shared[sOffset];
            double dtmp = sGij[0];
            for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
            atomicAdd(&G[iao*nao+jao], dtmp);
          }
#endif
#else 
//        Gi[jao] += sGij[tidx];
        Gi[jao] += *Gij;
        {
          int nGi = num_Gi*2;
          int bs = bidx*nthb*num_Gi;
          int i0 = iao*nao;
          int j0 = jao*nao;
          int i,j;
          int ijcs_next;
          int ics_next=-1, jcs_next=-1;
          __syncthreads();
#ifdef GPU_DLB
//          ijcs_next = ijcsw;
//          ijcs_next = ijcs1 - ijcsw + 1;
          ijcs_next = ijcs1 - 1 - (ijcsw - ijcs0);
          if (ijcsw<ijcs1) { 
#else
          ijcs_next = ijcs+nwkblk;
          if (ijcs_next<ijcs1) { 
#endif
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
          if (ics != ics_next) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
            /*
            for (j=0;j<nthb;j++) {
              Gtmp += *pG;
              *pG = ZERO;
              pG  += num_Gi;
            }
            */
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
          } 
          }
          if (jcs != jcs_next) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao + i;
            double *pG1 = pG + num_Gi;
            /*
            for (j=0;j<nthb;j++) {
              Gtmp += *pG;
              *pG = ZERO;
              pG  += num_Gi;
            }
            */
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          }
          } 
        }
#endif /* USE_ATOMIC */
        __syncthreads();
    }		// for ( ijcs );
    __syncthreads();
#ifndef USE_ATOMIC
    for (int klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
      int kcs,lcs,kao,lao;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs];
      lao = shel_ini[lcs];
//      G[kao*nao+lao] += Gkl[klcs];
      G[kao*nao+lao] += Gkl[klcs-klcs0];
    }
#endif

    __syncthreads();
//    if(tidx==0) printf("ssss:(%3d/%3d) %d %d %d %16.10g\n", iwkblk, nwkblk, workerid, idev, bidx, G[0]);

    return;
}

/** (ps,ss)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_128
gpu_twoint_direct_psss_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=1, Lb=0, Lc=0, Ld=0;
    int Lab, Lcd;
    int Labcd = 1;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, lcs, lat, lao;
    double PSSS[3];
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
//    double coe;
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[1];
    double *tbl = FMT_m_table1;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    //double Gij[3];
    size_t sOffset = tsize;
    double *Gij = &shared[tsize+tidx*3];
    tsize += nthb*3;
#else
    size_t sOffset = 0;
    double *Gij = &shared[tidx*3];
    size_t tsize = nthb*3;
#endif
#ifdef DLB_KL_PSSS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    mincs = MIN2(leading_cs[Lc], leading_cs[Ld]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[Lc+1], leading_cs[Ld+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;
//    if (bidx == 0 && tidx == 0)
//      printf("mincs(minao), maxcs(maxao) = %4d(%4d), %4d(%4d)\n", mincs, minao, maxcs, maxao); 

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
//    Gkl = Gkl_b + bidx * ncspair * nL[maxlqn] * nL[maxlqn];
    Gkl = Gkl_b + bidx * num_Gkl;
//    Gi = (double *)malloc(nao * sizeof(double) * 4);
//    Gj = Gi + nao*3;
//    Gi   = Gi_t + (bidx * nthb + tidx) * nL[maxlqn] * nao;
//    Gj   = Gj_t + (bidx * nthb + tidx) * nL[maxlqn] * nao;
//    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
//    Gj   = Gj_t + (bidx * nthb + tidx) * num_Gi;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*3;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;
//    if(tidx==0) printf("psss:(%3d/%3d) %d %d %d\n", iwkblk, nwkblk, workerid, idev, bidx);

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];

#ifndef USE_ATOMIC
    /*
    for ( i=0; i<nao*3; i++ ) Gi[i]=ZERO;
    for ( i=0; i<nao; i++ ) Gj[i]=ZERO;
    */
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*4; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0); i+=nthb ) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
//        double Gij[3];
//        double A[3],BA[3];
//        double A[3];
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_PSSS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
        klcs0a = klcs0;
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0a+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0a ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
#pragma unroll
        for (int i=0;i<3;i++) Gij[i] = ZERO;
//        for (i=0;i<3;i++) sGij[i][tidx] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	jao    = jao0;
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) - (A[0] = LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) - (A[1] = LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) - (A[2] = LDG(atom_z[iat]));

        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        klcs0a = klcs0;
//	for (klcs = klcs0a ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0a+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_PSSS
  NOT supported combination of defines.
#endif
#else
#ifndef DLB_KL_PSSS
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* DLB_KL */
#endif /* USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao    = LDG(shel_ini[kcs]);
	    lao    = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            {
            double dtmp;
            AC[0] = A[0] - (dtmp = LDG(atom_x[kat]));
            DC[0] = LDG(atom_x[lat]) - dtmp;
            AC[1] = A[1] - (dtmp = LDG(atom_y[kat]));
            DC[1] = LDG(atom_y[lat]) - dtmp;
            AC[2] = A[2] - (dtmp = LDG(atom_z[kat]));
            DC[2] = LDG(atom_z[lat]) - dtmp;
            }
	    gpu_twoint_core_psss_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      PSSS );
            {
            double Gjk=ZERO, Gjl=ZERO, Glk2=ZERO;
	    double coe = ( kao == lao ? HALF : ONE );
            int j0 = jao*nao;
	    int jk = j0 + kao;
	    int jl = j0 + lao;
            int kl = kao*nao + lao;
#pragma unroll
	    for (int i=0, iao=iao0; i<3; i++, iao++ ) {
		    double x, x4;
//                    x = PSSS[i];
		if ( fabs(PSSS[i]) > eps_eri ) {
//		if ( fabs(x) > eps_eri ) {
//		    int ij, ik, il, jk, jl, kl, i0, j0;
		    int ij, ik, il, i0;
                    double dx;
		    x  = coe * PSSS[i];
                    x4 = 4.0 * x;
                    x *= -x_coef;
		    i0 = iao*nao;
		    ij = i0 + jao;
		    ik = i0 + kao;
		    il = i0 + lao;
		    i0 = i*nao;
                    /*
		    G[ij] += x4*Ds[kl];
		    G[kl] += x4*Ds[ij];
		    G[ik] -=  x*Ds[jl];
		    G[il] -=  x*Ds[jk];
		    G[jk] -=  x*Ds[il];
		    G[jl] -=  x*Ds[ik];
                    */
                    Gjk += x*LDG(Ds[il]);
                    Gjl += x*LDG(Ds[ik]);
		    Glk2 += x4*LDG(Ds[ij]);
		    Gij[i] += x4*LDG(Ds[kl]);
#ifdef USE_ATOMIC
                    dx = x*LDG(Ds[jl]);
		    atomicAdd(&G[ik],dx);
                    dx = x*LDG(Ds[jk]);
		    atomicAdd(&G[il],dx);
#else
		    Gi[i0+kao]   +=  x*LDG(Ds[jl]);
		    Gi[i0+lao]   +=  x*LDG(Ds[jk]);
#endif /* USE_ATOMIC */
		}
	    }	// for ( i, iao);
#ifdef USE_ATOMIC
		atomicAdd(&G[jk],Gjk);
		atomicAdd(&G[jl],Gjl);
		atomicAdd(&G[kl],Glk2);
#else
		Gj[kao] +=  Gjk;
		Gj[lao] +=  Gjl;
                Gkl[klcs2] += Glk2;
#endif
            }
#ifdef DLB_KL_PSSS
          if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
          iklcs = klcsw[widx] + tidw;
          }; // while (iklcs)
#endif
	}	// for ( klcs );
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
#pragma unroll
	  for (int i=0; i<3; i++) {
            int ij;
	    ij = jao0*nao + iao0 + i;
//            atomicAdd(&G[ij], sGij[i][tidx]);
            //atomicAdd(&G[ij], Gij[i]);
            atomicAdd(&G[ij], Gij[i]);
          }
#else
        {
          int i, j;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          double tGij[3];
          for (i=0; i<3; i++) tGij[i] = Gij[i];
          for (i=0; i<3; i++) {
            double *ss = &shared[sOffset+tidx];
            __syncthreads();
            *ss = tGij[i];
            { // Reduce Gij within warp
              double *sGij = &shared[sOffset+widx*WARP_SIZE];
              warpReduce(sGij, tidw);
            }
            __syncthreads();
            if (tidx==0) { // Reduce Gij for warp masters
              double *sGij = &shared[sOffset];
              double dtmp = sGij[0];
              for (j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
              atomicAdd(&G[j0+iao0+i], dtmp);
            }
          } // i
        }
#endif
        __syncthreads();
#else
//	klcs = klcs0;
        {
          int i,j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          int ijcs_next;
          int ics_next, jcs_next;
    /*
//	  for (i=0; i<3; i++) atomicAdd(&G[j0+iao0+i], Gij[i]);
//	  for (i=0; i<3; i++) G[j0+iao0+i] += Gij[i];
//            G[i0+i] += Gi[i];
//            G[j0+i] += Gj[i];
        */
//	  for (i=0; i<3; i++) Gj[iao0+i] += Gij[i];
//	  for (i=0; i<3; i++) Gi[jao0+nao*i] += Gij[i];
// Don't use Gj[iao0+i] because only s-type ao will be added for (ps,ss)
#pragma unroll
	  //for (i=0; i<3; i++) Gi[jao0+nao*i] += Gij[i];
	  for (i=0; i<3; i++) Gi[jao0+nao*i] += Gij[i];
//	  for (i=0; i<3; i++) Gi[jao0+nao*i] += sGij[i][tidx];
    __syncthreads();
          ics_next=jcs_next=-1;
#ifdef GPU_DLB
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
          /*
	  for (i=0; i<nao*3; i++) atomicAdd(&G[i0+i], Gi[i]);
	  for (i=0; i<nao; i++) atomicAdd(&G[j0+i], Gj[i]);
          */
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
            {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
            /*
            for (j=0;j<nthb;j++) {
              Gtmp += *pG;
              *pG = ZERO;
              pG += num_Gi;
            }
            */
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
//            G[i0+i+ii*nao] += Gtmp;
            }
          } 
          }
//          }
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*3 + i;
            double *pG1 = pG + num_Gi;
            /*
            for (j=0;j<nthb;j++) {
              Gtmp += *pG;
              *pG = ZERO;
              pG += num_Gi;
            }
            */
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } 
          }
    __syncthreads();
//	  for ( i=0; i<nao*3; i++ ) Gi[i]=ZERO;
//	  for ( i=0; i<nao; i++ ) Gj[i]=ZERO;
        }
#endif /* USE_ATOMIC */
    }		// for ( ijcs );
    __syncthreads();
#ifndef USE_ATOMIC
    for (klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs];
      lao = shel_ini[lcs];
//      G[kao*nao+lao] += Gkl[klcs];
      G[kao*nao+lao] += Gkl[klcs-klcs0];
    }
#endif
    __syncthreads();
//    free(Gi);

    return;
}

/** (ps,ps)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_128
gpu_twoint_direct_psps_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=1, Lb=0, Lc=1, Ld=0;
//    int Lab, Lcd, i, k, ix;
    int Lab, Lcd, i,j;
    int Labcd = 2;
    int *p_ijcounter = &ijcounter[Labcd];
//    int ipat, IJ, KL;
    int ijcs, ijcs0, ijcs1;
//    int klcs, klcs0, klcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
//    int ics, iat, iao, iao0, jcs, jat, jao;
    int ics, iat, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    double PSPS[3*3];
//    __shared__ double *PSPS;
    /*
    // for check sum
    double lsum = ZERO;
    */
    int klcs0a;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
    __shared__ double BA[3];
//    __shared__ double A[3];
//    __shared__ double sGij[3][NTHREADS];
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[2];
    double *tbl = FMT_m_table2;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    double Gij[3];
    //double *Gij = &shared[tsize+1+tidx*3];
    size_t sOffset = tsize;
    tsize += nthb;
#else
    double *Gij = &shared[tidx*3];
    size_t tsize = nthb*3;
    size_t sOffset = 0;
#endif
#ifdef DLB_KL_PSPS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif

//    PSPS = (double *)malloc(sizeof(double)*3*3*nthb);
    mincs = MIN2(leading_cs[Lc], leading_cs[Ld]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[Lc+1], leading_cs[Ld+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*3;
    work = work_b + bidx * nthb * WORK_SIZE;

    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];

#ifndef USE_ATOMIC
    /*
    for ( i=0; i<nao*3; i++ ) Gi[i]=ZERO;
    for ( i=0; i<nao; i++ ) Gj[i]=ZERO;
    */
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*4; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*3; i+=nthb ) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx;
      nijcsw = 0;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (ijcs=ijcs0+iwkblk; ijcs<ijcs1; ijcs+=nwkblk ) {
#endif
//        double A[3], BA[3];
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs1 - 1 - (ijcsw - ijcs0);
#endif
#ifdef DLB_KL_PSPS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        klcs0a = klcs0;
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else
        {
          float val_ab = csp_schwarz[ijcs];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
          for (int klcs = klcs0a+tidx ; klcs<=ijcs; klcs+=nthb) {
//	  for (int klcs = ijcs-tidx; klcs>=klcs0a ; klcs-=nthb) {
              int kcs, lcs;
              int iklcs;
              float dmax;
              float val_abcd = val_ab * csp_schwarz[klcs];
              if ( val_abcd < eps_ps4 ) continue;
              kcs    = csp_ics[klcs];
              lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
              if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif
#pragma unroll
        for (int i=0;i<3;i++) Gij[i] = ZERO;
//        for (i=0;i<3;i++) sGij[i][tidx] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao    = shel_ini[jcs];
        {
          /*
        double B[3];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        /*
	BA[0] =atom_x[jat] - (A[0]=atom_x[iat]);
	BA[1] =atom_y[jat] - (A[1]=atom_y[iat]);
	BA[2] =atom_z[jat] - (A[2]=atom_z[iat]);
        */
        /*
	BA[0] =atom_x[jat] - (work[tidx       ]=atom_x[iat]);
	BA[1] =atom_y[jat] - (work[tidx+nthb  ]=atom_y[iat]);
	BA[2] =atom_z[jat] - (work[tidx+nthb*2]=atom_z[iat]);
        */
	  BA[0] = LDG(atom_x[jat]) - (WORK(0) = LDG(atom_x[iat]));
	  BA[1] = LDG(atom_y[jat]) - (WORK(1) = LDG(atom_y[iat]));
	  BA[2] = LDG(atom_z[jat]) - (WORK(2) = LDG(atom_z[iat]));
        }

	
//	for ( ; klcs<=ijcs; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs = klcs0a+tidx ; klcs<=ijcs; klcs+=nthb ) {
#else
#ifndef DLB_KL_PSPS
        for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
#else
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* DLB_KL */
#endif
            int klcs2;
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
            int ipat;
            int ijgekl;
            double DC[3], AC[3];
#ifdef USE_INSTANT_SCHWARZ
            {
	    float val_abcd = val_ab * csp_schwarz[klcs];
            float dmax;
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
            }
#else
            int klcs;
            klcs = sklcs[iklcs];
#endif
            klcs2 = (klcs - klcs0)*3;
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao    = LDG(shel_ini[lcs]);
            /*
            {
              double C[3],D[3];
	    C[0]=LDG(atom_x[kat]); C[1]=LDG(atom_y[kat]); C[2]=LDG(atom_z[kat]);
	    D[0]=LDG(atom_x[lat]); D[1]=LDG(atom_y[lat]); D[2]=LDG(atom_z[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
//		AC[i] = A[i] - C[i];
//		AC[i] = work[tidx+nthb*i] - C[i];
		AC[i] = WORK(i) - C[i];
		DC[i] = D[i] - C[i];
	    }
            }
            */
            {
            double dtmp;
            AC[0] = WORK(0) - (dtmp = LDG(atom_x[kat]));
            DC[0] = LDG(atom_x[lat]) - dtmp;
            AC[1] = WORK(1) - (dtmp = LDG(atom_y[kat]));
            DC[1] = LDG(atom_y[lat]) - dtmp;
            AC[2] = WORK(2) - (dtmp = LDG(atom_z[kat]));
            DC[2] = LDG(atom_z[lat]) - dtmp;
            }
	    gpu_twoint_core_psps_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      PSPS );
	    ipat = ( (ics==kcs && jcs>lcs) ? true : false);
            ijgekl = (ics>kcs);
            if (ics==kcs) ijgekl = (jcs>=lcs);
            if (!ijgekl) ipat = ( (ics==kcs && jcs<lcs) ? true : false);
            {
            int iao, ix;
            int j0 = jao*nao;
            int jl = j0 + lao;
            double Gjl = ZERO;
            double Gjk[3]={ZERO,ZERO,ZERO};
            double Glk2[3]={ZERO,ZERO,ZERO};
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<3; i++, iao++ ) {
                int k, kao;
		int i0 = iao*nao;
		int il = i0 + lao;
                double Gil = ZERO;
		int IJ = ((iao*iao+iao)>>1) + jao;
#pragma unroll
		for ( k=0, kao=kao0; k<3; k++, kao++, ix++ ) {
		    int KL = ((kao*kao+kao)>>1) + lao ;
		    if ( fabs(PSPS[ix]) <= eps_eri ) continue;
//		    if ( IJ>=KL || ipat ) {
		    if ( (ijgekl&&IJ>=KL) || (!ijgekl&&KL>=IJ) || ipat ) {
			double x, x4, coe;
                        double dx;
//			int ij, ik, il, jk, jl, kl, i0, j0;
			int ij, ik, jk, kl;
			coe = ONE;
			if ( IJ == KL ) coe = HALF;
			x  = coe * PSPS[ix];
			x4 = 4.e0 * x;
                        x *= -x_coef;
//			i0 = iao*nao;
//			j0 = jao*nao;
			ij = i0 + jao;
			ik = i0 + kao;
//			il = i0 + lao;
			jk = j0 + kao;
//			jl = j0 + lao;
			kl = kao*nao + lao;
/*
			G[ij] += x4*Ds[kl];
			G[kl] += x4*Ds[ij];
			G[ik] -=  x*Ds[jl];
			G[il] -=  x*Ds[jk];
			G[jk] -=  x*Ds[il];
			G[jl] -=  x*Ds[ik];
*/
#ifdef USE_ATOMIC
                        dx = x*LDG(Ds[jl]);
                        atomicAdd(&G[ik],dx);
#else
                        Gi[i*nao+kao] += x*LDG(Ds[jl]);
#endif
                        Gil    += x*LDG(Ds[jk]);
                        Gjk[k] += x*LDG(Ds[il]);
                        Gjl    += x*LDG(Ds[ik]);
                        Gij[i]  += x4*LDG(Ds[kl]);
                        Glk2[k] += x4*LDG(Ds[ij]);
		    }
		}	// for ( kao )
#ifdef USE_ATOMIC
              atomicAdd(&G[il],Gil);
#else
              Gi[i*nao+lao] += Gil;
#endif
	    }		// for ( iao )
#ifdef USE_ATOMIC
              atomicAdd(&G[jl],Gjl);
#pragma unroll
              for (int i=0;i<3;i++) atomicAdd(&G[j0+kao0+i],Gjk[i]);
#pragma unroll
              for (int k=0;k<3;k++) atomicAdd(&G[lao*nao+kao0+k],Glk2[k]);
#else
              Gj[lao] += Gjl;
#pragma unroll
              for (int i=0;i<3;i++) Gj[kao0+i] += Gjk[i];
#pragma unroll
              for (int k=0;k<3;k++) Gkl[klcs2+k] += Glk2[k];
#endif
            }
#ifdef DLB_KL_PSPS
          if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
          iklcs = klcsw[widx] + tidw;
          }; // while (iklcs)
#endif
	}	// for ( klcs );
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
#pragma unroll
	  for (int i=0; i<3; i++) {
            int ij;
	    ij = jao*nao + iao0 + i;
//            atomicAdd(&G[ij], sGij[i][tidx]);
            atomicAdd(&G[ij], Gij[i]);
          }
#else
        {
#ifndef CUDA_FMT_M_SM
          double tGij[3];
          for (int i=0; i<3; i++) tGij[i] = Gij[i];
#else
          double *tGij = Gij;
#endif
          for (int i=0; i<3; i++) {
            double *ss = &shared[sOffset+tidx];
            __syncthreads();
            *ss = tGij[i];
            { // Reduce Gij within warp
              double *sGij = &shared[sOffset+widx*WARP_SIZE];
              warpReduce(sGij, tidw);
            }
            __syncthreads();
            if (tidx==0) { // Reduce Gij for warp masters
              double *sGij = &shared[sOffset];
              double dtmp = sGij[0];
              for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
              atomicAdd(&G[jao*nao+iao0+i], dtmp);
            }
          } // i
        }
#endif
    __syncthreads();
#else
//	klcs = klcs0;
//        if (n2ei>0) {
        {
          int i, j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao*nao;
          int ijcs_next;
          int ics_next=-1, jcs_next=-1;
#pragma unroll
	  for (i=0; i<3; i++) Gj[iao0+i] += Gij[i];
//	  for (i=0; i<3; i++) Gj[iao0+i] += sGij[i][tidx];
//	  for (i=0; i<3; i++) Gi[jao+nao*i] += sGij[i][tidx];
    __syncthreads();
#ifdef GPU_DLB
//          ijcs_next = ijcsw;
          ijcs_next = ijcs1 - ijcsw + 1;
          ijcs_next = ijcs1 - 1 - (ijcsw - ijcs0);
          if (ijcsw<ijcs1) {
#else
          ijcs_next = ijcs+nwkblk;
          if (ijcs_next<ijcs1) {
#endif
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
//          for (int ii=tidx;ii<nao*3;ii+=nthb) {
//            i = (ii/nao)*nao + ii%nao;
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
            {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
            /*
            for (j=0;j<nthb;j++) {
              Gtmp += *pG;
              *pG = ZERO;
              pG += num_Gi;
            }
            */
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
            }
          } 
          }
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*3 + i;
            double *pG1 = pG + num_Gi;
            /*
            for (j=0;j<nthb;j++) {
              Gtmp += *pG;
              *pG = ZERO;
              pG += num_Gi;
            }
            */
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } 
          }
    __syncthreads();
//	  for ( i=0; i<nao*3; i++ ) Gi[i]=ZERO;
//	  for ( i=0; i<nao; i++ ) Gj[i]=ZERO;
        }
#endif /* USE_ATOMIC */
//	klcs = klcs0;
    }		// for ( ijcs );
#ifndef USE_ATOMIC
    /*
    for (int klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
      int klcs2;
      int kcs,lcs,kao,lao,l0;
      klcs = klcs0 + i/3;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs];
      lao = shel_ini[lcs];
      l0 = lao*nao+kao;
#pragma unroll
      for (i=0;i<3;i++) G[l0+i] += Gkl[klcs2+i];
    }
    */
    for (int i=tidx; i<(klcs1-klcs0)*3; i+=nthb) {
      int klcs, k;
      int kcs,lcs,kao,lao,l0;
      klcs = i/3;
      k = i - klcs*3;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs];
      lao = shel_ini[lcs];
      l0 = lao*nao+kao;
      G[l0+k] += Gkl[i];
    }
#endif

    return;
}


/** (pp,ss)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
// exchange La,Lb <=> Lc,Ld
__global__ void
NREGS_128
gpu_twoint_direct_ppss_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=1, Lb=1, Lc=0, Ld=0;
    int Lab, Lcd;
    int Labcd = 3;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, lcs, lat, lao;
    double PPSS[3*3];
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
//    double coe;
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[2];
    double *tbl = FMT_m_table2;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    //double Gij[1];
    size_t sOffset = tsize;
    double *Gij = &shared[sOffset+tidx];
    tsize += nthb;
#else
    double *Gij = &shared[tidx];
    size_t tsize = nthb*3;
    size_t sOffset = 0;
#endif
#ifdef DLB_KL_PPSS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    mincs = MIN2(leading_cs[La], leading_cs[Lb]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[La+1], leading_cs[Lb+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lcd];
    ijcs1 = leading_cs_pair[Lcd+1];
    klcs0 = leading_cs_pair[Lab];
    klcs1 = leading_cs_pair[Lab+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*2; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_PPSS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
//        if(tidx==0) printf("%d:0 %d %d %d\n",tidx,ijcs,ics,jcs);
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else /* !USE_INSTANT_SCHWARZ */
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0 ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
        *Gij  = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao    = shel_ini[ics];
	jao    = shel_ini[jcs];
        __syncthreads();
        if(tidx == 0) {
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) + (A[0] = -LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) + (A[1] = -LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) + (A[2] = -LDG(atom_z[iat]));
        /*
	  BA[0] = atom_x[jat] + (WORK(0) = -atom_x[iat]);
	  BA[1] = atom_y[jat] + (WORK(1) = -atom_y[iat]);
	  BA[2] = atom_z[jat] + (WORK(2) = -atom_z[iat]);
        */
        }
        __threadfence_block();
        __syncthreads();

//        if(tidx==0) printf("%d:k %d %d\n",tidx,klcs0,klcs1);
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
//	for (klcs = klcs0 ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_PPSS
  NOT supported combination of defines.
#endif
#else /* !USE_INSTANT_SCHWARZ */
#ifndef DLB_KL_PPSS
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else /* !DLB_KL_PPSS */
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* !DLB_KL_PPSS */
#endif /* !USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
            int jk, jl, j0;
            int kao0, lao0, kao, lao;
//            int n2ei2 = 0;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
//         if (tidx==0) printf("%d:kl %d %d\n",tidx,klcs, klcs2);
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
//            Gjk = Gjl = ZERO;
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao0   = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            {
              double dtmp;
              AC[0] = A[0] + (dtmp = LDG(atom_x[kat]));
              DC[0] = LDG(atom_x[lat]) - dtmp;
              AC[1] = A[1] + (dtmp = LDG(atom_y[kat]));
              DC[1] = LDG(atom_y[lat]) - dtmp;
              AC[2] = A[2] + (dtmp = LDG(atom_z[kat]));
              DC[2] = LDG(atom_z[lat]) - dtmp;
              /*
              AC[0] =  WORK(0) + (dtmp = atom_x[kat]);
              DC[0] = atom_x[lat] - dtmp;
              AC[1] =  WORK(1) + (dtmp = atom_y[kat]);
              DC[1] = atom_y[lat] - dtmp;
              AC[2] =  WORK(2) + (dtmp = atom_z[kat]);
              DC[2] = atom_z[lat] - dtmp;
              */
            }
/*
	    gpu_twoint_core_ppss_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      PPSS );
*/
// (ss,pp) -> (pp,ss)
	    gpu_twoint_core_ppss_(
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,   AC,      PPSS );

//        printf("%d:core %d %d\n",tidx,nijps, nklps);
            {
              int i0=iao*nao, j0=jao*nao;
              int ij = i0 + jao;
              double Gil[3] = {ZERO, ZERO, ZERO};
              double Gjl[3] = {ZERO, ZERO, ZERO};
            double coe, coe0;
	    coe0 = ( iao == jao ? HALF : ONE );
#pragma unroll
	    for ( int k=0, kao=kao0, ix=0; k<3; k++, kao++ ) {
              int ik = i0 + kao;
              int jk = j0 + kao;
              double Gik = ZERO, Gjk = ZERO;
#pragma unroll
		for ( int l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
		    if ( lao > kao ) continue;
		    if ( fabs(PPSS[ix]) > eps_eri ) {
			double x, x4;
                        double dx;
			int il, jl, kl;
			coe = coe0;
			if ( kao == lao ) coe *= HALF;
			x  = coe * PPSS[ix];

			x4 = 4.e0 * x;
                        x *= -x_coef;
			il = i0 + lao;
			jl = j0 + lao;
			kl = kao*nao + lao;
                        /*
			G[ij] += x4*Ds[kl];
			G[kl] += x4*Ds[ij];
			G[ik] -=  x*Ds[jl];
			G[il] -=  x*Ds[jk];
			G[jk] -=  x*Ds[il];
			G[jl] -=  x*Ds[ik];
                        */

			Gil[l] += x*LDG(Ds[jk]);
			Gjl[l] += x*LDG(Ds[ik]);
			Gik += x*LDG(Ds[jl]);
			Gjk += x*LDG(Ds[il]);
                        *Gij += x4*LDG(Ds[kl]);
#ifdef USE_ATOMIC
			dx = x4*LDG(Ds[ij]);
                        atomicAdd(&G[kl], dx);
#else
                        Gkl[klcs2*9+ix] += x4*LDG(Ds[ij]);
#endif
		    }
		} // for ( lao );
#ifdef USE_ATOMIC
                atomicAdd(&G[ik], Gik);
                atomicAdd(&G[jk], Gjk);
#else
                Gi[kao] += Gik;
                Gj[kao] += Gjk;
#endif
	    }	// for ( kao );
#pragma unroll
            for ( int l=0, lao=lao0; l<3; l++, lao++ ) {
              int il = i0 + lao;
              int jl = j0 + lao;
#ifdef USE_ATOMIC
              atomicAdd(&G[il], Gil[l]);
              atomicAdd(&G[jl], Gjl[l]);
#else
              Gi[lao] += Gil[l];
              Gj[lao] += Gjl[l];
#endif
            }
            }  // block for additions
#ifdef DLB_KL_PPSS
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx] + tidw;
          } // while (iklcs)
#endif
	}	// for ( klcs );
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
        atomicAdd(&G[iao*nao+jao], *Gij);
#else
          { // Reduce Gij within warp
            //double *sGij = &shared[widx*WARP_SIZE];
            double *sGij = &shared[sOffset+widx*WARP_SIZE];
            warpReduce(sGij, tidw);
          }
          __syncthreads();
          if (tidx==0) { // Reduce Gij for warp masters
            //double *sGij = &shared[0];
            double *sGij = &shared[sOffset];
            double dtmp = sGij[0];
            for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
            atomicAdd(&G[iao*nao+jao], dtmp);
          }
#endif
    __syncthreads();
#else
//	klcs = klcs0;
//        if (n2ei>0) {
        {
          int i,j;
          int nGi;
          int bs;
	  int i0 = iao*nao;
	  int j0 = jao*nao;
          int ijcs_next;
          int ics_next, jcs_next;
#if 1
          { // Reduce Gij within warp
            //double *sGij = &shared[widx*WARP_SIZE];
            double *sGij = &shared[sOffset+widx*WARP_SIZE];
            warpReduce(sGij, tidw);
          }
          __syncthreads();
          if (tidx==0) { // Reduce Gij for warp masters
            //double *sGij = &shared[0];
            double *sGij = &shared[sOffset];
            double dtmp = sGij[0];
            for (j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
            G[i0+jao] += dtmp;
          }
#else
        atomicAdd(&G[iao*nao+jao], *Gij);
        //Gi[jao] += *Gij;
#endif
          ics_next=jcs_next=-1;
#ifdef GPU_DLB
          __syncthreads();
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else /* !GPU_DLB */
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif /* !GPU_DLB */
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
#ifndef GPU_DLB
          if (ics != ics_next || jcs != jcs_next) __syncthreads();
#endif
          /*
	  for (i=0; i<nao*3; i++) atomicAdd(&G[i0+i], Gi[i]);
	  for (i=0; i<nao; i++) atomicAdd(&G[j0+i], Gj[i]);
          */
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
          for (int ii=tidx;ii<numao;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
            {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
            }
          } // for ii 
          } // ics != ics_next
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } // for i
          } // jcs != jcs_next
    __syncthreads();
        }
#endif /* !USE_ATOMIC */
//	klcs = klcs0;
    }		// for ( ijcs );

#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) {
      int klcs, kl;
      int kcs,lcs,kao,lao;
      int kao0, lao0, k, l;
      klcs = i/9;
      kl = i - klcs*9;
      k = kl/3;
      l = kl - k*3;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs] + l;
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}

/** (pp,ps)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_128
gpu_twoint_direct_ppps_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=1, Lb=1, Lc=1, Ld=0;
    int Lab, Lcd;
    int Labcd = 4;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao0, jcs, jat, jao0;
    int kcs, kat, kao0, lcs, lat, lao0;
    double PPPS[3*3*3];
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[3];
    double *tbl = FMT_m_table3;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    double Gij[3];
    //double *Gij = &shared[tsize+1+tidx*3];
    size_t sOffset = tsize;
    tsize += nthb;
#else
    double *Gij = &shared[tidx*3];
    size_t tsize = nthb*3;
    size_t sOffset = 0;
#endif
#ifdef DLB_KL_PPPS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    mincs = MIN2(leading_cs[La], leading_cs[Lb]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[La+1], leading_cs[Lb+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*3;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lcd];
    ijcs1 = leading_cs_pair[Lcd+1];
    klcs0 = leading_cs_pair[Lab];
    klcs1 = leading_cs_pair[Lab+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*4; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_PPPS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
//        if(tidx==0) printf("%d:0 %d %d %d\n",tidx,ijcs,ics,jcs);
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else /* !USE_INSTANT_SCHWARZ */
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0 ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
#pragma unroll
        for (int i=0;i<3;i++) Gij[i] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
        __syncthreads();
        if(tidx == 0) {
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) + (A[0] = -LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) + (A[1] = -LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) + (A[2] = -LDG(atom_z[iat]));
        }
        __threadfence_block();
        __syncthreads();

//        if(tidx==0) printf("%d:k %d %d\n",tidx,klcs0,klcs1);
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
//	for (klcs = klcs0 ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_PPPS
  NOT supported combination of defines.
#endif
#else /* !USE_INSTANT_SCHWARZ */
#ifndef DLB_KL_PPPS
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else /* !DLB_KL_PPPS */
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* !DLB_KL_PPPS */
#endif /* !USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
//            int n2ei2 = 0;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
//         if (tidx==0) printf("%d:kl %d %d\n",tidx,klcs, klcs2);
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
//            Gjk = Gjl = ZERO;
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao0   = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            { // AC -> CA
              double dtmp;
              AC[0] = A[0] + (dtmp = LDG(atom_x[kat]));
              DC[0] = LDG(atom_x[lat]) - dtmp;
              AC[1] = A[1] + (dtmp = LDG(atom_y[kat]));
              DC[1] = LDG(atom_y[lat]) - dtmp;
              AC[2] = A[2] + (dtmp = LDG(atom_z[kat]));
              DC[2] = LDG(atom_z[lat]) - dtmp;
            }
/*
	    gpu_twoint_core_ppps_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      PPPS );
*/
// (ps,pp) -> (pp,ps)
#ifdef GPU_TWOINT_RYS
            gpu_twoint_core_rys_ppps
#else
	    gpu_twoint_core_ppps_
#endif
		   (&nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,   AC,      PPPS);
          {
            double coe;
            int iao, jao = jao0;
//            int j0 = jao*nao;
            double Gjl[3] = {ZERO, ZERO, ZERO};
            double Gil[9];
#pragma unroll
            for (int i=0;i<9;i++) Gil[i]=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<3; k++, kao++ ) {
//              int jk = j0 + kao;
              double Gjk = ZERO;
              double Gik[3] = {ZERO, ZERO, ZERO};
#pragma unroll
		for (int l=0, lao=lao0; l<3; l++, lao++ ) {
//                  int jl = j0 + lao;
                  double Gkl2 = ZERO;
//                  double Gjl = ZERO;
//                  int kl = kao*nao + lao;
		    if ( lao>kao ) { ix += 3; continue; }
		    coe = ( kao==lao ? HALF : ONE );
#pragma unroll
		    for (int i=0, iao=iao0; i<3; i++, iao++, ix++ ) {
                      double x = PPPS[ix];
//			if ( fabs(PPPS[ix]) > eps_eri ) {
			if ( fabs(x) > eps_eri ) {
                            double x4, dx;
			    x  *= coe;

			    x4 = 4.e0 * x;
                            x *= -x_coef;
                            /*
			    G[ij] += x4*Ds[kl];
			    G[kl] += x4*Ds[ij];
			    G[ik] -=  x*Ds[jl];
			    G[il] -=  x*Ds[jk];
			    G[jk] -=  x*Ds[il];
			    G[jl] -=  x*Ds[ik];
                            */
                        Gij[i] += x4*LDG(Ds[kao*nao+lao]);
                        Gkl2   += x4*LDG(Ds[jao0*nao+iao]);
                        Gjk    += x*LDG(Ds[lao*nao+iao]);
                        Gjl[l] += x*LDG(Ds[kao*nao+iao]);
                        Gik[i] += x*LDG(Ds[jao0*nao+lao]);
                        Gil[l*3+i] += x*LDG(Ds[jao0*nao+kao]);
			}	// if ( fabs );
		    }	// for ( iao )
#ifdef USE_ATOMIC
                  atomicAdd(&G[kao*nao+lao], Gkl2);
#else
                  Gkl[klcs2*9+k*3+l] += Gkl2;
#endif
		}	// for ( lao )
#ifdef USE_ATOMIC
              atomicAdd(&G[jao0*nao+kao], Gjk);
#pragma unroll
              for (int i=0,k0=kao*nao+iao0; i<3; i++) atomicAdd(&G[k0+i], Gik[i]);
#else
              Gj[kao] += Gjk;
#pragma unroll
              for (int i=0; i<3; i++) Gi[i*nao+kao] += Gik[i];
#endif
	    }	// for ( kao )
#ifdef USE_ATOMIC
#pragma unroll
            for (int l=0,jl=jao0*nao+lao0; l<3; l++,jl++)
              atomicAdd(&G[jl], Gjl[l]);
#pragma unroll
            for (int l=0,lao=lao0; l<3; l++,lao++) 
#pragma unroll
              for (int i=0,il=lao*nao+iao0; i<3; i++,il++)
                atomicAdd(&G[il], Gil[l*3+i]);
#else
#pragma unroll
            for (int l=0; l<3; l++) Gj[lao0+l] += Gjl[l];
#pragma unroll
            for (int l=0,lao=lao0; l<3; l++,lao++) 
#pragma unroll
              for (int i=0; i<3; i++)
                Gi[i*nao+lao] += Gil[l*3+i];
#endif
          } // block for additions
#ifdef DLB_KL_PPPS
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx] + tidw;
          } // while (iklcs)
#endif
	}	// for ( klcs );
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
#pragma unroll
      //for (i=0; i<3; i++) atomicAdd(&G[jao0*nao+iao0+i], Gij[i]);
      for (int i=0,ji=jao0*nao+iao0; i<3; i++) atomicAdd(&G[ji+i], Gij[i]);
#else
        {
#ifndef CUDA_FMT_M_SM
          double tGij[3];
          for (int i=0; i<3; i++) tGij[i] = Gij[i];
#else
          double *tGij = Gij;
#endif
          for (int i=0; i<3; i++) {
            double *ss = &shared[sOffset+tidx];
            __syncthreads();
            *ss = tGij[i];
            { // Reduce Gij within warp
              double *sGij = &shared[sOffset+widx*WARP_SIZE];
              warpReduce(sGij, tidw);
            }
            __syncthreads();
            if (tidx==0) { // Reduce Gij for warp masters
              double *sGij = &shared[sOffset];
              double dtmp = sGij[0];
              for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
              atomicAdd(&G[jao0*nao+iao0+i], dtmp);
            }
          } // i
        }
#endif
      __syncthreads();
#else
//	klcs = klcs0;
//        if (n2ei>0) {
        {
          int i,j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          int ijcs_next;
          int ics_next, jcs_next;
          ics_next=jcs_next=-1;
#pragma unroll
          for (i=0; i<3; i++) Gj[iao0+i] += Gij[i];
#ifdef GPU_DLB
          __syncthreads();
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else /* !GPU_DLB */
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif /* !GPU_DLB */
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
#ifndef GPU_DLB
          if (ics != ics_next || jcs != jcs_next) __syncthreads();
#endif
          /*
          if (ics != ics_next) {
	  for (i=0; i<nao*3; i++) atomicAdd(&G[iao0*nao+i], Gi[i]);
	  for (i=0; i<nao*3; i++) Gi[i]=ZERO;
          }
          if (jcs != jcs_next) {
	  for (i=0; i<nao; i++) atomicAdd(&G[jao0*nao+i], Gj[i]);
	  for (i=0; i<nao; i++) Gj[i]=ZERO;
          }
          */
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
            {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
            }
          } // for ii 
          } // ics != ics_next
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*3 + i; // warning!
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } // for i
          } // jcs != jcs_next
    __syncthreads();
        }
#endif /* !USE_ATOMIC */
//	klcs = klcs0;
    }		// for ( ijcs );
#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) {
      int klcs, kl;
      int kcs,lcs,kao,lao;
      int kao0, lao0, k, l;
      klcs = i/9;
      kl = i - klcs*9;
      k = kl/3;
      l = kl - k*3;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs] + l;
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}


/** (pp,pp)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_255
gpu_twoint_direct_pppp_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=1, Lb=1, Lc=1, Ld=1;
    int Lab, Lcd;
    int Labcd = 5;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int klps0, nklps;
//    int kcs, kat, kao0, lcs, lat, lao0;
    double PPPP[3*3*3*3];
//    double PPPP[3*3*3*3], pppp;
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
    int ijc;
    double Gij[9];
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[4];
    double *tbl = FMT_m_table4;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    double stmp[3];
    size_t sOffset = tsize;
    tsize += nthb;
#else
    double *stmp = (double *)&shared[tidx*3];
    size_t tsize = nthb*3;
    size_t sOffset = 0;
#endif
#ifdef DLB_KL_PPPP
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    mincs = MIN2(leading_cs[Lc], leading_cs[Ld]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[Lc+1], leading_cs[Ld+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*3;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*6; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx;
//      ijcsw = ijcs0 + iwkblk;
      nijcsw = 0;
    }
    /*
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    */
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (ijcs=ijcs0+iwkblk; ijcs<ijcs1; ijcs+=nwkblk ) {
#endif
//        double A[3], BA[3];
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs1 - 1 - (ijcsw - ijcs0);
#endif
#ifdef DLB_KL_PPPP
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
        ics    = csp_ics[ijcs];
        jcs    = csp_jcs[ijcs];
        klcs0a = klcs0;
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else
        {
          float val_ab = csp_schwarz[ijcs];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
          for (int klcs = klcs0a+tidx ; klcs<=ijcs; klcs+=nthb) {
//	  for (int klcs = ijcs-tidx; klcs>=klcs0a ; klcs-=nthb) {
              int kcs, lcs;
              int iklcs;
              float dmax;
              float val_abcd = val_ab * csp_schwarz[klcs];
              if ( val_abcd < eps_ps4 ) continue;
              kcs    = csp_ics[klcs];
              lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
              if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif
#pragma unroll
        for (int i=0;i<9;i++) Gij[i] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
        {
          /*
        double B[3];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
#pragma unroll
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
	BA[0] =LDG(atom_x[jat]) - (A[0]=LDG(atom_x[iat]));
	BA[1] =LDG(atom_y[jat]) - (A[1]=LDG(atom_y[iat]));
	BA[2] =LDG(atom_z[jat]) - (A[2]=LDG(atom_z[iat]));
        }
        __threadfence_block();
        __syncthreads();
	
//	for ( ; klcs<=ijcs; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs = klcs0a+tidx ; klcs<=ijcs; klcs+=nthb ) {
#else
#ifndef DLB_KL_PPPP
        for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
#else
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* DLB_KL */
#endif
            int klcs2;
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
            int ipat, ijgekl;
            double DC[3], AC[3];
#ifdef USE_INSTANT_SCHWARZ
            {
	    float val_abcd = val_ab * csp_schwarz[klcs];
            float dmax;
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
            }
#else
            int klcs;
            klcs = sklcs[iklcs];
#endif
            klcs2 = (klcs - klcs0)*9;
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao0   = LDG(shel_ini[lcs]);
            {
              double C[3],D[3];
	    C[0]=LDG(atom_x[kat]); C[1]=LDG(atom_y[kat]); C[2]=LDG(atom_z[kat]);
	    D[0]=LDG(atom_x[lat]); D[1]=LDG(atom_y[lat]); D[2]=LDG(atom_z[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            }
	    gpu_twoint_core_pppp_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      PPPP );
            {
              double Gkl2[9];
              for (int i=0;i<9;i++) Gkl2[i]=ZERO;
	    ipat = ( (ics==kcs && jcs>lcs) ? true : false );
            ijgekl = (ics>kcs);
            if (ics==kcs) ijgekl= (jcs>=lcs);
            if (!ijgekl) ipat = ( (ics==kcs && jcs<lcs) ? true : false);
#pragma unroll
	    for (int i=0, iao=iao0; i<3; i++, iao++ ) {
              int i0 = iao*nao;
              double Gik[3]={ZERO,ZERO,ZERO};
              double Gil[3]={ZERO,ZERO,ZERO};
              int I2;
		I2 = iao*(iao+1)/2;
#pragma unroll
		for (int  j=0, jao=jao0; j<3; j++, jao++ ) {
                  int j0 = jao*nao;
                  int ij = i0 + jao;
                  double coe0;
                  //double Gjk[3]={ZERO,ZERO,ZERO};
                  //double *Gjk = stmp;
                  double Gjk[3]={ZERO,ZERO,ZERO};
                  double Gjl[3]={ZERO,ZERO,ZERO};
                  int IJ;
                  //Gjk[0] = ZERO; Gjk[1] = ZERO; Gjk[2] = ZERO;
		    if ( jao>iao ) continue;
		    IJ = I2 + jao;
		    coe0 = ( iao==jao ? HALF : ONE );
#pragma unroll
		    for (int k=0, kao=kao0; k<3; k++, kao++ ) {
                      int K2;
			K2 = kao*(kao+1)/2;
#pragma unroll
			for (int l=0, lao=lao0; l<3; l++, lao++ ) {
                          double x;
			    if ( lao>kao ) continue;
			    x = PPPP[i*27+j*9+k*3+l];
			    if ( fabs(x) > eps_eri ) {
//				int ij, ik, il, jk, jl, kl, i0, j0;
				int kl;
                                int KL;
				KL = K2 + lao;
//				if ( IJ >= KL  || ipat ) {
				if ((ijgekl&&IJ >= KL) || (!ijgekl&&KL>=IJ) || ipat ) {
                                  double x4, dx;
                                  /*
				    coe = coe0;
				    if ( kao==lao ) coe *= HALF;
				    if ( KL == IJ ) coe *= HALF;
				    x  = coe * pppp;
                                  */
				    x *= coe0;
				    if ( kao==lao ) x *= HALF;
				    if ( KL == IJ ) x *= HALF;
                                    x4 = 4.0 * x;
                                    x *= -x_coef;

                                    /*
				    x4 = 4.e0 * x;
				    i0 = iao*nao;
				    j0 = jao*nao;
				    ij = i0 + jao;
				    ik = i0 + kao;
				    il = i0 + lao;
				    jk = j0 + kao;
				    jl = j0 + lao;
                                    */
				    kl = kao*nao + lao;
                                    /*
				    G[ij] += x4*Ds[kl];
				    G[kl] += x4*Ds[ij];
				    G[ik] -=  x*Ds[jl];
				    G[il] -=  x*Ds[jk];
				    G[jk] -=  x*Ds[il];
				    G[jl] -=  x*Ds[ik];
                                    */
                                    Gik[k] += x*LDG(Ds[j0+lao]);
                                    Gil[l] += x*LDG(Ds[j0+kao]);
                                    Gjk[k] += x*LDG(Ds[i0+lao]);
                                    Gjl[l] += x*LDG(Ds[i0+kao]);

                                    Gij[i*3+j]  += x4*LDG(Ds[kl]);
                                    Gkl2[k*3+l] += x4*LDG(Ds[ij]);
				}
			    } // if ( fabs )
			} // for ( lao )
		    } // for ( kao )
#ifdef USE_ATOMIC
#pragma unroll
                  for (int k=0; k<3; k++) {
                    int jk = jao*nao + kao0 + k;
                    int jl = jao*nao + lao0 + k;
                    if (kcs==lcs) Gjk[k] += Gjl[k];
                    else atomicAdd(&G[jl], Gjl[k]);
                    atomicAdd(&G[jk], Gjk[k]);
                  }
#else
#pragma unroll
                  for (int k=0; k<3; k++) {
                    Gj[j*nao+lao0+k] += Gjl[k];
                    Gj[j*nao+kao0+k] += Gjk[k];
                  }
#endif
		} // for ( jao )
#ifdef USE_ATOMIC
#pragma unroll
              for (int k=0; k<3; k++) {
                int ik = iao*nao + kao0 + k;
                int il = iao*nao + lao0 + k;
                if (kcs==lcs) Gik[k] += Gil[k];
                else atomicAdd(&G[il], Gil[k]);
                atomicAdd(&G[ik], Gik[k]);
              }
#else
#pragma unroll
              for (int k=0; k<3; k++) {
                Gi[i*nao+kao0+k] += Gik[k];
                Gi[i*nao+lao0+k] += Gil[k];
              }
#endif
	    }	// for ( iao )
#ifdef USE_ATOMIC
#pragma unroll
            for (int k=0, kao=kao0; k<3; k++, kao++ ) 
#pragma unroll
              for (int l=0, lao=lao0; l<3; l++, lao++ ) 
                atomicAdd(&G[kao*nao+lao],Gkl2[k*3+l]);
#else
#pragma unroll
            for (int kl=0; kl<9; kl++) 
              Gkl[klcs2+kl] += Gkl2[kl];
#endif
          } // block for additions
#ifdef DLB_KL_PPPP
          if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
          iklcs = klcsw[widx] + tidw;
          }; // while (iklcs)
#endif
	}	// for ( klcs );
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
//            ijc++;
//            ijcsw = ijcs0 + iwk + ijc*nwks;
//            ijcsw = ijcs0 + ijc*nwks + (iwk + ijc*3)%nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
//            ijc = atomicAdd(p_ijcounter,NIJCSW);
//            ijcsw = ijcs0 + iwk + ijc*nwks;
//            ijcsw = ijcs0 + ijc*nwks + (iwk + ijc*3)%nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
        {
          double *sGij0 = (double *)&shared[sOffset+tidx];
          __syncthreads();
#pragma unroll
          for (int i=0,iao=iao0;i<3;i++,iao++) {
#pragma unroll
            for (int j=0,jao=jao0; j<3; j++,jao++) {
              //atomicAdd(&G[iao*nao+jao],Gij[i*3+j]);
              {
                double *sGij = &shared[sOffset+widx*WARP_SIZE];
                *sGij0 = Gij[i*3+j];
                warpReduce(sGij, tidw);
              }
              __syncthreads();
              if (tidx==0) { // Reduce Gij for warp masters
                double *sGij = &shared[sOffset];
                double dtmp = sGij[0];
                for (int k=1; k<nwrp; k++) dtmp += sGij[k*WARP_SIZE];
                //G[iao*nao+jao] += dtmp;
                atomicAdd(&G[iao*nao+jao], dtmp);
              }
              __syncthreads();
            }
          }
        }
        __syncthreads();
#else
//	klcs = klcs0;
//        if (n2ei>0) {
        {
          int j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          int ijcs_next;
          int ics_next=-1, jcs_next=-1;
#pragma unroll
          for (int i=0;i<3;i++) {
#pragma unroll
            for (int j=0,jao=jao0; j<3; j++,jao++) {
              Gi[i*nao+jao] += Gij[i*3+j];
            }
          }
    __syncthreads();
#ifdef GPU_DLB
//          ijcs_next = ijcsw;
          ijcs_next = ijcs1 - ijcsw + 1;
          ijcs_next = ijcs1 - 1 - (ijcsw - ijcs0);
          if (ijcsw<ijcs1) {
#else
          ijcs_next = ijcs+nwkblk;
          if (ijcs_next<ijcs1) {
#endif
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
//          for (int ii=tidx;ii<nao*3;ii+=nthb) {
//            i = (ii/nao)*nao + ii%nao;
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            int i = (ii/numao)*nao + ii%numao + minao;
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
          } 
          }
         // if (jcs != jcs_next) {
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
//          for (i=minao+tidx;i<=maxao;i+=nthb) {
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            int i = (ii/numao)*nao + ii%numao + minao;
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*3 + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } 
          }
    __syncthreads();
//	  for ( i=0; i<nao*3; i++ ) Gi[i]=ZERO;
//	  for ( i=0; i<nao; i++ ) Gj[i]=ZERO;
        }
#endif /* USE_ATOMIC */
//	klcs = klcs0;
    }		// for ( ijcs );

#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) {
      int klcs, kl;
      int kcs,lcs,kao,lao;
      int kao0, lao0, k, l;
      klcs = i/9;
      kl = i - klcs*9;
      k = kl/3;
      l = kl - k*3;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs] + l;
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}

/** (ds,ss)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_128
gpu_twoint_direct_dsss_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=2, Lb=0, Lc=0, Ld=0;
    int Lab, Lcd;
    int Labcd = 6;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, lcs, lat, lao;
    double DSSS[6];
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
//    double coe;
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int minao1[2], maxao1[2];
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[2];
    double *tbl = FMT_m_table2;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    double Gij[1];
    //double Gil[1];
    //double Gjl[1];
    //double *Gij = &shared[tsize+tidx];
    //double *Gij = &shared[tsize+1+tidx+nthb];
    //double *Gij = &shared[tsize+1+tidx+nthb*2];
    size_t sOffset = tsize;
    tsize += nthb;
#else
    size_t sOffset = 0;
    double *Gij = &shared[tidx];
    //double *Gil = &shared[tidx+nthb];
    //double *Gjl = &shared[tidx+nthb*2];
    size_t tsize = nthb*3;
#endif
#ifdef DLB_KL_DSSS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    minao1[0] = shel_ini[leading_cs[La]];
    minao1[1] = shel_ini[leading_cs[Lb]];
    minao = MIN2(minao1[0], minao1[1]);
    maxao1[0] = shel_ini[leading_cs[La+1]] - 1;
    maxao1[1] = shel_ini[leading_cs[Lb+1]] - 1;
    maxao = MAX2(maxao1[0], maxao1[1]);
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lcd];
    ijcs1 = leading_cs_pair[Lcd+1];
    klcs0 = leading_cs_pair[Lab];
    klcs1 = leading_cs_pair[Lab+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*2; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*6; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_DSSS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
//        if(tidx==0) printf("%d:0 %d %d %d\n",tidx,ijcs,ics,jcs);
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else /* !USE_INSTANT_SCHWARZ */
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0 ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
        *Gij  = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao    = shel_ini[ics];
	jao    = shel_ini[jcs];
        __syncthreads();
        if(tidx == 0) {
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) + (A[0] = -LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) + (A[1] = -LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) + (A[2] = -LDG(atom_z[iat]));
        }
        __threadfence_block();
        __syncthreads();

//        if(tidx==0) printf("%d:k %d %d\n",tidx,klcs0,klcs1);
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
//	for (klcs = klcs0 ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_DSSS
  NOT supported combination of defines.
#endif
#else /* !USE_INSTANT_SCHWARZ */
#ifndef DLB_KL_DSSS
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else /* !DLB_KL_DSSS */
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* !DLB_KL_DSSS */
#endif /* !USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
            int jk, jl, j0;
            int kao0, lao0, kao, lao;
//            int n2ei2 = 0;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
//         if (tidx==0) printf("%d:kl %d %d\n",tidx,klcs, klcs2);
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
//            Gjk = Gjl = ZERO;
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao    = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            {
              double dtmp;
              AC[0] = A[0] + (dtmp = LDG(atom_x[kat]));
              DC[0] = LDG(atom_x[lat]) - dtmp;
              AC[1] = A[1] + (dtmp = LDG(atom_y[kat]));
              DC[1] = LDG(atom_y[lat]) - dtmp;
              AC[2] = A[2] + (dtmp = LDG(atom_z[kat]));
              DC[2] = LDG(atom_z[lat]) - dtmp;
            }

/*
	    gpu_twoint_core_dsss_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DSSS );
*/
// (ss,ds) -> (ds,ss)
	    //gpu_twoint_core_dsss_(
	    gpu_twoint_core_os_dsss(
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,   AC,      DSSS );

            {
	    double coe = ( iao == jao ? HALF : ONE );
            //*Gil  = ZERO;
            //*Gjl  = ZERO;
            double Gil  = ZERO;
            double Gjl  = ZERO;
#pragma unroll
	    for (int k=0, kao=kao0; k<6; k++, kao++ ) {
		if ( fabs(DSSS[k]) > eps_eri ) {
		    double x, x4;
                    double dx;
		    int ij, ik, il, jk, jl, kl, i0, j0;
		    x  = coe * DSSS[k];

		    x4 = 4.e0 * x;
                    x *= -x_coef;
		    i0 = iao*nao;
		    j0 = jao*nao;
		    ij = i0 + jao;
		    ik = i0 + kao;
		    il = i0 + lao;
		    jk = j0 + kao;
		    jl = j0 + lao;
		    kl = kao*nao + lao;
                    /*
		    G[ij] += x4*Ds[kl];
		    G[kl] += x4*Ds[ij];
		    G[ik] -=  x*Ds[jl];
		    G[il] -=  x*Ds[jk];
		    G[jk] -=  x*Ds[il];
		    G[jl] -=  x*Ds[ik];
                    */
		    *Gij += x4*LDG(Ds[kl]);
		    Gil += x*LDG(Ds[jk]);
		    Gjl += x*LDG(Ds[ik]);
#ifdef USE_ATOMIC
		    dx = x4*LDG(Ds[ij]);
		    atomicAdd(&G[kl], dx);
		    dx = x*LDG(Ds[jl]);
		    atomicAdd(&G[ik], dx);
		    dx = x*LDG(Ds[il]);
		    atomicAdd(&G[jk], dx);
#else
                    Gkl[klcs2*6+k] += x4*LDG(Ds[ij]);
                    Gi[kao] += x*LDG(Ds[jl]);
                    Gj[kao] += x*LDG(Ds[il]);
#endif
		}
	    }	// for ( k, kao);
#ifdef USE_ATOMIC
            atomicAdd(&G[iao*nao+lao], Gil);
            atomicAdd(&G[jao*nao+lao], Gjl);
#else
            Gi[lao] += Gil;
            Gj[lao] += Gjl;
#endif
            } // block for additions
#ifdef DLB_KL_DSSS
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx] + tidw;
          } // while (iklcs)
#endif
	}	// for ( klcs );
//	klcs = klcs0;
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
        atomicAdd(&G[iao*nao+jao], *Gij);
#else
        shared[sOffset+tidx] = *Gij;
          { // Reduce Gij within warp
            //double *sGij = &shared[widx*WARP_SIZE];
            double *sGij = &shared[sOffset+widx*WARP_SIZE];
            warpReduce(sGij, tidw);
          }
          __syncthreads();
          if (tidx==0) { // Reduce Gij for warp masters
            //double *sGij = &shared[0];
            double *sGij = &shared[sOffset];
            double dtmp = sGij[0];
            for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
            atomicAdd(&G[iao*nao+jao], dtmp);
          }
#endif
        __syncthreads();
#else /* !USE_ATOMIC */
        Gi[jao] += *Gij;
        {
          int i, j;
          int nGi;
          int bs;
	  int i0 = iao*nao;
	  int j0 = jao*nao;
          int ijcs_next;
          int ics_next, jcs_next;
          ics_next=jcs_next=-1;
#ifdef GPU_DLB
          __syncthreads();
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else /* !GPU_DLB */
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif /* !GPU_DLB */
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
#ifndef GPU_DLB
          if (ics != ics_next || jcs != jcs_next) __syncthreads();
#endif
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
#ifdef ADD_FULL_NAO
          for (i=minao+tidx;i<=maxao;i+=nthb) {
#else
          for (int k=0;k<2;k++) {
          for (i=minao1[k]+tidx;i<=maxao1[k];i+=nthb) {
#endif
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
          } // for i
#ifndef ADD_FULL_NAO
          } // for k
#endif
          } // ics != ics_next
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
#ifdef ADD_FULL_NAO
          for (i=minao+tidx;i<=maxao;i+=nthb) {
#else
          for (int k=0;k<2;k++) {
          for (i=minao1[k]+tidx;i<=maxao1[k];i+=nthb) {
#endif
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } // for i
#ifndef ADD_FULL_NAO
          } // for k
#endif
          } // jcs != jcs_next
    __syncthreads();
        }
#endif /* !USE_ATOMIC */
    }		 // for ( ijcs );

#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*6; i+=nthb) {
      int klcs, k;
      int kcs,lcs,kao,lao;
      klcs = i/6;
      k = i - klcs*6;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs];
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}

/** (ds,ps)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_128
gpu_twoint_direct_dsps_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=2, Lb=0, Lc=1, Ld=0;
    int Lab, Lcd;
    int Labcd = 7;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao0, jcs, jat, jao0;
    int kcs, kat, kao0, lcs, lat, lao0;
    double DSPS[6*3];
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int minao1[2], maxao1[2];
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[3];
    double *tbl = FMT_m_table3;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    size_t sOffset = tsize;
    double Gij[3];
    //double *Gij = &shared[sOffset+tidx*3];
    tsize += nthb;
#else
    size_t sOffset = 0;
    double *Gij = &shared[tidx*3];
    size_t tsize = nthb*3;
#endif
#ifdef DLB_KL_DSPS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    minao1[0] = shel_ini[leading_cs[La]];
    minao1[1] = shel_ini[leading_cs[Lb]];
    minao = MIN2(minao1[0], minao1[1]);
    maxao1[0] = shel_ini[leading_cs[La+1]] - 1;
    maxao1[1] = shel_ini[leading_cs[Lb+1]] - 1;
    maxao = MAX2(maxao1[0], maxao1[1]);
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*3;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lcd];
    ijcs1 = leading_cs_pair[Lcd+1];
    klcs0 = leading_cs_pair[Lab];
    klcs1 = leading_cs_pair[Lab+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*4; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*6*1; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_DSPS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
//        if(tidx==0) printf("%d:0 %d %d %d\n",tidx,ijcs,ics,jcs);
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else /* !USE_INSTANT_SCHWARZ */
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0 ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
#pragma unroll
        for (int i=0;i<3;i++) Gij[i] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
        __syncthreads();
        if(tidx == 0) {
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) + (A[0] = -LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) + (A[1] = -LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) + (A[2] = -LDG(atom_z[iat]));
        }
        __threadfence_block();
        __syncthreads();

//        if(tidx==0) printf("%d:k %d %d\n",tidx,klcs0,klcs1);
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
	
//	for (klcs = klcs0 ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_DSPS
  NOT supported combination of defines.
#endif
#else /* !USE_INSTANT_SCHWARZ */
#ifndef DLB_KL_DSPS
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else /* !DLB_KL_DSPS */
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* !DLB_KL_DSPS */
#endif /* !USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
//            int n2ei2 = 0;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
//         if (tidx==0) printf("%d:kl %d %d\n",tidx,klcs, klcs2);
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao0   = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            {
              double dtmp;
              AC[0] = A[0] + (dtmp = LDG(atom_x[kat]));
              DC[0] = LDG(atom_x[lat]) - dtmp;
              AC[1] = A[1] + (dtmp = LDG(atom_y[kat]));
              DC[1] = LDG(atom_y[lat]) - dtmp;
              AC[2] = A[2] + (dtmp = LDG(atom_z[kat]));
              DC[2] = LDG(atom_z[lat]) - dtmp;
            }
/*
	    gpu_twoint_core_dsps_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DSPS );
*/
// (ps,ds) -> (ds,ps)
	    //gpu_twoint_core_dsps_(
#ifdef GPU_TWOINT_RYS
	    gpu_twoint_core_rys_dsps
#else
	    gpu_twoint_core_os_dsps
#endif
                   (&nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,   AC,      DSPS);
            {
              int iao, jao, kao, lao;
              int ix = 0;
              double Gjl = ZERO;
              double Gil[3] = {ZERO,ZERO,ZERO};
              jao = jao0;
              lao = lao0;
#pragma unroll
              for (int k=0, kao=kao0; k<6; k++, kao++ ) {
                double Gjk = ZERO;
                double Gkl2 = ZERO;
#pragma unroll
		for (int i=0, iao=iao0; i<3; i++, iao++, ix++ ) {
		    if ( fabs(DSPS[ix]) > eps_eri ) {
			double x, x4;
                        double dx;
			int ij, ik, il, jk, jl, kl, i0, j0;
			x  = DSPS[ix];

			x4 = 4.e0 * x;
                        x *= -x_coef;
			i0 = iao*nao;
			j0 = jao*nao;
			ij = i0 + jao;
			ik = i0 + kao;
			il = i0 + lao;
			jk = j0 + kao;
			jl = j0 + lao;
			kl = kao*nao + lao;
                        /*
			G[ij] += x4*Ds[kl];
			G[kl] += x4*Ds[ij];
			G[ik] -=  x*Ds[jl];
			G[il] -=  x*Ds[jk];
			G[jk] -=  x*Ds[il];
			G[jl] -=  x*Ds[ik];
                        */
                        Gij[i] += x4*LDG(Ds[kao*nao+lao]);
			Gjk += x*LDG(Ds[iao*nao+lao]);
			Gjl += x*LDG(Ds[iao*nao+kao]);
			Gil[i] += x*LDG(Ds[jao*nao+kao]);
                        Gkl2 += x4*LDG(Ds[iao*nao+jao]);
#ifdef USE_ATOMIC
			dx = x*LDG(Ds[jl]);
                        atomicAdd(&G[ik], dx);
#else
                        Gi[i*nao+kao] += x*LDG(Ds[jao*nao+lao]);
#endif
		    }
		}  // for (i, iao);
#ifdef USE_ATOMIC
                atomicAdd(&G[jao*nao+kao], Gjk);
                atomicAdd(&G[kao*nao+lao], Gkl2);
#else
                Gj[kao] += Gjk;
                Gkl[klcs2*6+k] += Gkl2;
#endif
	    }	// for ( k, kao);
#ifdef USE_ATOMIC
            atomicAdd(&G[jao*nao+lao], Gjl);
#pragma unroll
            for (int i=0,iao=iao0;i<3;i++,iao++)
              atomicAdd(&G[iao*nao+lao], Gil[i]);
#else
            Gj[lao] += Gjl;
#pragma unroll
            for (int i=0,iao=iao0;i<3;i++,iao++)
              Gi[i*nao+lao] += Gil[i];
#endif
          } // block for additions
#ifdef DLB_KL_DSPS
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx] + tidw;
          } // while (iklcs)
#endif
	}	// for ( klcs );
//	klcs = klcs0;

#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
#pragma unroll
        for (int i=0; i<3; i++)
          atomicAdd(&G[jao0*nao+iao0+i], Gij[i]);
#else
        {
#ifndef CUDA_FMT_M_SM
          double tGij[3];
          for (int i=0; i<3; i++) tGij[i] = Gij[i];
#else
          double *tGij = Gij;
#endif
          for (int i=0; i<3; i++) {
            double *ss = &shared[sOffset+tidx];
            __syncthreads();
            *ss = tGij[i];
            { // Reduce Gij within warp
              double *sGij = &shared[sOffset+widx*WARP_SIZE];
              warpReduce(sGij, tidw);
            }
            __syncthreads();
            if (tidx==0) { // Reduce Gij for warp masters
              double *sGij = &shared[sOffset];
              double dtmp = sGij[0];
              for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
              atomicAdd(&G[jao0*nao+iao0+i], dtmp);
            }
          } // i
        }
#endif
        __syncthreads();
#else
#pragma unroll
        for (int i=0; i<3; i++) Gi[i*nao+jao0] += Gij[i];
        {
          int i, j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          int ijcs_next;
          int ics_next, jcs_next;
          ics_next=jcs_next=-1;
#ifdef GPU_DLB
          __syncthreads();
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else /* !GPU_DLB */
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif /* !GPU_DLB */
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
#ifndef GPU_DLB
          if (ics != ics_next || jcs != jcs_next) __syncthreads();
#endif
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
#ifdef ADD_FULL_NAO
          //for (i=minao+tidx;i<=maxao;i+=nthb) {
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
#else
          for (int k=0;k<2;k++) {
//          for (i=minao1[k]+tidx;i<=maxao1[k];i+=nthb) {
          int numao1=maxao1[k]-minao1[k]+1;
          for (int ii=tidx;ii<numao1*3;ii+=nthb) {
            i = (ii/numao1)*nao + ii%numao1 + minao1[k];
#endif
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
          } // for i
#ifndef ADD_FULL_NAO
          } // for k
#endif
          } // ics != ics_next
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
#ifdef ADD_FULL_NAO
          for (i=minao+tidx;i<=maxao;i+=nthb) {
#else
          for (int k=0;k<2;k++) {
          for (i=minao1[k]+tidx;i<=maxao1[k];i+=nthb) {
#endif
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*3 + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } // for i
#ifndef ADD_FULL_NAO
          } // for k
#endif
          } // jcs != jcs_next
    __syncthreads();
        }
#endif /* !USE_ATOMIC */
    }		// for ( ijcs );

#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*6; i+=nthb) {
      int klcs, k;
      int kcs,lcs,kao,lao;
      klcs = i/6;
      k = i - klcs*6;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs];
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}

/** (ds,pp)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_255
gpu_twoint_direct_dspp_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=2, Lb=0, Lc=1, Ld=1;
    int Lab, Lcd;
    int Labcd = 8;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao0, jcs, jat, jao0;
    int kcs, kat, kao0, lcs, lat, lao0;
    double DSPP[6*3*3];
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int minao1[2], maxao1[2];
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
//    double *Gij = &shared[tidx*3];
    double Gij[6*1];
//    double *stmp = (double *)&shared[tidx*3];
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[4];
    double *tbl = FMT_m_table4;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    size_t sOffset = tsize;
    tsize += nthb;
#else
    size_t tsize = nthb*3;
    size_t sOffset = 0;
#endif
#ifdef DLB_KL_DSPP
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    mincs = MIN2(leading_cs[Lc], leading_cs[Ld]);
    minao = shel_ini[mincs];
    maxcs = MAX2(leading_cs[Lc+1], leading_cs[Ld+1]) - 1;
    maxao = shel_ini[maxcs+1]-1;
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*6;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lab];
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*(6+1); i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_DSPP
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
        klcs0a = klcs0;
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0a+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0a ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
#pragma unroll
        for (int i=0;i<1*6;i++) Gij[i] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) - (A[0] = LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) - (A[1] = LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) - (A[2] = LDG(atom_z[iat]));

        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        klcs0a = klcs0;
//	for (klcs = klcs0a ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0a+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_DSPP
  NOT supported combination of defines.
#endif
#else
#ifndef DLB_KL_DSPP
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* DLB_KL */
#endif /* USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
            int jk, jl, j0;
//            int n2ei2 = 0;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao0   = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            {
            double dtmp;
            AC[0] = A[0] - (dtmp = LDG(atom_x[kat]));
            DC[0] = LDG(atom_x[lat]) - dtmp;
            AC[1] = A[1] - (dtmp = LDG(atom_y[kat]));
            DC[1] = LDG(atom_y[lat]) - dtmp;
            AC[2] = A[2] - (dtmp = LDG(atom_z[kat]));
            DC[2] = LDG(atom_z[lat]) - dtmp;
            }
	    //gpu_twoint_core_dspp_(
	    gpu_twoint_core_os_dspp(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DSPP );
            {
              int jao=jao0;
              int j0=jao*nao;
              double Glk2[3*3];
              double Gjk[3]={ZERO,ZERO,ZERO};
#pragma unroll
              for (int kl=0;kl<3*3;kl++) Glk2[kl]=ZERO;
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
                int i0=iao*nao;
                int ij=i0+jao;
                double Gjl[3]={ZERO,ZERO,ZERO};
                double Gil[3]={ZERO,ZERO,ZERO};
		for (int k=0, kao=kao0; k<3; k++, kao++ ) {
                    int jk=jao*nao+kao;
                    int ik=iao*nao+kao;
                    double Gik=ZERO;
                    //double Gjk=ZERO;
		    for (int  l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			//if ( lao > kao ) continue;
			if ( lao <= kao && fabs(DSPP[ix]) > eps_eri ) {
			    double coe = ( kao == lao ? HALF : ONE );
			    double x, x4;
                            double dx;
			    //int ij, ik, il, jk, jl, kl, i0, j0;
			    int il, jl, kl;
			    x  = coe * DSPP[ix];

			    x4 = 4.e0 * x;
                            x *= -x_coef;
			    il = i0 + lao;
			    jl = j0 + lao;
			    kl = kao*nao + lao;
                            /*
			    G[ij] += x4*Ds[kl];
			    G[kl] += x4*Ds[ij];
			    G[ik] -=  x*Ds[jl];
			    G[il] -=  x*Ds[jk];
			    G[jk] -=  x*Ds[il];
			    G[jl] -=  x*Ds[ik];
                            */
                        Glk2[k*3+l] += x4*LDG(Ds[ij]);
                        Gij[i] += x4*LDG(Ds[kl]);
                        Gik    += x*LDG(Ds[jl]);
                        Gjk[k] += x*LDG(Ds[il]);
                        Gjl[l] += x*LDG(Ds[ik]);
                        Gil[l] += x*LDG(Ds[jk]);
			}
		    } // l
#ifdef USE_ATOMIC
                    atomicAdd(&G[ik], Gik);
#else
                    Gi[i*nao+kao] += Gik;
#endif
		} // k
#ifdef USE_ATOMIC
#pragma unroll
                for (int l=0,jl=j0+lao0;l<3;l++,jl++) atomicAdd(&G[jl],Gjl[l]);
#pragma unroll
                for (int l=0,il=i0+lao0;l<3;l++,il++) atomicAdd(&G[il],Gil[l]);
#else
#pragma unroll
                for (int l=0,lao=lao0;l<3;l++,lao++) Gj[lao] += Gjl[l];
#pragma unroll
                for (int l=0,il=i*nao+lao0;l<3;l++,il++) Gi[il] += Gil[l];
#endif /* USE_ATOMIC */
	    }	// for ( i, iao);
#ifdef USE_ATOMIC
#pragma unroll
            for (int k=0, kao=kao0; k<3; k++, kao++ ) 
#pragma unroll
              for (int l=0, lao=lao0; l<3; l++, lao++ ) 
                atomicAdd(&G[kao*nao+lao], Glk2[k*3+l]);
#pragma unroll
            for (int k=0, kao=kao0; k<3; k++, kao++ ) 
              atomicAdd(&G[j0+kao], +Gjk[k]);
#else
#pragma unroll
            for (int kl=0; kl<3*3; kl++)
              Gkl[klcs2*9+kl] += Glk2[kl];
#pragma unroll
            for (int k=0, kao=kao0; k<3; k++, kao++ ) 
              Gj[kao] += Gjk[k];
#endif /* USE_ATOMIC */
          } // block for additions
#ifdef DLB_KL_DSPP
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx] + tidw;
          } // while (iklcs)
#endif
	}	// for ( klcs );
//	klcs = klcs0;
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
#pragma unroll
        for (int i=0,ij=jao0*nao+iao0; i<6; i++,ij++)
          atomicAdd(&G[ij], Gij[i]);
#else
        {
          for (int i=0; i<6; i++) {
            double *ss = &shared[sOffset+tidx];
            __syncthreads();
            *ss = Gij[i];
            { // Reduce Gij within warp
              double *sGij = &shared[sOffset+widx*WARP_SIZE];
              warpReduce(sGij, tidw);
            }
            __syncthreads();
            if (tidx==0) { // Reduce Gij for warp masters
              double *sGij = &shared[sOffset];
              double dtmp = sGij[0];
              for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
              atomicAdd(&G[jao0*nao+iao0+i], dtmp);
            }
          } // i
        }
#endif
        __syncthreads();
#else /* !USE_ATOMIC */
//#pragma unroll
        //for (int i=0; i<6; i++) Gj[iao0+i] += Gij[i];
        {
          int i, j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          int ijcs_next;
          int ics_next, jcs_next;
          for (i=0; i<6; i++) {
          double *ss = &shared[sOffset+tidx];
          __syncthreads();
          *ss = Gij[i];
          { // Reduce Gij within warp
            double *sGij = &shared[sOffset+widx*WARP_SIZE];
            warpReduce(sGij, tidw);
          }
          __syncthreads();
          if (tidx==0) { // Reduce Gij for warp masters
            double *sGij = &shared[sOffset];
            double dtmp = sGij[0];
            for (j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
            G[j0+iao0+i] += dtmp;
          }
          } // i
          ics_next=jcs_next=-1;
#ifdef GPU_DLB
          __syncthreads();
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else /* !GPU_DLB */
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif /* !GPU_DLB */
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
#ifndef GPU_DLB
          if (ics != ics_next || jcs != jcs_next) __syncthreads();
#endif
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
          for (int ii=tidx;ii<numao*6;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
          } // for i
          } // ics != ics_next
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*6 + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } // for i
          } // jcs != jcs_next
    __syncthreads();
        }
#endif /* !USE_ATOMIC */
    }		// for ( ijcs );

#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*3*3; i+=nthb) {
      int klcs, kl;
      int k, l;
      int kcs,lcs,kao,lao;
      klcs = i/9;
      kl = i - klcs*9;
      k = kl/3;
      l = kl-k*3;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs] + l;
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}

#ifdef DUMMY
/** (ds,ds)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dsds_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, k, ix;
    int IJ, KL, ipat;
    int ijcs,        ijcs1;
    int klcs, klcs0;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao;
    int kcs, kat, kao, kao0, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DSDS[6*6];
    int ics2, jcs2;
    double dmax, dij;
    int Labcd = 9;
    int *p_ijcounter = &ijcounter[Labcd];
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao    = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<=ijcs; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao    = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dsds_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DSDS );
	    ipat = ( (ics==kcs && jcs>lcs) ? true : false);
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		IJ = ( (iao*iao+iao)>>1) + jao;
		for ( k=0, kao=kao0; k<6; k++, kao++, ix++ ) {
		    KL = ( (kao*kao+kao)>>1) + lao;
		    if ( fabs(DSDS[ix]) <= eps_eri ) continue;
		    if ( IJ >= KL || ipat ) {
			double x, x4;
			int ij, ik, il, jk, jl, kl, i0, j0;
			coe = ONE;
			if ( iao==kao && jao==lao ) coe = HALF;
			x  = coe * DSDS[ix];
			/*
		// for check sum
		lsum += x;
		*/

			x4 = 4.e0 * x;
			i0 = iao*nao;
			j0 = jao*nao;
			ij = i0 + jao;
			ik = i0 + kao;
			il = i0 + lao;
			jk = j0 + kao;
			jl = j0 + lao;
			kl = kao*nao + lao;
			G[ij] += x4*Ds[kl];
			G[kl] += x4*Ds[ij];
			G[ik] -=  x*Ds[jl];
			G[il] -=  x*Ds[jk];
			G[jk] -=  x*Ds[il];
			G[jl] -=  x*Ds[ik];
		    }
		}	// for ( kao )
	    }		// for ( iao )
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[9] += lsum;
    */

    return 0;
}

/** (dp,ss)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dpss_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DPSS[6*3];
    int ics2, jcs2;
    double dmax, dij;
    int Labcd = 10;
    int *p_ijcounter = &ijcounter[Labcd];
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao    = shel_ini[kcs];
	    lao    = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dpss_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DPSS );
	    coe = ( kao == lao ? HALF : ONE );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<3; j++, jao++, ix++ ) {
		    if ( fabs(DPSS[ix]) > eps_eri ) {
			double x, x4;
			int ij, ik, il, jk, jl, kl, i0, j0;
			x  = coe * DPSS[ix];
			/*
		// for check sum
		lsum += x;
		*/

			x4 = 4.e0 * x;
			i0 = iao*nao;
			j0 = jao*nao;
			ij = i0 + jao;
			ik = i0 + kao;
			il = i0 + lao;
			jk = j0 + kao;
			jl = j0 + lao;
			kl = kao*nao + lao;
			G[ij] += x4*Ds[kl];
			G[kl] += x4*Ds[ij];
			G[ik] -=  x*Ds[jl];
			G[il] -=  x*Ds[jk];
			G[jk] -=  x*Ds[il];
			G[jl] -=  x*Ds[ik];
		    }
		}
	    }	// for ( i, iao);
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[10] += lsum;
    */

    return 0;
}
#endif

/** (dp,ps)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
NREGS_255
gpu_twoint_direct_dpps_( const int nwks, const int iwk,
   const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int La=2, Lb=1, Lc=1, Ld=0;
    int Lab, Lcd;
    int Labcd = 11;
    int *p_ijcounter = &ijcounter[Labcd];
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1, klcs0a;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao0, jcs, jat, jao0;
    int kcs, kat, kao0, lcs, lat, lao0;
    double DPPS[6*3*3];
#ifdef USE_INSTANT_SCHWARZ
    float val_ab;
#endif
    int ics2, jcs2;
    int nwkblk, iwkblk;
    double *G, *Gkl;
    double *Gi, *Gj;
    double *work;
    int mincs,maxcs,minao,maxao;
    int minao1[2], maxao1[2];
    int numao;
    int *sklcs;
    __shared__ int nklcs;
    __shared__ int ijcsw;
    __shared__ int nijcsw;
#ifdef CUDA_FMT_M_SM
    size_t tsize = FMT_m_size[4];
    double *tbl = FMT_m_table4;
    for (int i=tidx; i<tsize; i+=nthb) shared[i] = tbl[i];
    __syncthreads();
    double Gij[3];
    size_t sOffset = tsize;
    tsize += nthb;
#else
    double *Gij = &shared[tidx*3];
    size_t tsize = nthb*3;
    size_t sOffset = 0;
#endif
#ifdef DLB_KL_DSPS
//    __shared__ volatile int klcsw[NTHREADS/WARP_SIZE];
//    volatile int *klcsw = (int *)&shared[nthb*3];
    volatile int *klcsw = (int *)&shared[tsize];
    __shared__ int cklcs;
#endif
    __shared__ double A[3];
    __shared__ double BA[3];

    minao1[0] = shel_ini[leading_cs[La]];
    minao1[1] = shel_ini[leading_cs[Lb]];
    minao = MIN2(minao1[0], minao1[1]);
    maxao1[0] = shel_ini[leading_cs[La+1]] - 1;
    maxao1[1] = shel_ini[leading_cs[Lb+1]] - 1;
    maxao = MAX2(maxao1[0], maxao1[1]);
#ifdef ADD_FULL_NAO
    minao=0;
    maxao=nao-1;
#endif
    numao = maxao - minao + 1;

    sklcs = sklcs_b + bidx * max_num_klcs;
    G   = G_b   + bidx * nao * nao;
    Gkl = Gkl_b + bidx * num_Gkl;
    Gi   = Gi_t + (bidx * nthb + tidx) * num_Gi;
    Gj   = Gi + nao*3;
    work = work_b + bidx * nthb * WORK_SIZE;

//    nwkblk = nworkers * ndev * nblk;
//    iwkblk = workerid * ndev * nblk + idev * nblk + bidx;
//    nwkblk = nwks;
//    iwkblk = iwk + bidx;
    nwkblk = nwks * nblk;
    iwkblk = iwk * nblk + bidx;

    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs0 = leading_cs_pair[Lcd];
    ijcs1 = leading_cs_pair[Lcd+1];
    klcs0 = leading_cs_pair[Lab];
    klcs1 = leading_cs_pair[Lab+1];

#ifndef USE_ATOMIC
    for (int idx=0; idx<nthb; idx++) {
      double *Gi0   = Gi_t + (bidx * nthb + idx) * num_Gi;
      for (int i=tidx; i<nao*4; i+=nthb ) Gi0[i]=ZERO;
    }
    for (int i=tidx; i<(klcs1-klcs0)*6*3; i+=nthb) Gkl[i]=ZERO;
    __syncthreads();
#endif

#ifdef GPU_DLB
//    if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
//    ijcsw = ijcs0 + iwk + nwks * bidx;
//    nijcsw = 0;
    if (tidx==0) {
      ijcsw = ijcs0 + iwk + nwks * bidx * NIJCSW;
      nijcsw = NIJCSW-1;
    }
    __syncthreads();
#endif

//    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
#ifdef GPU_DLB
    while(ijcsw<ijcs1) {
#else
    for (int ijcs2=ijcs0+iwkblk; ijcs2<ijcs1; ijcs2+=nwkblk ) {
#endif
#ifdef GPU_DLB
//        ijcs = ijcsw;
        ijcs = ijcs0 + ijcs1 - ijcsw - 1;
        /*
        __syncthreads();
        if (tidx==0) ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,1)*nwks;
        */
#else
      ijcs = ijcs2;
#endif
#ifdef SORT_IJ_SCHWARZ
      ijcs = sorted_csp[ijcs];
#endif
#ifdef DLB_KL_DPPS
        if(tidx==0) cklcs=nthb;
        __syncthreads();
#endif
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
//        if(tidx==0) printf("%d:0 %d %d %d\n",tidx,ijcs,ics,jcs);
#ifdef USE_INSTANT_SCHWARZ
	val_ab = csp_schwarz[ijcs];
#else /* !USE_INSTANT_SCHWARZ */
        {
	  float val_ab = csp_schwarz[ijcs];
//          int sklcs_l[NKLBUF];
          __syncthreads();
          if(tidx == 0) nklcs = 0;
          __syncthreads();
	  for (int klcs2 = klcs0+tidx ; klcs2<klcs1; klcs2+=nthb) {
//	  for (int klcs2 = klcs1-tidx-1; klcs2>=klcs0 ; klcs2-=nthb) {
              int klcs=klcs2;
              int kcs, lcs;
              int iklcs;
              float dmax;
	      float val_abcd;
#ifdef SORT_KL_SCHWARZ
          klcs = sorted_csp[klcs2];
#endif
	      val_abcd = val_ab * csp_schwarz[klcs];
	      if ( val_abcd < eps_ps4 ) continue;
	      kcs    = csp_ics[klcs];
	      lcs    = csp_jcs[klcs];
              dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	      if ( dmax*val_abcd < eps_sch ) continue;
//              iklcs = atomicInc(&nklcs, max_num_klcs);
              iklcs = atomicAdd(&nklcs, 1);
#ifdef SORT_KL_SCHWARZ
              klcs = klcs2;
#endif
              sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
//          if(bidx==0&&tidx==0) printf("nklcs = %d\n", nklcs);
        }
#endif /* USE_INSTANT_SCHWARZ */
#pragma unroll
        for (int i=0;i<3;i++) Gij[i] = ZERO;
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
        __syncthreads();
        if(tidx == 0) {
        /*
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        */
        BA[0] = LDG(atom_x[jat]) + (A[0] = -LDG(atom_x[iat]));
        BA[1] = LDG(atom_y[jat]) + (A[1] = -LDG(atom_y[iat]));
        BA[2] = LDG(atom_z[jat]) + (A[2] = -LDG(atom_z[iat]));
        }
        __threadfence_block();
        __syncthreads();

//        if(tidx==0) printf("%d:k %d %d\n",tidx,klcs0,klcs1);
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
	
//	for (klcs = klcs0 ; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (klcs = klcs0+tidx ; klcs<klcs1; klcs+=nthb ) {
#ifdef DLB_KL_DPPS
  NOT supported combination of defines.
#endif
#else /* !USE_INSTANT_SCHWARZ */
#ifndef DLB_KL_DPPS
//	for (int iklcs = tidx ; iklcs<nklcs; iklcs+=nthb ) {
	for (int iklcs2 = tidx ; iklcs2<nklcs; iklcs2+=nthb ) {
          int iklcs;
          int it = iklcs2 / nthb;
          if (it%2 == 0) iklcs = iklcs2;
          else {
            int ilast = MIN2(nklcs, (it+1)*nthb);
            iklcs = it*nthb + ilast - iklcs2 - 1;
          }
#else /* !DLB_KL_DPPS */
        {
          int iklcs;
          if (tidw==0) klcsw[widx] = widx * warpSize;
          iklcs = klcsw[widx] + tidw;
        while(iklcs<nklcs) {
#endif /* !DLB_KL_DPPS */
#endif /* !USE_INSTANT_SCHWARZ */
            double DC[3], AC[3];
            float dmax;
            int klcs2;
#ifdef USE_INSTANT_SCHWARZ
	    float val_abcd = val_ab * csp_schwarz[klcs];
	    if ( val_abcd < eps_ps4 ) continue;
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
            dmax = gpu_dmax6(ics,jcs,kcs,lcs);
	    if ( dmax*val_abcd < eps_sch ) continue;
#else
            klcs = sklcs[iklcs];
#ifdef SORT_KL_SCHWARZ
            klcs = sorted_csp[klcs];
#endif
#endif /* USE_INSTANT_SCHWARZ */
            klcs2 = klcs - klcs0;
//         if (tidx==0) printf("%d:kl %d %d\n",tidx,klcs, klcs2);
	    kcs    = LDG(csp_ics[klcs]);
	    lcs    = LDG(csp_jcs[klcs]);
	    klps0  = LDG(csp_leading_ps_pair[klcs]);
	    nklps  = LDG(csp_leading_ps_pair[klcs+1])-klps0;
	    kat    = LDG(shel_atm[kcs]);
	    lat    = LDG(shel_atm[lcs]);
	    kao0   = LDG(shel_ini[kcs]);
	    lao0   = LDG(shel_ini[lcs]);
            /*
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
            */
            {
              double dtmp;
              AC[0] = A[0] + (dtmp = LDG(atom_x[kat]));
              DC[0] = LDG(atom_x[lat]) - dtmp;
              AC[1] = A[1] + (dtmp = LDG(atom_y[kat]));
              DC[1] = LDG(atom_y[lat]) - dtmp;
              AC[2] = A[2] + (dtmp = LDG(atom_z[kat]));
              DC[2] = LDG(atom_z[lat]) - dtmp;
            }
/*
	    gpu_twoint_core_dpps_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DPPS );
*/
// (ps,dp) -> (dp,ps)
	    //gpu_twoint_core_dpps_(
	    gpu_twoint_core_os_dpps(
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,   AC,      DPPS);
            {
              int jao = jao0;
              int j0 = jao*nao;
              int ix = 0;
              double Gjl[3] = {ZERO,ZERO,ZERO};
              double Gil[9];
#pragma unroll
              for (int i=0;i<9;i++) Gil[i]=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<6; k++, kao++ ) {
              int jk = j0 + kao;
              double Gkl2[3] = {ZERO,ZERO,ZERO};
              double Gjk = ZERO;
              double Gik[3] = {ZERO,ZERO,ZERO};
#pragma unroll
		for (int l=0, lao=lao0; l<3; l++, lao++ ) {
                  int jl = j0 + lao;
                  int kl = kao*nao+lao;
#pragma unroll
		    for (int i=0, iao=iao0; i<3; i++, iao++, ix++ ) {
                      double x = DPPS[ix];
			if ( fabs(x) > eps_eri ) {
			    int ij, ik, il, i0;
                            double dx, x4;

			    x4 = 4.e0 * x;
                            x *= -x_coef;
			    i0 = iao*nao;
			    ij = i0 + jao;
			    ik = i0 + kao;
			    il = i0 + lao;
                            /*
			    G[ij] += x4*Ds[kl];
			    G[kl] += x4*Ds[ij];
			    G[ik] -=  x*Ds[jl];
			    G[il] -=  x*Ds[jk];
			    G[jk] -=  x*Ds[il];
			    G[jl] -=  x*Ds[ik];
                            */
			
                          Gij[i]  += x4*LDG(Ds[kl]);
                          Gkl2[l] += x4*LDG(Ds[ij]);
                          Gik[i]     += x*LDG(Ds[jl]);
                          Gil[i*3+l] += x*LDG(Ds[jk]);
                          Gjk        += x*LDG(Ds[il]);
                          Gjl[l]     += x*LDG(Ds[ik]);
			}
		    } // i
		} // l
#ifdef USE_ATOMIC
                atomicAdd(&G[j0+kao], Gjk);
#pragma unroll
                for (int i=0,iao=iao0; i<3; i++,iao++)
                  atomicAdd(&G[iao*nao+kao], Gik[i]);
#pragma unroll
                for (int l=0,lao=lao0; l<3; l++,lao++)
                  atomicAdd(&G[kao*nao+lao], Gkl2[l]);
#else
                Gj[kao] += Gjk;
                for (int i=0; i<3; i++)
                  Gi[i*nao+kao] += Gik[i];
#pragma unroll
                for (int l=0; l<3; l++)
                  Gkl[klcs2*6*3+k*3+l] += Gkl2[l];
#endif
	    }	// for ( k, kao);
#ifdef USE_ATOMIC
#pragma unroll
            for (int i=0,iao=iao0; i<3; i++,iao++)
#pragma unroll
              for (int l=0,lao=lao0; l<3; l++,lao++)
                atomicAdd(&G[iao*nao+lao], Gil[i*3+l]);
#pragma unroll
            for (int l=0,lao=lao0; l<3; l++,lao++)
              atomicAdd(&G[j0+lao], Gjl[l]);
#else
#pragma unroll
            for (int i=0,iao=iao0; i<3; i++,iao++)
#pragma unroll
              for (int l=0,lao=lao0; l<3; l++,lao++)
                Gi[i*nao+lao] += Gil[i*3+l];
#pragma unroll
            for (int l=0,lao=lao0; l<3; l++,lao++)
              Gj[lao] += Gjl[l];
#endif
          } // block for additions
#ifdef DLB_KL_DPPS
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx] + tidw;
          } // while (iklcs)
#endif
	}	// for ( klcs );
//	klcs = klcs0;
#ifdef GPU_DLB
        if (tidx==0) {
          if (nijcsw > 0) {
            ijcsw += nwks;
            nijcsw--;
          } else {
            ijcsw = ijcs0 + iwk + atomicAdd(p_ijcounter,NIJCSW)*nwks;
            nijcsw = NIJCSW-1;
          }
        }
#endif
#ifdef USE_ATOMIC
#if 0
#pragma unroll
        for (int i=0; i<3; i++)
          atomicAdd(&G[jao0*nao+iao0+i], Gij[i]);
#else
        {
#ifndef CUDA_FMT_M_SM
          double tGij[3];
          for (int i=0; i<3; i++) tGij[i] = Gij[i];
#else
          double *tGij = Gij;
#endif
          for (int i=0; i<3; i++) {
            double *ss = &shared[sOffset+tidx];
            __syncthreads();
            *ss = tGij[i];
            { // Reduce Gij within warp
              double *sGij = &shared[sOffset+widx*WARP_SIZE];
              warpReduce(sGij, tidw);
            }
            __syncthreads();
            if (tidx==0) { // Reduce Gij for warp masters
              double *sGij = &shared[sOffset];
              double dtmp = sGij[0];
              for (int j=1; j<nwrp; j++) dtmp += sGij[j*WARP_SIZE];
              atomicAdd(&G[jao0*nao+iao0+i], dtmp);
            }
          } // i
        }
#endif
        __syncthreads();
#else /* !USE_ATOMIC */
#pragma unroll
        for (int i=0; i<3; i++) Gj[iao0+i] += Gij[i];
        {
          int i,j;
          int nGi;
          int bs;
	  int i0 = iao0*nao;
	  int j0 = jao0*nao;
          int ijcs_next;
          int ics_next, jcs_next;
          ics_next=jcs_next=-1;
#ifdef GPU_DLB
          __syncthreads();
//          ijcs_next = ijcsw;
//          if (ijcs_next<ijcs1) { 
          ijcs_next = ijcs0 + ijcs1 - ijcsw - 1;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
//          if (ijcs_next>=ijcs0) { 
          if (ijcsw<ijcs1) { 
#else /* !GPU_DLB */
          ijcs_next = ijcs2+nwkblk;
#ifdef SORT_IJ_SCHWARZ
          ijcs_next = sorted_csp[ijcs_next];
#endif
          if (ijcs_next<ijcs1) { 
#endif /* !GPU_DLB */
	    ics_next = csp_ics[ijcs_next];
	    jcs_next = csp_jcs[ijcs_next];
          }
#ifndef GPU_DLB
          if (ics != ics_next || jcs != jcs_next) __syncthreads();
#endif
          nGi = num_Gi*2;
          bs = bidx*nthb*num_Gi;
          if (ics != ics_next) {
          for (int ii=tidx;ii<numao*3;ii+=nthb) {
            i = (ii/numao)*nao + ii%numao + minao;
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[i0+i] += Gtmp;
          } // for i
          } // ics != ics_next
          if (jcs != jcs_next) {
//          for (i=tidx;i<nao;i+=nthb) {
          for (i=minao+tidx;i<=maxao;i+=nthb) {
            double Gtmp = ZERO;
            double *pG = Gi_t + bs + nao*3 + i;
            double *pG1 = pG + num_Gi;
#pragma unroll
            for (j=0;j<nthb/2;j++) {
              Gtmp += (*pG + *pG1);
              *pG = *pG1 = ZERO;
              pG  += nGi;
              pG1 += nGi;
            }
            if (j*2!=nthb) {
              Gtmp += *pG;
              *pG = ZERO;
            }
            G[j0+i] += Gtmp;
          } // for i
          } // jcs != jcs_next
    __syncthreads();
        }
#endif /* !USE_ATOMIC */
    }		// for ( ijcs );

#ifndef USE_ATOMIC
    for (int i=tidx; i<(klcs1-klcs0)*6*3; i+=nthb) {
      int klcs, kl;
      int k, l;
      int kcs,lcs,kao,lao;
      klcs = i/18;
      kl = i - klcs*18;
      k = kl/3;
      l = kl-k*3;
      klcs += klcs0;
      kcs = csp_ics[klcs];
      lcs = csp_jcs[klcs];
      kao = shel_ini[kcs] + k;
      lao = shel_ini[lcs] + l;
      G[kao*nao+lao] += Gkl[i];
    }
#endif

    return;
}

#ifdef DUMMY
/** (dp,pp)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dppp_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, l, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DPPP[6*3*3*3];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao0   = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dppp_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DPPP );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<3; j++, jao++ ) {
		    for (k=0, kao=kao0; k<3; k++, kao++ ) {
			for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    if ( lao > kao ) continue;
			    coe = ( kao == lao ? HALF : ONE );
			    if ( fabs(DPPP[ix]) > eps_eri ) {
				double x, x4;
				int ij, ik, il, jk, jl, kl, i0, j0;
				x  = coe * DPPP[ix];
				/*
		// for check sum
		lsum += x;
		*/

				x4 = 4.e0 * x;
				i0 = iao*nao;
				j0 = jao*nao;
				ij = i0 + jao;
				ik = i0 + kao;
				il = i0 + lao;
				jk = j0 + kao;
				jl = j0 + lao;
				kl = kao*nao + lao;
				G[ij] += x4*Ds[kl];
				G[kl] += x4*Ds[ij];
				G[ik] -=  x*Ds[jl];
				G[il] -=  x*Ds[jk];
				G[jk] -=  x*Ds[il];
				G[jl] -=  x*Ds[ik];
			    }
			}
		    }
		}
	    }	// for ( i, iao);
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[12] += lsum;
    */

    return 0;
}

/** (dp,ds)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dpds_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd;
    double DPDS[6*3*6];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao    = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dpds_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DPDS );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<3; j++, jao++ ) {
		    for (k=0, kao=kao0; k<6; k++, kao++, ix++ ) {
			if ( fabs(DPDS[ix]) > eps_eri ) {
			    double x, x4;
			    int ij, ik, il, jk, jl, kl, i0, j0;
			    x  = DPDS[ix];
			    /*
		// for check sum
		lsum += x;
		*/

			    x4 = 4.e0 * x;
			    i0 = iao*nao;
			    j0 = jao*nao;
			    ij = i0 + jao;
			    ik = i0 + kao;
			    il = i0 + lao;
			    jk = j0 + kao;
			    jl = j0 + lao;
			    kl = kao*nao + lao;
			    G[ij] += x4*Ds[kl];
			    G[kl] += x4*Ds[ij];
			    G[ik] -=  x*Ds[jl];
			    G[il] -=  x*Ds[jk];
			    G[jk] -=  x*Ds[il];
			    G[jl] -=  x*Ds[ik];
			}
		    }
		}
	    }	// for ( i, iao);
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[13] += lsum;
    */

    return 0;
}

/** (dp,dp)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dpdp_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, l, ix, ipat;
    int IJ, KL;
    int ijcs,        ijcs1;
    int klcs, klcs0;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DPDP[6*3*6*3];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<=ijcs; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao0   = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dpdp_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DPDP );
	    ipat = ( (ics==kcs && jcs>lcs) ? true : false );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<3; j++, jao++ ) {
		    IJ = ((iao*iao+iao)>>1) + jao;
		    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
			for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    KL = ((kao*kao+kao)>>1) + lao;
			    if ( fabs(DPDP[ix]) > eps_eri ) {
				if ( IJ>=KL || ipat ) {
				    double x, x4;
				    int ij, ik, il, jk, jl, kl, i0, j0;
				    coe = ( IJ==KL ? HALF : ONE );
				    x  = coe * DPDP[ix];
				    /*
		// for check sum
		lsum += x;
		*/

				    x4 = 4.e0 * x;
				    i0 = iao*nao;
				    j0 = jao*nao;
				    ij = i0 + jao;
				    ik = i0 + kao;
				    il = i0 + lao;
				    jk = j0 + kao;
				    jl = j0 + lao;
				    kl = kao*nao + lao;
				    G[ij] += x4*Ds[kl];
				    G[kl] += x4*Ds[ij];
				    G[ik] -=  x*Ds[jl];
				    G[il] -=  x*Ds[jk];
				    G[jk] -=  x*Ds[il];
				    G[jl] -=  x*Ds[ik];
				}
			    }
			}
		    }	// for ( kao )
		}
	    }		// for ( iao )
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[14] += lsum;
    */

    return 0;
}

/** (dd,ss)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_ddss_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DDSS[6*6];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao    = shel_ini[kcs];
	    lao    = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_ddss_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DDSS );
	    coe0 = ( kao == lao ? HALF : ONE );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<6; j++, jao++, ix++ ) {
		    if ( jao > iao ) continue;
		    if ( fabs(DDSS[ix]) > eps_eri ) {
			double x, x4;
			int ij, ik, il, jk, jl, kl, i0, j0;
			coe = coe0;
			if ( iao == jao ) coe *= HALF;
			x  = coe * DDSS[ix];
			/*
		// for check sum
		lsum += x;
		*/

			x4 = 4.e0 * x;
			i0 = iao*nao;
			j0 = jao*nao;
			ij = i0 + jao;
			ik = i0 + kao;
			il = i0 + lao;
			jk = j0 + kao;
			jl = j0 + lao;
			kl = kao*nao + lao;
			G[ij] += x4*Ds[kl];
			G[kl] += x4*Ds[ij];
			G[ik] -=  x*Ds[jl];
			G[il] -=  x*Ds[jk];
			G[jk] -=  x*Ds[il];
			G[jl] -=  x*Ds[ik];
		    }
		} // for ( jao );
	    }	// for ( iao );
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[15] += lsum;
    */

    return 0;
}

/** (dd,ps)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_ddps_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DDPS[6*6*3];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao    = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_ddps_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DDPS );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix += 3; continue; }
		    coe = ( iao==jao ? HALF : ONE );
		    for ( k=0, kao=kao0; k<3; k++, kao++, ix++ ) {
			if ( fabs(DDPS[ix]) > eps_eri ) {
			    double x, x4;
			    int ij, ik, il, jk, jl, kl, i0, j0;
			    x  = coe * DDPS[ix];
			    /*
		// for check sum
		lsum += x;
		*/

			    x4 = 4.e0 * x;
			    i0 = iao*nao;
			    j0 = jao*nao;
			    ij = i0 + jao;
			    ik = i0 + kao;
			    il = i0 + lao;
			    jk = j0 + kao;
			    jl = j0 + lao;
			    kl = kao*nao + lao;
			    G[ij] += x4*Ds[kl];
			    G[kl] += x4*Ds[ij];
			    G[ik] -=  x*Ds[jl];
			    G[il] -=  x*Ds[jk];
			    G[jk] -=  x*Ds[il];
			    G[jl] -=  x*Ds[ik];
			}	// if ( fabs );
		    }	// for ( kao )
		}	// for ( jao )
	    }	// for ( iao )
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[16] += lsum;
    */

    return 0;
}

/** (dd,pp)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_ddpp_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, l, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DDPP[6*6*3*3];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao0   = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_ddpp_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DDPP );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=3*3; continue; }
		    coe0 = (iao==jao ? HALF : ONE );
		    for (k=0, kao=kao0; k<3; k++, kao++ ) {
			for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    if ( lao > kao ) continue;
			    coe = coe0 * ( kao==lao ? HALF : ONE );
			    if ( fabs(DDPP[ix]) > eps_eri ) {
				double x, x4;
				int ij, ik, il, jk, jl, kl, i0, j0;
				x  = coe * DDPP[ix];
				/*
		// for check sum
		lsum += x;
		*/

				x4 = 4.e0 * x;
				i0 = iao*nao;
				j0 = jao*nao;
				ij = i0 + jao;
				ik = i0 + kao;
				il = i0 + lao;
				jk = j0 + kao;
				jl = j0 + lao;
				kl = kao*nao + lao;
				G[ij] += x4*Ds[kl];
				G[kl] += x4*Ds[ij];
				G[ik] -=  x*Ds[jl];
				G[il] -=  x*Ds[jk];
				G[jk] -=  x*Ds[il];
				G[jl] -=  x*Ds[ik];
			    }
			}
		    }
		}
	    }	// for ( i, iao);
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[17] += lsum;
    */

    return 0;
}

/** (dd,ds)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_ddds_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DDDS[6*6*6];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao    = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_ddds_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DDDS );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix += 6; continue; }
		    coe = ( iao==jao ? HALF : ONE );
		    for ( k=0, kao=kao0; k<6; k++, kao++, ix++ ) {
			if ( fabs(DDDS[ix]) > eps_eri ) {
			    double x, x4;
			    int ij, ik, il, jk, jl, kl, i0, j0;
			    x  = coe * DDDS[ix];
			    /*
		// for check sum
		lsum += x;
		*/

			    x4 = 4.e0 * x;
			    i0 = iao*nao;
			    j0 = jao*nao;
			    ij = i0 + jao;
			    ik = i0 + kao;
			    il = i0 + lao;
			    jk = j0 + kao;
			    jl = j0 + lao;
			    kl = kao*nao + lao;
			    G[ij] += x4*Ds[kl];
			    G[kl] += x4*Ds[ij];
			    G[ik] -=  x*Ds[jl];
			    G[il] -=  x*Ds[jk];
			    G[jk] -=  x*Ds[il];
			    G[jl] -=  x*Ds[ik];
			}	// if ( fabs );
		    }	// for ( kao )
		}	// for ( jao )
	    }	// for ( iao )
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[18] += lsum;
    */

    return 0;
}

/** (dd,dp)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dddp_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, l, ix;
    int ijcs,        ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DDDP[6*6*6*3];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    klcs1 = leading_cs_pair[Lcd+1];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<klcs1; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao0   = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dddp_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DDDP );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix += 6*3; continue; }
		    coe = ( iao==jao ? HALF : ONE );
		    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
			for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    if ( fabs(DDDP[ix]) > eps_eri ) {
				double x, x4;
				int ij, ik, il, jk, jl, kl, i0, j0;
				x  = coe * DDDP[ix];
				/*
		// for check sum
		lsum += x;
		*/

				x4 = 4.e0 * x;
				i0 = iao*nao;
				j0 = jao*nao;
				ij = i0 + jao;
				ik = i0 + kao;
				il = i0 + lao;
				jk = j0 + kao;
				jl = j0 + lao;
				kl = kao*nao + lao;
				G[ij] += x4*Ds[kl];
				G[kl] += x4*Ds[ij];
				G[ik] -=  x*Ds[jl];
				G[il] -=  x*Ds[jk];
				G[jk] -=  x*Ds[il];
				G[jl] -=  x*Ds[ik];
			    }	// if ( fabs );
			}
		    }	// for ( kao )
		}	// for ( jao )
	    }	// for ( iao )
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[19] += lsum;
    */

    return 0;
}

/** (dd,dd)タイプの積分計算、および、G行列計算を行う関数
 *
 * @ingroup integ-twoint-direct
 * */
__global__ void
#ifdef MY_KERNEL_MIN_BLOCKS
__launch_bounds__(MY_KERNEL_MAX_THREADS, MY_KERNEL_MIN_BLOCKS)
#endif
gpu_twoint_direct_dddd_(
	// paralleization
	const int nworkers, const int workerid,
	// integral type data
	const int La, const int Lb, const int Lc, const int Ld,
	// basis set & cutoff table data
	const int shel_atm[], const int shel_ini[],
	const double atom_x[], const double atom_y[],
	const double atom_z[], const int leading_cs_pair[],
	const double csp_schwarz[],
	const int csp_ics[], const int csp_jcs[],
	const int csp_leading_ps_pair[],
	const double psp_zeta[], const double psp_dkps[],
	const double psp_xiza[],
	// concerned about buffered direct method
	const int last_ijcs, const int last_klcs,
	// density matrix & G-matrix data
	const int nao, const double Ds[], double G[],
	const int ncs, const float Dcs[] ) {
    int Lab, Lcd, i, j, k, l, ix, ipat;
    int I2, IJ, K2, KL;
    int ijcs,        ijcs1;
    int klcs, klcs0;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe, coe0;
    double DDDD[6*6*6*6];
    int ics2, jcs2;
    double dmax, dij;
    /*
    // for check sum
    double lsum = ZERO;
    */


    Lab = La*(La+1)/2+Lb;
    Lcd = Lc*(Lc+1)/2+Ld;
    ijcs1 = leading_cs_pair[Lab+1];
    klcs0 = leading_cs_pair[Lcd];
    if ( last_ijcs != -1 ) {
	ijcs = last_ijcs;
	klcs = last_klcs+1;
    } else {
	ijcs = leading_cs_pair[Lab] + workerid;
	klcs = klcs0;
    }

    for (  ; ijcs<ijcs1; ijcs+=nworkers ) {
	val_ab = csp_schwarz[ijcs];
	ics    = csp_ics[ijcs];
	jcs    = csp_jcs[ijcs];
	ijps0  = csp_leading_ps_pair[ijcs];
	nijps  = csp_leading_ps_pair[ijcs+1]-ijps0;
	iat    = shel_atm[ics];
	jat    = shel_atm[jcs];
	iao0   = shel_ini[ics];
	jao0   = shel_ini[jcs];
	A[0]=atom_x[iat]; A[1]=atom_y[iat]; A[2]=atom_z[iat];
	B[0]=atom_x[jat]; B[1]=atom_y[jat]; B[2]=atom_z[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        ics2 = ics*ncs;
        jcs2 = jcs*ncs;
        dij = Dcs[ics2+jcs];
	
	for ( ; klcs<=ijcs; klcs++ ) {
	    kcs    = csp_ics[klcs];
	    lcs    = csp_jcs[klcs];
          dmax = MAX2(dij, Dcs[kcs*ncs+lcs]) * 4.0e0;
          dmax = MAX2(dmax, Dcs[ics2+kcs]);
          dmax = MAX2(dmax, Dcs[ics2+lcs]);
          dmax = MAX2(dmax, Dcs[jcs2+kcs]);
          dmax = MAX2(dmax, Dcs[jcs2+lcs]);
	    val_cd = csp_schwarz[klcs];
//	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    if ( dmax*val_ab*val_cd < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair[klcs];
	    nklps  = csp_leading_ps_pair[klcs+1]-klps0;
	    kat    = shel_atm[kcs];
	    lat    = shel_atm[lcs];
	    kao0   = shel_ini[kcs];
	    lao0   = shel_ini[lcs];
	    C[0]=atom_x[kat]; C[1]=atom_y[kat]; C[2]=atom_z[kat];
	    D[0]=atom_x[lat]; D[1]=atom_y[lat]; D[2]=atom_z[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    twoint_core_dddd_(
		    &nijps, &psp_zeta[ijps0], &psp_dkps[ijps0],
		    &psp_xiza[ijps0], BA,
		    &nklps, &psp_zeta[klps0], &psp_dkps[klps0],
		    &psp_xiza[klps0], DC,   AC,      DDDD );
	    ipat = ( (ics==kcs && jcs>lcs) ? true : false );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=6*6; continue; }
		    IJ = I2 + jao;
		    coe0 = ( iao==jao ? HALF : ONE );
		    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
			K2 = (kao*kao+kao)>>1;
			for ( l=0, lao=lao0; l<6; l++, lao++, ix++ ) {
			    if ( lao>kao ) continue;
			    if ( fabs(DDDD[ix]) > eps_eri ) {
				double x, x4;
				int ij, ik, il, jk, jl, kl, i0, j0;
				KL = K2 + lao;
				if ( IJ >= KL || ipat ) {
				    coe = coe0;
				    if ( kao==lao ) coe *= HALF;
				    if ( KL == IJ ) coe *= HALF;
				    x  = coe * DDDD[ix];
				    /*
		// for check sum
		lsum += x;
		*/

				    x4 = 4.e0 * x;
				    i0 = iao*nao;
				    j0 = jao*nao;
				    ij = i0 + jao;
				    ik = i0 + kao;
				    il = i0 + lao;
				    jk = j0 + kao;
				    jl = j0 + lao;
				    kl = kao*nao + lao;
				    G[ij] += x4*Ds[kl];
				    G[kl] += x4*Ds[ij];
				    G[ik] -=  x*Ds[jl];
				    G[il] -=  x*Ds[jk];
				    G[jk] -=  x*Ds[il];
				    G[jl] -=  x*Ds[ik];
				}
			    } // if ( fabs )
			} // for ( lao )
		    } // for ( kao )
		} // for ( jao )
	    }	// for ( iao )
	}	// for ( klcs );
	klcs = klcs0;
    }		// for ( ijcs );
    /*
    // for check sum
#pragma omp atomic
    check_sum[20] += lsum;
    */

    return 0;
}
#endif /* DUMMY */

#undef WORK

#undef NREGS_064
#undef NREGS_128
#undef NREGS_255

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>

#ifdef _OPENMP
#include <omp.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include "integ/ofmo-twoint.h"
#include "integ/ofmo-twoint-direct.h"
#include "integ/ofmo-os-xxxx.h"
#include "integ/ofmo-rys-xxxx.h"
  extern FILE* fp_prof; // from common/ofmo-prof.h
#ifdef __cplusplus
}
#endif

#include <cuda.h>
#include "cuda-drv.h"
#include "cudalib.h"
#include "cuda-twoint-direct.h"
#include "cuda-integ.h"
#include "cuda-fmt-m.h"

// Default {#block/#SMX, #threads/WARP_SIZE} set for each 2e-type
// This array will be converted to actual {#block, #threads} set
// in cuda_Init_Sub() by multiplying #SMX and WARP_SIZE, respectively.
int dim2e[][2] = {
#if CUDA_ARCH >= 350
  {  9,  2}, // ssss
  {  8,  2}, // psss
  {  8,  2}, // psps
  {  8,  2}, // ppss
  {  8,  2}, // ppps
  {  8,  1}, // pppp
//  { 10,  1}, // dsss
  {  9,  1}, // dsss
  {  8,  1}, // dsps
  {  8,  1}, // dspp
  {  0,  0}, // dsds
  {  0,  0}, // dpss
  {  8,  1}, // dpps
  {  0,  0}, // dppp
  {  0,  0}, // dpds
  {  0,  0}, // dpdp
  {  0,  0}, // ddss
  {  0,  0}, // ddps
  {  0,  0}, // ddpp
  {  0,  0}, // ddds
  {  0,  0}, // dddp
  {  0,  0}, // dddd
#else /* FERMI */
  {  5,  2}, // ssss
  {  4,  2}, // psss
  {  7,  1}, // psps
  {  6,  1}, // ppss
  {  5,  1}, // ppps
  {  5,  1}, // pppp
  {  5,  1}, // dsss
  {  3,  1}, // dsps
  {  5,  1}, // dspp
  {  0,  0}, // dsds
  {  0,  0}, // dpss
  {  4,  1}, // dpps
  {  0,  0}, // dppp
  {  0,  0}, // dpds
  {  0,  0}, // dpdp
  {  0,  0}, // ddss
  {  0,  0}, // ddps
  {  0,  0}, // ddpp
  {  0,  0}, // ddds
  {  0,  0}, // dddp
  {  0,  0}, // dddd
#endif
  {  0,  0}  // buff
};

int counter_ini_type[] = { // 0 for 0, 1 for nblk, 2 for nblk*NIJCSW
  1,                // sxxx
  2, 1, 2, 2, 1,    // pxxx             
  2, 2, 2, 0,       // dsxx
  0, 2, 0, 0, 0,    // dpxx
  0, 0, 0, 0, 0, 0  // ddxx
};

/* ------------------------------------- */
__host__ int cuda_twoint_direct_ssss_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = 96; // best
  nthb = 64;
  nblk = 64; // better for nblk <= 64
  nthb = 96;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];

  nwarps = nthb/WARP_SIZE;
//  if (nthb%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(0)*sizeof(double);
  Ns += nthb * 2 *  sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_SSSS
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
//    gpu_twoint_direct_counter_init <<< NBLOCKS, NTHREADS >>> (NBLOCKS);
    int c0 = nblk;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
//    gpu_twoint_direct_ssss_ <<< NBLOCKS, NTHREADS >>> (nwks, iwk,
    gpu_twoint_direct_ssss_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_psss_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 1;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = 128; // best
  nthb = 32;
  nblk = 64;  // better for nblk <= 64
  nthb = 64;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
  Ns = 0;
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(1)*sizeof(double);
  Ns += nthb * 3 * sizeof(double);
#else
  Ns += nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_PSSS
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
//    gpu_twoint_direct_counter_init <<< NBLOCKS, NTHREADS >>> (NBLOCKS);
//    gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_psss_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_psps_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 2;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = 96; // best
  nthb = 32;
  nblk = 48; // better for nblk <= 64
  nthb = 64;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(2)*sizeof(double);
  Ns += nthb * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_PSPS
  Ns += nwarps * sizeof(int);
#endif


  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk);
    int c0 = nblk;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_psps_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_ppss_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 3;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];
  if (last_ijcs!=-1||last_klcs!=-1) exit(1);

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(2)*sizeof(double);
  Ns += nthb * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_PPSS
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
//    gpu_twoint_direct_counter_init <<< NBLOCKS, NTHREADS >>> (NBLOCKS);
//    gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_ppss_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_ppps_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 4;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];
  if (last_ijcs!=-1||last_klcs!=-1) exit(1);

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(3)*sizeof(double);
  Ns += nthb * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
//  Ns = nwarps*(WARP_SIZE/9) * (3*3+4) * sizeof(double);
#ifdef DLB_KL_PPPS
  Ns += nwarps * sizeof(int);
#endif
//  cudaFuncSetCacheConfig(gpu_twoint_direct_ppps_, cudaFuncCachePreferShared);

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
//    gpu_twoint_direct_counter_init <<< NBLOCKS, NTHREADS >>> (NBLOCKS);
//    gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_ppps_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_pppp_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 5;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(4)*sizeof(double);
  Ns += nthb * 1 * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_PPPP
  Ns += nwarps * sizeof(int);
#endif


  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk);
    int c0 = nblk;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_pppp_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_dsss_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 6;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];
  if (last_ijcs!=-1||last_klcs!=-1) exit(1);

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(2)*sizeof(double);
  Ns += nthb * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_DSSS
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_dsss_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_dsps_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 7;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];
  if (last_ijcs!=-1||last_klcs!=-1) exit(1);

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(3)*sizeof(double);
  Ns += nthb * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_DSPS
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_dsps_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

__host__ int cuda_twoint_direct_dspp_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 8;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];
  if (last_ijcs!=-1||last_klcs!=-1) exit(1);

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(4)*sizeof(double);
  Ns += nthb * 1 * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_DSPP
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_dspp_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}


__host__ int cuda_twoint_direct_dpps_(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int nao = *pnao;
  int last_ijcs = *plast_ijcs, last_klcs = *plast_klcs;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
//  int nwks = np * NDEV * NBLOCKS;
//  int iwk0 = me * NDEV * NBLOCKS;
//  nwkblk = nworkers * ndev * gridDim.x;
//  iwkblk = workerid * ndev * gridDim.x + idev * gridDim.x + blockIdx.x;
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns;
  int Labcd = 11;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);

//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim2e[Labcd][0];
  nthb = dim2e[Labcd][1];
  if (last_ijcs!=-1||last_klcs!=-1) exit(1);

  nwarps = nthb/WARP_SIZE;
//  if (NTHREADS%WARP_SIZE!=0) exit(1);
//  if (nwarps>NTHREADS) exit(1);
//  if (nblk>NBLOCKS) exit(1);
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(4)*sizeof(double);
  Ns += nthb * 1 * sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_DPPS
  Ns += nwarps * sizeof(int);
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, nblk*NIJCSW);
    int c0 = nblk*NIJCSW;
    //gpu_twoint_direct_counter_init <<< dimGrid, dimBlock >>> (Labcd, c0);
    //cudaMemcpyH2D(dev->ijcounter + Labcd, &c0, sizeof(int));
#endif
    gpu_twoint_direct_dpps_ <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}
/* ------------------------------------- */

static inttype TWOINT_INTTYPE = INTTYPE_OS;

inttype cuda_twoint_inttype(inttype type)
{
    if (type>=0) TWOINT_INTTYPE = type;
      return TWOINT_INTTYPE;
}

static int (*cuda_host_twoint_direct[])(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) = {
#if 0
  ofmo_twoint_direct_ssss__,
  // Obara-Saika式（一般式、C言語）
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
  ofmo_twoint_direct_xxxx, ofmo_twoint_direct_xxxx,
#endif
  ofmo_twoint_direct_ssss__,
  // Obara-Saika式（個別、C言語）
  ofmo_twoint_direct_os_psss, ofmo_twoint_direct_os_psps,
  ofmo_twoint_direct_os_ppss, ofmo_twoint_direct_os_ppps,
  ofmo_twoint_direct_os_pppp, ofmo_twoint_direct_os_dsss,
  ofmo_twoint_direct_os_dsps, ofmo_twoint_direct_os_dspp,
  ofmo_twoint_direct_os_dsds, ofmo_twoint_direct_os_dpss,
  ofmo_twoint_direct_os_dpps, ofmo_twoint_direct_os_dppp,
  ofmo_twoint_direct_os_dpds, ofmo_twoint_direct_os_dpdp,
  ofmo_twoint_direct_os_ddss, ofmo_twoint_direct_os_ddps,
  ofmo_twoint_direct_os_ddpp, ofmo_twoint_direct_os_ddds,
  ofmo_twoint_direct_os_dddp, ofmo_twoint_direct_os_dddd,
#if 0
  ofmo_twoint_direct_ssss__,
  // Rys求積法（一般式、C言語）
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_rys_xxxx, ofmo_twoint_direct_rys_xxxx,
  ofmo_twoint_direct_ssss__,
  // Rys求積法（個別、C言語）
  ofmo_twoint_direct_rys_psss, ofmo_twoint_direct_rys_psps,
  ofmo_twoint_direct_rys_ppss, ofmo_twoint_direct_rys_ppps,
  ofmo_twoint_direct_rys_pppp, ofmo_twoint_direct_rys_dsss,
  ofmo_twoint_direct_rys_dsps, ofmo_twoint_direct_rys_dspp,
  ofmo_twoint_direct_rys_dsds, ofmo_twoint_direct_rys_dpss,
  ofmo_twoint_direct_rys_dpps, ofmo_twoint_direct_rys_dppp,
  ofmo_twoint_direct_rys_dpds, ofmo_twoint_direct_rys_dpdp,
  ofmo_twoint_direct_rys_ddss, ofmo_twoint_direct_rys_ddps,
  ofmo_twoint_direct_rys_ddpp, ofmo_twoint_direct_rys_ddds,
  ofmo_twoint_direct_rys_dddp, ofmo_twoint_direct_rys_dddd,
#endif
};


static int (*cuda_twoint_direct[])(
        // paralleization
        const int *pnworkers, const int *pworkerid,
        // integral type data
        const int *pLa, const int *pLb, const int *pLc, const int *pLd,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long *petmp_max_nzeri, long *petmp_non_zero_eri,
        double etmp_val[], short int etmp_ind4[],
        const int *plast_ijcs, const int *plast_klcs,
        // density matrix & G-matrix data
        const int *pnao, const double Ds[], double G[] ) = {
  //ofmo_twoint_direct_ssss__,
  cuda_twoint_direct_ssss_,
  cuda_twoint_direct_psss_, cuda_twoint_direct_psps_,
  cuda_twoint_direct_ppss_, cuda_twoint_direct_ppps_,
  cuda_twoint_direct_pppp_, cuda_twoint_direct_dsss_,
  cuda_twoint_direct_dsps_, cuda_twoint_direct_dspp_,
  ofmo_twoint_direct_os_dsds, ofmo_twoint_direct_os_dpss,
//  ofmo_twoint_direct_os_dpps, ofmo_twoint_direct_os_dppp,
  cuda_twoint_direct_dpps_, ofmo_twoint_direct_os_dppp,
  ofmo_twoint_direct_os_dpds, ofmo_twoint_direct_os_dpdp,
  ofmo_twoint_direct_os_ddss, ofmo_twoint_direct_os_ddps,
  ofmo_twoint_direct_os_ddpp, ofmo_twoint_direct_os_ddds,
  ofmo_twoint_direct_os_dddp, ofmo_twoint_direct_os_dddd,
};

char *cuda_s2e[] = {
  "ssss", "psss", "psps", "ppss", "ppps", "pppp",
  "dsss", "dsps", "dspp", "dsds", "dpss", "dpps",
  "dppp", "dpds", "dpdp", "ddss", "ddps", "ddpp",
  "ddds", "dddp", "dddd",
  "buff",
};
int cuda_get_num_types(void)
{
  return sizeof(dim2e)/(sizeof(int)*2)-1;
}


#if 0
static double w2e[] = {
   -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
   -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
   -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
   -1.0e0,  -1.0e0,  -1.0e0,
   -1.0e0, // buffered
};
#ifdef _OPENMP
#pragma omp threadprivate(w2e)
#endif

int cuda_get_num_types(void)
{
  return sizeof(w2e)/sizeof(double);
}

void cuda_print_w2e(void) {
  int i;
  int n = cuda_get_num_types();
#ifdef _OPENMP
#pragma omp master
#endif
  {
    printf("--- w2e ---\n");
    for (i=0; i<n; i++) {
      if (w2e[i]>=0) {
        int nb=0, nt=0;
        if (dim2e[i][0]!=0) {
          nb = dim2e[i][0];
          nt = dim2e[i][1];
        }
        printf("%4s: %8.4f (%3d,%3d)\n",s2e[i],w2e[i],nb,nt);
      }
    }
    printf("-----------\n");
  }
}
#endif


__host__ int cuda_calc_twoint_direct(
        const int Labcd,
        // paralleization for CPU
        const int nworkers, const int workerid,
        // integral type data
        const int La, const int Lb, const int Lc, const int Ld,
        // basis set & cutoff table data
        const int shel_atm[], const int shel_ini[],
        const double atom_x[], const double atom_y[],
        const double atom_z[], const int leading_cs_pair[],
        const double csp_schwarz[],
        const int csp_ics[], const int csp_jcs[],
        const int csp_leading_ps_pair[],
        const double psp_zeta[], const double psp_dkps[],
        const double psp_xiza[],
        // concerned about buffered direct method
        const long max_nzeri, long *p_nzeri,
        double etmp_val[], short int etmp_ind4[],
        const int last_ijcs, const int last_klcs,
        // density matrix & G-matrix data
        const int nao, const double Ds[], double G[])
{
  int NDEV = cuda_get_numDevice();
  double w0,w1;
  int master=TRUE;
  int optsync=cuda_get_optsync();
  //int buffered = (Labcd <= ofmo_twoint_get_global_last_eri_type());
  int gpu = (cuda_use_Device() && cuda_get_optCPU(Labcd)!=0);
  int type = cuda_twoint_inttype(INTTYPE_QUERY);

//  if (optsync) cuda_Barrier();

//  w0 = cuda_Wtime();
//  if (NDEV<0) return 2;
//  if (cuda_use_Device() && dim2e[Labcd][0]!=0 && !buffered) {
  if (gpu) {
    if (NDEV>0&&optsync) checkCudaErrors(cudaDeviceSynchronize());
    //fprintf(stderr,"Labcd: %d\n",Labcd);
        cuda_twoint_direct[Labcd](
                            &nworkers, &workerid,
                            &La, &Lb, &Lc, &Ld,
                            shel_atm, shel_ini,
                            atom_x, atom_y, atom_z,
                            leading_cs_pair,
                            csp_schwarz, csp_ics, csp_jcs,
                            csp_leading_ps_pair,
                            psp_zeta, psp_dkps, psp_xiza,
                            &max_nzeri, p_nzeri,
                            etmp_val, etmp_ind4,
                            &last_ijcs, &last_klcs,
                            &nao, Ds, G );
    if (NDEV>0&&optsync) checkCudaErrors(cudaDeviceSynchronize());
  } else {
    int L = Labcd + type*21;
        cuda_host_twoint_direct[Labcd](
                            &nworkers, &workerid,
                            &La, &Lb, &Lc, &Ld,
                            shel_atm, shel_ini,
                            atom_x, atom_y, atom_z,
                            leading_cs_pair,
                            csp_schwarz, csp_ics, csp_jcs,
                            csp_leading_ps_pair,
                            psp_zeta, psp_dkps, psp_xiza,
                            &max_nzeri, p_nzeri,
                            etmp_val, etmp_ind4,
                            &last_ijcs, &last_klcs,
                            &nao, Ds, G );
  }
//  if (optsync) cuda_Barrier();
//  w1 = cuda_Wtime();
//  if (w2e[Labcd]<0) w2e[Labcd]=0.0e0;
//  w2e[Labcd] += w1-w0;

  return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <assert.h>

#include <cuda.h>

#ifdef _OPENMP
#include <omp.h>
#endif

#include "cuda-drv.h"
#include "cudalib.h"
#include "cuda-ifc4c.h"
#include "cuda-ifc4c-os.h"

#ifdef __cplusplus
extern "C" {
#endif
//#include "integ/ofmo-twoint-direct.h"
//#include "integ/ofmo-index.h"
extern FILE* fp_prof; // from common/ofmo-prof.h
#ifdef __cplusplus
}
#endif

#ifndef ZERO
#define ZERO 0.0e0
#endif
static int NCS_F;
static int NCS_M;

static struct {
  int maxlqn;
  int max_num_klcs;
  int nat_f;
  int ncs_f;
  int nao_f;
  int ncspair_f;
  int npspair_f;
  int nat_m;
  int ncs_m;
  int nao_m;
  int ncspair_m;
  int npspair_m;
} ifc4cParam;

/* ------------------------------------- */
__device__ __constant__ int ncs_frg;
__device__ __constant__ int nat_frg;
__device__ __constant__ int nao_frg;
__device__ __constant__ int ncspair_frg;
__device__ __constant__ int npspair_frg;
__device__ __constant__ int ncs_mon;
__device__ __constant__ int nat_mon;
__device__ __constant__ int nao_mon;
__device__ __constant__ int ncspair_mon;
__device__ __constant__ int npspair_mon;

__device__ __constant__ int *shel_atm_frg;
__device__ __constant__ int *shel_ini_frg;
__device__ __constant__ double *atom_x_frg;
__device__ __constant__ double *atom_y_frg;
__device__ __constant__ double *atom_z_frg;
__device__ __constant__ int *leading_cs_pair_frg;
__device__ __constant__ int *leading_cs_frg;
__device__ __constant__ int *csp_leading_ps_pair_frg;
__device__ __constant__ int *csp_ics_frg;
__device__ __constant__ int *csp_jcs_frg;
__device__ __constant__ float *csp_schwarz_frg;
__device__ __constant__ double *psp_zeta_frg;
__device__ __constant__ double *psp_dkps_frg;
__device__ __constant__ double *psp_xiza_frg;
__device__ __constant__ int *shel_atm_mon;
__device__ __constant__ int *shel_ini_mon;
__device__ __constant__ double *atom_x_mon;
__device__ __constant__ double *atom_y_mon;
__device__ __constant__ double *atom_z_mon;
__device__ __constant__ int *leading_cs_pair_mon;
__device__ __constant__ int *leading_cs_mon;
__device__ __constant__ int *csp_leading_ps_pair_mon;
__device__ __constant__ int *csp_ics_mon;
__device__ __constant__ int *csp_jcs_mon;
__device__ __constant__ float *csp_schwarz_mon;
__device__ __constant__ double *psp_zeta_mon;
__device__ __constant__ double *psp_dkps_mon;
__device__ __constant__ double *psp_xiza_mon;
__device__ __constant__ double *D_mon;
__device__ __constant__ double *V_frg;
__device__ __constant__ double *V_frgP;

/* ------------------------------------- */
static int ifc4c_Initialized = FALSE;

static double *Vifc4c = NULL;

#if 0
#define cudaDevMallocAndSetSymbol(name, num, kind) \
  {ret--; \
   if (cudaMalloc((void **)&(dev->name), (num)*sizeof(kind))!=cudaSuccess) break; \
   if (cudaMemcpyToSymbol(name, &(dev->name), sizeof(dev->name))!=cudaSuccess) break;}
#else
#define McudaDevMallocAndSetSymbol(name, num, kind) \
  {ret--;\
   if (dev->name!=NULL) {ret-=1000; break;}; \
   if ((err=cudaMalloc((void **)&(dev->name), (num)*sizeof(kind)))!=cudaSuccess) break; \
   if ((err=cudaMemcpyToSymbol(name, &(dev->name), sizeof(dev->name)))!=cudaSuccess) break;}
#endif

// arg: maximum value to malloc
__host__ int cuda_ifc4c_Init(const int maxlqn, const int max_num_klcs0,
    const int nat_f, const int ncs_f, const int nao_f,
    const int ncspair_f, const int npspair_f,
    const int nat_m, const int ncs_m, const int nao_m,
    const int ncspair_m, const int npspair_m)
{
  char fn[]="cuda_ifc4c_Init";
  cudaError_t err;
  int i,ret;
  int NDEV = cuda_get_numDevice();
  int maxlqn2 = (maxlqn+1)*(maxlqn+2)/2;

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (ifc4c_Initialized) return 1;
  if(fp_prof) fprintf(fp_prof, "(%d) %s(%d,%d)\n", CUDA_ME, fn, nao_f, nao_m);

  //ret = cuda_set_BT(nblk, nthb, maxlqn);
  //if (ret<0) return ret;
  //int nblk = cuda_get_numBlocks();
  //int nthb = cuda_get_numThreads();
  int nblk=0, nthb=0;
  for (i=0;i<6*6;i++) nblk=MAX2(nblk, dim_ifc4c[i][0]);

  double *DFACT0=ofmo_getadd_dfact();

  for (i=0; i<NDEV; i++) {
    ret = -(i+1)*100;
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    cudaMemcpyToSymbol(max_num_klcs, &max_num_klcs0, sizeof(int));
    McudaDevMallocAndSetSymbol(sklcs_b, max_num_klcs0*nblk, int);
    McudaDevMallocAndSetSymbol(shel_atm_frg, ncs_f, int);
    McudaDevMallocAndSetSymbol(shel_ini_frg, ncs_f+1, int);
    McudaDevMallocAndSetSymbol(atom_x_frg, nat_f, double);
    McudaDevMallocAndSetSymbol(atom_y_frg, nat_f, double);
    McudaDevMallocAndSetSymbol(atom_z_frg, nat_f, double);
    McudaDevMallocAndSetSymbol(leading_cs_frg, maxlqn+2, int);
    McudaDevMallocAndSetSymbol(leading_cs_pair_frg, maxlqn2+2, int);
    McudaDevMallocAndSetSymbol(csp_leading_ps_pair_frg, ncspair_f+1, int);
    McudaDevMallocAndSetSymbol(csp_ics_frg, ncspair_f, int);
    McudaDevMallocAndSetSymbol(csp_jcs_frg, ncspair_f, int);
    McudaDevMallocAndSetSymbol(psp_zeta_frg, npspair_f, double);
    McudaDevMallocAndSetSymbol(psp_dkps_frg, npspair_f, double);
    McudaDevMallocAndSetSymbol(psp_xiza_frg, npspair_f, double);
    McudaDevMallocAndSetSymbol(csp_schwarz_frg, ncspair_f, float);
    McudaDevMallocAndSetSymbol(shel_atm_mon, ncs_m, int);
    McudaDevMallocAndSetSymbol(shel_ini_mon, ncs_m+1, int);
    McudaDevMallocAndSetSymbol(atom_x_mon, nat_m, double);
    McudaDevMallocAndSetSymbol(atom_y_mon, nat_m, double);
    McudaDevMallocAndSetSymbol(atom_z_mon, nat_m, double);
    McudaDevMallocAndSetSymbol(leading_cs_mon, maxlqn+2, int);
    McudaDevMallocAndSetSymbol(leading_cs_pair_mon, maxlqn2+2, int);
    McudaDevMallocAndSetSymbol(csp_leading_ps_pair_mon, ncspair_m+1, int);
    McudaDevMallocAndSetSymbol(csp_ics_mon, ncspair_m, int);
    McudaDevMallocAndSetSymbol(csp_jcs_mon, ncspair_m, int);
    McudaDevMallocAndSetSymbol(psp_zeta_mon, npspair_m, double);
    McudaDevMallocAndSetSymbol(psp_dkps_mon, npspair_m, double);
    McudaDevMallocAndSetSymbol(psp_xiza_mon, npspair_m, double);
    McudaDevMallocAndSetSymbol(csp_schwarz_mon, ncspair_m, float);
    McudaDevMallocAndSetSymbol(D_mon, (nao_m*nao_m+nao_m)/2, double);
    McudaDevMallocAndSetSymbol(V_frg, (nao_f*nao_f+nao_f)/2, double);
    McudaDevMallocAndSetSymbol(V_frgP, (nao_f*nao_f+nao_f)/2, double);
    McudaDevMallocAndSetSymbol(Dcs, ncs_m*ncs_m, float);
    McudaDevMallocAndSetSymbol(ijcounter, 6*6, int);
#ifdef SORT_INDEX_SCHWARZ
    McudaDevMallocAndSetSymbol(sorted_csp, ncspair_f, int);
#endif
    McudaDevMallocAndSetSymbol(DFACT, 36, double);
    ret --;
    McudaMemcpyH2D(dev->DFACT, DFACT0, 36*sizeof(double));
    ret = 0;
  }
  if (ret<0 && fp_prof) {
    if (ret<-1000) {
      fprintf(fp_prof, "(%d) %s() %d: may not clean pointer!\n", CUDA_ME, fn, ret);
    } else {
      fprintf(fp_prof, "(%d) %s() %d: %s\n", CUDA_ME, fn, ret, cudaGetErrorString(err));
    }
    fprintf(fp_prof, "(%d) %s(%d,%d,\n"
                     "        %d,%d,%d,%d,%d,\n"
                     "        %d,%d,%d,%d,%d)\n", CUDA_ME, fn,
                     maxlqn, max_num_klcs0,
                     nat_f, ncs_f, nao_f, ncspair_f, npspair_f,
                     nat_m, ncs_m, nao_m, ncspair_m, npspair_m);
    fflush(fp_prof);
    exit(ret);
  }
  assert(Vifc4c==NULL);
  if ((Vifc4c=(double *)malloc((nao_f*nao_f+nao_f)/2*sizeof(double)))==NULL) exit(-1);

  NCS_F=ncs_f;
  NCS_M=ncs_m;
  ifc4c_Initialized = TRUE;

  ifc4cParam.maxlqn = maxlqn;
  ifc4cParam.max_num_klcs= max_num_klcs0;
  ifc4cParam.nat_f = nat_f;
  ifc4cParam.ncs_f = ncs_f;
  ifc4cParam.nao_f = nao_f;
  ifc4cParam.ncspair_f = ncspair_f;
  ifc4cParam.npspair_f = npspair_f;
  ifc4cParam.nat_m = nat_m;
  ifc4cParam.ncs_m = ncs_m;
  ifc4cParam.nao_m = nao_m;
  ifc4cParam.ncspair_m = ncspair_m;
  ifc4cParam.npspair_m = npspair_m;

  return 0;
}

#undef McudaDevMallocAndSetSymbol

#define McudaDevFree(name) \
  {ret--; \
    if ((err=cudaFree(dev->name))!=cudaSuccess) break; dev->name = NULL;}

__host__ int cuda_ifc4c_Finalize(void)
{
  char fn[]="cuda_ifc4c_Finalize";
  cudaError_t err;
  int i,ret;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!ifc4c_Initialized) return 1;
  if(fp_prof) fprintf(fp_prof, "(%d) %s()\n", CUDA_ME, fn);

  for (i=0; i<NDEV; i++) {
    ret = -(i+1)*100;
    struct dev_Data *dev = devData + i;

    cuda_set_Device(i);
    McudaDevFree(sklcs_b);
    McudaDevFree(shel_atm_frg);
    McudaDevFree(shel_ini_frg);
    McudaDevFree(atom_x_frg);
    McudaDevFree(atom_y_frg);
    McudaDevFree(atom_z_frg);
    McudaDevFree(leading_cs_frg);
    McudaDevFree(leading_cs_pair_frg);
    McudaDevFree(csp_leading_ps_pair_frg);
    McudaDevFree(csp_ics_frg);
    McudaDevFree(csp_jcs_frg);
    McudaDevFree(psp_zeta_frg);
    McudaDevFree(psp_dkps_frg);
    McudaDevFree(psp_xiza_frg);
    McudaDevFree(csp_schwarz_frg);
    McudaDevFree(shel_atm_mon);
    McudaDevFree(shel_ini_mon);
    McudaDevFree(atom_x_mon);
    McudaDevFree(atom_y_mon);
    McudaDevFree(atom_z_mon);
    McudaDevFree(leading_cs_mon);
    McudaDevFree(leading_cs_pair_mon);
    McudaDevFree(csp_leading_ps_pair_mon);
    McudaDevFree(csp_ics_mon);
    McudaDevFree(csp_jcs_mon);
    McudaDevFree(psp_zeta_mon);
    McudaDevFree(psp_dkps_mon);
    McudaDevFree(psp_xiza_mon);
    McudaDevFree(csp_schwarz_mon);
    McudaDevFree(D_mon);
    McudaDevFree(V_frg);
    McudaDevFree(V_frgP);
    McudaDevFree(Dcs);
    McudaDevFree(ijcounter);
#ifdef SORT_INDEX_SCHWARZ
    McudaDevFree(sorted_csp);
#endif
    McudaDevFree(DFACT);
    ret = 0;
  }
  if (ret<0 && fp_prof) {
    fprintf(fp_prof, "(%d) %s(): %d\n", CUDA_ME, fn, ret);
    fflush(fp_prof);
    exit(ret);
  }

  free(Vifc4c); Vifc4c = NULL;
  ifc4c_Initialized = FALSE;

  return 0;
}
#undef McudaDevFree

/* ------------------------------------- */
#define McudaMemcpyToSymbolH2D(dst, src, kind) \
  {ret--; \
   if (cudaMemcpyToSymbol(dst, src, sizeof(kind))!=cudaSuccess) return ret;}

__host__ int cuda_ifc4c_SetData_Symbol(const int iorj, const int maxlqn0,
    const int nat0, const int ncs0, const int nao0,
    const int ncspair0, const int npspair0)
{
  cudaError_t err;
  int ret=-100*(iorj+1);

  if (!ifc4c_Initialized) return -1;

  if (iorj==0) {
    McudaMemcpyToSymbolH2D(ncs_frg, &ncs0, int);
    McudaMemcpyToSymbolH2D(nao_frg, &nao0, int);
    McudaMemcpyToSymbolH2D(nat_frg, &nat0, int);
    McudaMemcpyToSymbolH2D(ncspair_frg, &ncspair0, int);
    McudaMemcpyToSymbolH2D(npspair_frg, &npspair0, int);
    McudaMemcpyToSymbolH2D(maxlqn, &maxlqn0, int);
  } else {
    McudaMemcpyToSymbolH2D(ncs_mon, &ncs0, int);
    McudaMemcpyToSymbolH2D(nao_mon, &nao0, int);
    McudaMemcpyToSymbolH2D(nat_mon, &nat0, int);
    McudaMemcpyToSymbolH2D(ncspair_mon, &ncspair0, int);
    McudaMemcpyToSymbolH2D(npspair_mon, &npspair0, int);
  }

  return 0;
}
#undef McudaMemcpyToSymbolH2D

#if 1
#define McudaDevMemcpyH2D(name, frg, num, kind) \
  {ret--; narg=(num); \
   if (cudaMemcpy(dev->name##_##frg, name, (num)*sizeof(kind),cudaMemcpyHostToDevice)!=cudaSuccess) break;}
#else
#define McudaDevMemcpyH2D(name, frg, num, kind) \
    checkCudaErrors(cudaMemcpy(dev->name##_##frg, name, (num)*sizeof(kind),cudaMemcpyHostToDevice));
#endif

__host__ int cuda_ifc4c_SetData(const int iorj, const int maxlqn,
    const int nat, const int ncs, const int nao,
    const int ncspair, const int npspair,
    const int *shel_atm, const int *shel_ini,
    const double *atom_x, const double *atom_y, const double *atom_z,
    const int *leading_cs_pair, const int *csp_leading_ps_pair,
    const int *csp_ics, const int *csp_jcs,
    const double *psp_zeta, const double *psp_dkps, const double *psp_xiza,
    const float *csp_schwarz, const double *D)
{
  char fn[]="cuda_ifc4c_SetData";
  cudaError_t err;
  int i,ret,narg;
  int NDEV = cuda_get_numDevice();
  int maxlqn2 = (maxlqn+1)*(maxlqn+2)/2;

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!ifc4c_Initialized) return -1;

#ifdef SORT_INDEX_SCHWARZ
  int *sorted_csp;
  if (iorj==0) {
    if ((sorted_csp=(int *)malloc(ncspair*sizeof(int)))==NULL) return -1;
    ret = cuda_sort_csp_schwarz(sorted_csp, ncspair, maxlqn, leading_cs_pair, csp_schwarz);
    if (ret<0) return ret;
  }
#endif

  for (i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    checkCudaErrors(cudaDeviceSynchronize());
    ret =cuda_ifc4c_SetData_Symbol(iorj, maxlqn, nat, ncs, nao,
        ncspair, npspair);
    if (ret<0) return ret;
    ret = -(i+1)*1000 - iorj*100;
    if (iorj==0) {
//      for (int j=0;j<(nao*nao+nao)/2;j++) Vifc4c[j]=0e0;
//      err = cudaMemcpyH2D(dev->V_frg, Vifc4c, (nao*nao+nao)/2*sizeof(double));
      gpu_ifc4c_ClearVfrg <<< dev->numSM, 768 >>> (nao, dev->V_frg);
      gpu_ifc4c_ClearVfrg <<< dev->numSM, 768 >>> (nao, dev->V_frgP);
      McudaDevMemcpyH2D(shel_atm, frg, ncs, int);
      McudaDevMemcpyH2D(shel_ini, frg, ncs+1, int);
      McudaDevMemcpyH2D(atom_x, frg, nat, double);
      McudaDevMemcpyH2D(atom_y, frg, nat, double);
      McudaDevMemcpyH2D(atom_z, frg, nat, double);
      McudaDevMemcpyH2D(leading_cs_pair, frg, maxlqn2+2, int);
      McudaDevMemcpyH2D(csp_leading_ps_pair, frg, ncspair+1, int);
      McudaDevMemcpyH2D(csp_ics, frg, ncspair, int);
      McudaDevMemcpyH2D(csp_jcs, frg, ncspair, int);
      McudaDevMemcpyH2D(psp_zeta, frg, npspair, double);
      McudaDevMemcpyH2D(psp_dkps, frg, npspair, double);
      McudaDevMemcpyH2D(psp_xiza, frg, npspair, double);
      McudaDevMemcpyH2D(csp_schwarz, frg, ncspair, float);
#ifdef SORT_INDEX_SCHWARZ
      ret--;
      McudaMemcpyH2D(dev->sorted_csp, sorted_csp, ncspair*sizeof(int));
#endif
      checkCudaErrors(cudaDeviceSynchronize());
    } else {
      McudaDevMemcpyH2D(shel_atm, mon, ncs, int);
      McudaDevMemcpyH2D(shel_ini, mon, ncs+1, int);
      McudaDevMemcpyH2D(atom_x, mon, nat, double);
      McudaDevMemcpyH2D(atom_y, mon, nat, double);
      McudaDevMemcpyH2D(atom_z, mon, nat, double);
      McudaDevMemcpyH2D(leading_cs_pair, mon, maxlqn2+2, int);
      McudaDevMemcpyH2D(csp_leading_ps_pair, mon, ncspair+1, int);
      McudaDevMemcpyH2D(csp_ics, mon, ncspair, int);
      McudaDevMemcpyH2D(csp_jcs, mon, ncspair, int);
      McudaDevMemcpyH2D(psp_zeta, mon, npspair, double);
      McudaDevMemcpyH2D(psp_dkps, mon, npspair, double);
      McudaDevMemcpyH2D(psp_xiza, mon, npspair, double);
      McudaDevMemcpyH2D(csp_schwarz, mon, ncspair, float);
      McudaDevMemcpyH2D(D, mon, (nao*nao+nao)/2, double);
    }
    ret = 0;
  }
#ifdef SORT_INDEX_SCHWARZ
  if (iorj==0) free(sorted_csp);
#endif
  if (ret<0 && fp_prof) {
    //fprintf(fp_prof, "(%d) %s(): %d\n", CUDA_ME, fn, ret);
    fprintf(fp_prof, "(%d) %s(): %d %d\n", CUDA_ME, fn, ret, narg);
    fprintf(fp_prof, "(%d) %s(): %d %d %d %d %d\n", CUDA_ME, fn, nat, ncs, nao, ncspair, npspair);
    if (iorj==0) fprintf(fp_prof, "(%d) %s(): %d %d %d %d %d\n", CUDA_ME, fn, ifc4cParam.nat_f, ifc4cParam.ncs_f, ifc4cParam.nao_f, ifc4cParam.ncspair_f, ifc4cParam.npspair_f);
    else         fprintf(fp_prof, "(%d) %s(): %d %d %d %d %d\n", CUDA_ME, fn, ifc4cParam.nat_m, ifc4cParam.ncs_m, ifc4cParam.nao_m, ifc4cParam.ncspair_m, ifc4cParam.npspair_m);

    fflush(fp_prof);
    exit(ret);
  }
  //if (iorj==0) assert(ncs<=NCS_F);
  //else         assert(ncs<=NCS_M);
  //if (iorj==0) NCS_F=ncs;
  //else         NCS_M=ncs;
  return 0;
}

#undef McudaDevMemcpyH2D

/* ------------------------------------- */

__global__ void gpu_ifc4c_ClearVfrg(const int nao, double *V)
{
  int tidx = blockIdx.x * blockDim.x + threadIdx.x;
  int nth  = gridDim.x * blockDim.x;
//  int nao = nao_frg;

  __threadfence();
  for (int i=tidx; i<(nao*nao+nao)/2; i+=nth) V[i]=ZERO;
  __syncthreads();
  __threadfence();
}

__global__ void gpu_ifc4c_PsumVfrg(const int nao, double *V, double *VP)
{
  int tidx = blockIdx.x * blockDim.x + threadIdx.x;
  int nth  = gridDim.x * blockDim.x;

  __threadfence();
  for (int i=tidx; i<(nao*nao+nao)/2; i+=nth) {
    VP[i] += V[i];
    V[i]   = ZERO;
  }
  __syncthreads();
  __threadfence();
}


/* ------------------------------------- */

__host__ int cuda_ifc4c_calc_Init(void)
{
  cudaError_t err;
  int NDEV = cuda_get_numDevice();
  int c0[6*6];

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!ifc4c_Initialized) return -1;
  for (int i=0; i<6*6; i++) c0[i] = dim_ifc4c[i][0];

  for (int i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    McudaMemcpyH2D(dev->ijcounter, c0, 6*6*sizeof(int));
  }
  return 0;
}

/* ------------------------------------- */

__host__ int cuda_ifc4c_SetDcs(const int ncs, const float *Dcs)
{
  cudaError_t err;
  int NDEV = cuda_get_numDevice();

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!ifc4c_Initialized) return -1;
  char fn[]="cuda_ifc4c_SetDcs";
  //assert(ncs<=NCS_M);

  for (int i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    McudaMemcpyH2D(dev->Dcs, Dcs, ncs*ncs*sizeof(float));
  }
  return 0;
}

/* ------------------------------------- */

__host__ int cuda_ifc4c_GetVfrg(const int nao, double *V)
{
  char fn[]="cuda_ifc4c_GetVfrg";
  cudaError_t err;
  int NDEV = cuda_get_numDevice();
  int nao2=(nao*nao+nao)/2;

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!ifc4c_Initialized) return -1;

  for (int i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    checkCudaErrors(cudaDeviceSynchronize());
    gpu_ifc4c_PsumVfrg <<< dev->numSM, 768 >>> (nao, dev->V_frgP, dev->V_frg);
    McudaMemcpyD2H(Vifc4c, dev->V_frg, nao2*sizeof(double));
    for (int j=0; j<nao2; j++) V[j]+=Vifc4c[j];
  }
  return 0;
}

/* ------------------------------------- */

__host__ int cuda_ifc4c_PsumVfrg(const int nao)
{
  char fn[]="cuda_ifc4c_PsumVfrg";
  cudaError_t err;
  int NDEV = cuda_get_numDevice();
  int nao2=(nao*nao+nao)/2;

  if (NDEV<=0) return 2;
  if (devData==NULL) return -1;
  if (!ifc4c_Initialized) return -1;

  for (int i=0; i<NDEV; i++) {
    struct dev_Data *dev = devData + i;
    cuda_set_Device(i);
    checkCudaErrors(cudaDeviceSynchronize());
    gpu_ifc4c_PsumVfrg <<< dev->numSM, 768 >>> (nao, dev->V_frg, dev->V_frgP);
  }
  return 0;
}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>

#undef CUDA_IFC4C_BENCH

#ifdef _OPENMP
#include <omp.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include "integ/ofmo-integ.h"
#include "integ/ofmo-ifc4c.h"
  extern FILE* fp_prof; // from common/ofmo-prof.h
#ifdef __cplusplus
}
#endif

#include <cuda.h>
#include "cuda-drv.h"
#include "cudalib.h"
#include "cuda-ifc4c.h"
#include "cuda-ifc4c-calc.h"
#include "cuda-fmt-m.h"

// Default {#block/#SMX, #threads/WARP_SIZE} set for each 2e-type
// This array will be converted to actual {#block, #threads} set
// in cuda_Init_Sub() by multiplying #SMX and WARP_SIZE, respectively.
int dim_ifc4c[][2] = {
#if CUDA_ARCH >= 350
 { 14,  7}, // ssss
 { 14,  8}, // ssps
 { 14,  8}, // sspp
 { 14,  6}, // ssds
 { 13,  8}, // ssdp
 { 14,  6}, // ssdd
 { 11,  8}, // psss
 { 11,  6}, // psps
 {  9,  8}, // pspp
 {  8,  7}, // psds
 {  9,  8}, // psdp
 {  0,  0}, // psdd
 {  6,  8}, // ppss
 {  4,  8}, // ppps
 {  3,  8}, // pppp
 {  3,  7}, // ppds
 {  0,  0}, // ppdp
 {  0,  0}, // ppdd
 {  5,  6}, // dsss
 {  6,  8}, // dsps
 {  5,  8}, // dspp
 {  5,  8}, // dsds
 {  5,  8}, // dsdp
 {  0,  0}, // dsdd
 {  4,  8}, // dpss
 {  3,  8}, // dpps
// {  3,  8}, // dppp
 {  0,  0}, // dppp
 {  3,  7}, // dpds
// {  3,  7}, // dpdp
 {  0,  0}, // dpdp
 {  0,  0}, // dpdd
 {  0,  0}, // ddss
 {  0,  0}, // ddps
 {  0,  0}, // ddpp
 {  0,  0}, // ddds
 {  0,  0}, // dddp
 {  0,  0}, // dddd
#else /* FERMI */
 { 12,  8}, // ssss
 { 12,  8}, // ssps
 { 12,  8}, // sspp
 { 12,  8}, // ssds
 { 12,  8}, // ssdp
 {  8,  6}, // ssdd
 {  6,  8}, // psss
 {  6,  6}, // psps
 {  6,  6}, // pspp
 {  6,  6}, // psds
 {  6,  6}, // psdp
 {  0,  0}, // psdd
 {  3,  7}, // ppss
 {  3,  9}, // ppps
 {  3,  6}, // pppp
// {  0,  0},
 {  3,  6}, // ppds
 {  0,  0}, // ppdp
 {  0,  0}, // ppdd
 {  3,  8}, // dsss
 {  3,  6}, // dsps
 {  7,  6}, // dspp
 {  7,  6}, // dsds
 {  9,  6}, // dsdp
// {  0,  0},
 {  0,  0}, // dsdd
 {  3,  6}, // dpss
 {  3,  6}, // dpps
 {  3,  6}, // dppp
// {  0,  0},
 {  3,  6}, // dpds
// {  0,  0},
 {  3,  7}, // dpdp
// {  0,  0},
 {  0,  0}, // dpdd
 {  0,  0}, // ddss
 {  0,  0}, // ddps
 {  0,  0}, // ddpp
 {  0,  0}, // ddds
 {  0,  0}, // dddp
 {  0,  0}, // dddd
#endif
};

int ifc4c_counter_ini_type[] = { // 0 for 0, 1 for nblk, 2 for nblk*NIJCSW
  1, 1, 1, 1, 1, 1, // ssxx
  1, 1, 1, 1, 1, 1, // psxx
  1, 1, 1, 1, 1, 1, // ppxx
  1, 1, 1, 1, 1, 1, // dsxx
  1, 1, 1, 1, 1, 1, // dpxx
  1, 1, 1, 1, 1, 1, // ddxx
};

/* ------------------------------------- */
/* ---- ssss ---- */
__host__ int cuda_ifc4c_os_ssss(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  Labcd=0;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#if 0
#ifdef CUDA_FMT_M_SM
  Ns = cuda_FMT_m_get_size(0)*sizeof(double);
  Ns += nthb * 2 *  sizeof(double);
#else
  Ns = nthb * 3 * sizeof(double);
#endif
#ifdef DLB_KL_SSSS
  Ns += nwarps * sizeof(int);
#endif
#endif
  Ns += nthb *  sizeof(double); // sV
  Ns += nthb *  sizeof(double); // SSSS
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ssss <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ssps ---- */
__host__ int cuda_ifc4c_os_ssps(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(1)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ssps <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- sspp ---- */
__host__ int cuda_ifc4c_os_sspp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(2)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_sspp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ssds ---- */
__host__ int cuda_ifc4c_os_ssds(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(2)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ssds <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ssdp ---- */
__host__ int cuda_ifc4c_os_ssdp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(3)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ssdp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ssdd ---- */
__host__ int cuda_ifc4c_os_ssdd(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ssdd <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- psss ---- */
__host__ int cuda_ifc4c_os_psss(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(1)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += nwarps * Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_psss <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- psps ---- */
__host__ int cuda_ifc4c_os_psps(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(2)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += nwarps * Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_psps <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- pspp ---- */
__host__ int cuda_ifc4c_os_pspp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(3)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += nwarps * Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_pspp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- psds ---- */
__host__ int cuda_ifc4c_os_psds(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(3)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += nwarps * Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_psds <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- psdp ---- */
__host__ int cuda_ifc4c_os_psdp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += nwarps * Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_psdp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ppss ---- */
__host__ int cuda_ifc4c_os_ppss(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(2)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ppss <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ppps ---- */
__host__ int cuda_ifc4c_os_ppps(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(3)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ppps <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- pppp ---- */
__host__ int cuda_ifc4c_os_pppp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_pppp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- ppds ---- */
__host__ int cuda_ifc4c_os_ppds(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_ppds <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dsss ---- */
__host__ int cuda_ifc4c_os_dsss(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(2)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  Ns += nwarps * Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dsss <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dsps ---- */
__host__ int cuda_ifc4c_os_dsps(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(3)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dsps <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dspp ---- */
__host__ int cuda_ifc4c_os_dspp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dspp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dsds ---- */
__host__ int cuda_ifc4c_os_dsds(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dsds <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dsdp ---- */
__host__ int cuda_ifc4c_os_dsdp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(5)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dsdp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dpss ---- */
__host__ int cuda_ifc4c_os_dpss(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(3)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dpss <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dpps ---- */
__host__ int cuda_ifc4c_os_dpps(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(4)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dpps <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dppp ---- */
__host__ int cuda_ifc4c_os_dppp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(5)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dppp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dpds ---- */
__host__ int cuda_ifc4c_os_dpds(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(5)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dpds <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}

/* ------------------------------------- */ /* ---- dpdp ---- */
__host__ int cuda_ifc4c_os_dpdp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int nworkers = *pnworkers;
  int workerid = *pworkerid;
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd=Lab*6+Lcd;
  int Nab = NNAO(La)*NNAO(Lb);

  cudaError_t err;
  int ret = 0;
  int i;
  int NDEV = cuda_get_numDevice();
  struct dev_Data *dev;
  int np = cuda_get_Nprocs();
  int me = cuda_get_myRank();
  int nwks = np * NDEV;
  int iwk0 = me * NDEV;
  int nwarps;
  int nblk,nthb;
  size_t Ns = 0;
  float eps_eri = ofmo_twoint_eps_eri(0);
  float eps_ps4 = ofmo_twoint_eps_ps4(0);
  float eps_sch = ofmo_twoint_eps_sch(0);


//  nblk = NBLOCKS;
//  nwarps = NTHREADS/WARP_SIZE;
  nblk = dim_ifc4c[Labcd][0];
  nthb = dim_ifc4c[Labcd][1];

  nwarps = nthb/WARP_SIZE;
  dim3 dimBlock(WARP_SIZE, nwarps);
  dim3 dimGrid(nblk);
#ifdef CUDA_FMT_M_SM
  Ns += cuda_FMT_m_get_size(6)*sizeof(double); // tbl
#endif
  Ns += nthb * sizeof(double); // sV
#ifdef DLB_KL
  Ns += nwarps * sizeof(int); // klcsw
#endif
  //Ns += nwarps * Nab * sizeof(double); // sVw
  Ns += Nab * sizeof(double); // sVw

  if (NDEV<=0) return 2;
  for (i=0; i<NDEV; i++) {
//    int iwk = iwk0 + i * NBLOCKS;
    int iwk = iwk0 + i;
    dev = cuda_SCF_get_dev_Data(i);
    cuda_set_Device(i);
#ifdef GPU_DLB
    int c0 = nblk;
#endif
    gpu_ifc4c_os_dpdp <<< dimGrid, dimBlock, Ns >>> (nwks, iwk,
        eps_eri, eps_ps4, eps_sch);
  }
  cuda_set_Device(0);

  return 0;
}
/* ------------------------------------- */


static int (*cuda_host_ifc4c_calc_a[])(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) = {
    // original
    /*ofmo_ifc4c_ssss__, ofmo_ifc4c_ssps__, ofmo_ifc4c_sspp__,
    ofmo_ifc4c_ssds__, ofmo_ifc4c_ssdp__, ofmo_ifc4c_ssdd__,
    ofmo_ifc4c_psss__, ofmo_ifc4c_psps__, ofmo_ifc4c_pspp__,
    ofmo_ifc4c_psds__, ofmo_ifc4c_psdp__, ofmo_ifc4c_psdd__,
    ofmo_ifc4c_ppss__, ofmo_ifc4c_ppps__, ofmo_ifc4c_pppp__,
    ofmo_ifc4c_ppds__, ofmo_ifc4c_ppdp__, ofmo_ifc4c_ppdd__,
    ofmo_ifc4c_dsss__, ofmo_ifc4c_dsps__, ofmo_ifc4c_dspp__,
    ofmo_ifc4c_dsds__, ofmo_ifc4c_dsdp__, ofmo_ifc4c_dsdd__,
    ofmo_ifc4c_dpss__, ofmo_ifc4c_dpps__, ofmo_ifc4c_dppp__,
    ofmo_ifc4c_dpds__, ofmo_ifc4c_dpdp__, ofmo_ifc4c_dpdd__,
    ofmo_ifc4c_ddss__, ofmo_ifc4c_ddps__, ofmo_ifc4c_ddpp__,
    ofmo_ifc4c_ddds__, ofmo_ifc4c_dddp__, ofmo_ifc4c_dddd__,*/
    // OS
    ofmo_ifc4c_os_ssss, ofmo_ifc4c_os_ssps, ofmo_ifc4c_os_sspp,
    ofmo_ifc4c_os_ssds, ofmo_ifc4c_os_ssdp, ofmo_ifc4c_os_ssdd,
    ofmo_ifc4c_os_psss, ofmo_ifc4c_os_psps, ofmo_ifc4c_os_pspp,
    ofmo_ifc4c_os_psds, ofmo_ifc4c_os_psdp, ofmo_ifc4c_os_psdd,
    ofmo_ifc4c_os_ppss, ofmo_ifc4c_os_ppps, ofmo_ifc4c_os_pppp,
    ofmo_ifc4c_os_ppds, ofmo_ifc4c_os_ppdp, ofmo_ifc4c_os_ppdd,
    ofmo_ifc4c_os_dsss, ofmo_ifc4c_os_dsps, ofmo_ifc4c_os_dspp,
    ofmo_ifc4c_os_dsds, ofmo_ifc4c_os_dsdp, ofmo_ifc4c_os_dsdd,
    ofmo_ifc4c_os_dpss, ofmo_ifc4c_os_dpps, ofmo_ifc4c_os_dppp,
    ofmo_ifc4c_os_dpds, ofmo_ifc4c_os_dpdp, ofmo_ifc4c_os_dpdd,
    ofmo_ifc4c_os_ddss, ofmo_ifc4c_os_ddps, ofmo_ifc4c_os_ddpp,
    ofmo_ifc4c_os_ddds, ofmo_ifc4c_os_dddp, ofmo_ifc4c_os_dddd,
    // Rys
    /*ofmo_ifc4c_rys_ssss, ofmo_ifc4c_rys_ssps, ofmo_ifc4c_rys_sspp,
    ofmo_ifc4c_rys_ssds, ofmo_ifc4c_rys_ssdp, ofmo_ifc4c_rys_ssdd,
    ofmo_ifc4c_rys_psss, ofmo_ifc4c_rys_psps, ofmo_ifc4c_rys_pspp,
    ofmo_ifc4c_rys_psds, ofmo_ifc4c_rys_psdp, ofmo_ifc4c_rys_psdd,
    ofmo_ifc4c_rys_ppss, ofmo_ifc4c_rys_ppps, ofmo_ifc4c_rys_pppp,
    ofmo_ifc4c_rys_ppds, ofmo_ifc4c_rys_ppdp, ofmo_ifc4c_rys_ppdd,
    ofmo_ifc4c_rys_dsss, ofmo_ifc4c_rys_dsps, ofmo_ifc4c_rys_dspp,
    ofmo_ifc4c_rys_dsds, ofmo_ifc4c_rys_dsdp, ofmo_ifc4c_rys_dsdd,
    ofmo_ifc4c_rys_dpss, ofmo_ifc4c_rys_dpps, ofmo_ifc4c_rys_dppp,
    ofmo_ifc4c_rys_dpds, ofmo_ifc4c_rys_dpdp, ofmo_ifc4c_rys_dpdd,
    ofmo_ifc4c_rys_ddss, ofmo_ifc4c_rys_ddps, ofmo_ifc4c_rys_ddpp,
    ofmo_ifc4c_rys_ddds, ofmo_ifc4c_rys_dddp, ofmo_ifc4c_rys_dddd,*/
};

static int (*cuda_ifc4c_calc_a[])(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) = {
    // OS
    cuda_ifc4c_os_ssss, cuda_ifc4c_os_ssps, cuda_ifc4c_os_sspp,
    cuda_ifc4c_os_ssds, cuda_ifc4c_os_ssdp, cuda_ifc4c_os_ssdd,
    cuda_ifc4c_os_psss, cuda_ifc4c_os_psps, cuda_ifc4c_os_pspp,
    cuda_ifc4c_os_psds, cuda_ifc4c_os_psdp, ofmo_ifc4c_os_psdd,
    cuda_ifc4c_os_ppss, cuda_ifc4c_os_ppps, cuda_ifc4c_os_pppp,
    cuda_ifc4c_os_ppds, ofmo_ifc4c_os_ppdp, ofmo_ifc4c_os_ppdd,
    cuda_ifc4c_os_dsss, cuda_ifc4c_os_dsps, cuda_ifc4c_os_dspp,
    cuda_ifc4c_os_dsds, cuda_ifc4c_os_dsdp, ofmo_ifc4c_os_dsdd,
    cuda_ifc4c_os_dpss, cuda_ifc4c_os_dpps, cuda_ifc4c_os_dppp,
    cuda_ifc4c_os_dpds, cuda_ifc4c_os_dpdp, ofmo_ifc4c_os_dpdd,
    ofmo_ifc4c_os_ddss, ofmo_ifc4c_os_ddps, ofmo_ifc4c_os_ddpp,
    ofmo_ifc4c_os_ddds, ofmo_ifc4c_os_dddp, ofmo_ifc4c_os_dddd,
};

static char *sifc4c[] = {
#if 0
  "ssss", "ssps", "sspp", "ssds", "ssdp", "ssdd",
  "psss", "psps", "pspp", "psds", "psdp", "psdd",
  "ppss", "ppps", "pppp", "ppds", "ppdp", "ppdd",
  "dsss", "dsps", "dspp", "dsds", "dsdp", "dsdd",
  "dpss", "dpps", "dppp", "dpds", "dpdp", "dpdd",
  "ddss", "ddps", "ddpp", "ddds", "dddp", "dddd",
#else
  "(ss,ss)", "(ss,ps)", "(ss,pp)", "(ss,ds)", "(ss,dp)", "(ss,dd)",
  "(ps,ss)", "(ps,ps)", "(ps,pp)", "(ps,ds)", "(ps,dp)", "(ps,dd)",
  "(pp,ss)", "(pp,ps)", "(pp,pp)", "(pp,ds)", "(pp,dp)", "(pp,dd)",
  "(ds,ss)", "(ds,ps)", "(ds,pp)", "(ds,ds)", "(ds,dp)", "(ds,dd)",
  "(dp,ss)", "(dp,ps)", "(dp,pp)", "(dp,ds)", "(dp,dp)", "(dp,dd)",
  "(dd,ss)", "(dd,ps)", "(dd,pp)", "(dd,ds)", "(dd,dp)", "(dd,dd)",
#endif
};
static double wifc4c[] = {
  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,  -1.0e0,
};

void cuda_print_wifc4c(void) {
  int i;
  int n = 6*6;

  int NDEV = cuda_get_numDevice();
//  if (NDEV<=0) return;
  if (CUDA_ME!=0) return;
#ifdef CUDA_IFC4C_BENCH
#ifdef _OPENMP
#pragma omp master
#endif
  {
    printf("--- wifc4c ---\n");
    for (i=0; i<n; i++) {
      if (wifc4c[i]>=0) {
        int nb=0, nt=0;
        if (NDEV>0&&dim_ifc4c[i][0]!=0) {
          nb = dim_ifc4c[i][0];
          nt = dim_ifc4c[i][1];
        }
//        printf("%4s %8.4f (%3d,%3d)\n",sifc4c[i],wifc4c[i],nb,nt);
        printf("%7s %8.4f (%3d,%3d)\n",sifc4c[i],wifc4c[i],nb,nt);
      }
      wifc4c[i]=-1.0e0;
    }
    printf("-----------\n");
    fflush(stdout);
  }
#endif /* CUDA_IFC4C_BENCH */
}

__host__ int cuda_ifc4c_calc( const int idev,
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[], const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] )
{
  int NDEV = cuda_get_numDevice();
  int La = *pLa, Lb = *pLb, Lc = *pLc, Ld = *pLd;
  int Lab = La*(La+1)/2 + Lb;
  int Lcd = Lc*(Lc+1)/2 + Ld;
  int Labcd = Lab*6 + Lcd;

#if 0
#pragma omp master
  {
    int ijcs0 = leading_cs_pair_frg[Lab];
    int ijcs1 = leading_cs_pair_frg[Lab+1];
    int klcs0 = leading_cs_pair_mon[Lcd];
    int klcs1 = leading_cs_pair_mon[Lcd+1];
    int nijcs = ijcs1-ijcs0+1;
    int nklcs = klcs1-klcs0+1;
    if (fp_prof) fprintf(fp_prof, "%s: %d-%d\n", sifc4c[Labcd], nijcs, nklcs);
  }
#endif

#ifdef CUDA_IFC4C_BENCH
#pragma omp master
  checkCudaErrors(cudaDeviceSynchronize());
#pragma omp barrier
  double w0,w1;
#pragma omp master
  w0 = cuda_Wtime();
#endif /* CUDA_IFC4C_BENCH */
  if (NDEV==0||dim_ifc4c[Labcd][0]==0) {
    if (idev==0)
    cuda_host_ifc4c_calc_a[Labcd](
        pnworkers, pworkerid,
        pLa, pLb, pLc, pLd,
        shel_atm_frg, shel_ini_frg,
        atom_x_frg, atom_y_frg, atom_z_frg,
        leading_cs_pair_frg,
        csp_schwarz_frg, csp_ics_frg, csp_jcs_frg,
        csp_leading_ps_pair_frg,
        psp_zeta_frg, psp_dkps_frg, psp_xiza_frg,
        shel_atm_mon, shel_ini_mon,
        atom_x_mon, atom_y_mon, atom_z_mon,
        leading_cs_pair_mon,
        csp_schwarz_mon, csp_ics_mon, csp_jcs_mon,
        csp_leading_ps_pair_mon,
        psp_zeta_mon, psp_dkps_mon, psp_xiza_mon,
        D_mon, V_frg );
  } else {
    if (idev==1)
    cuda_ifc4c_calc_a[Labcd](
        pnworkers, pworkerid,
        pLa, pLb, pLc, pLd,
        shel_atm_frg, shel_ini_frg,
        atom_x_frg, atom_y_frg, atom_z_frg,
        leading_cs_pair_frg,
        csp_schwarz_frg, csp_ics_frg, csp_jcs_frg,
        csp_leading_ps_pair_frg,
        psp_zeta_frg, psp_dkps_frg, psp_xiza_frg,
        shel_atm_mon, shel_ini_mon,
        atom_x_mon, atom_y_mon, atom_z_mon,
        leading_cs_pair_mon,
        csp_schwarz_mon, csp_ics_mon, csp_jcs_mon,
        csp_leading_ps_pair_mon,
        psp_zeta_mon, psp_dkps_mon, psp_xiza_mon,
        D_mon, V_frg );
#ifndef CUDA_IFC4C_BENCH
  }
#else
    checkCudaErrors(cudaDeviceSynchronize());
  }
#pragma omp barrier
#pragma omp master
  {
  w1 = cuda_Wtime();
  if (wifc4c[Labcd]<0) wifc4c[Labcd] = 0.0;
  wifc4c[Labcd] += w1-w0;
  }
#endif /* CUDA_IFC4C_BENCH */

  return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif
#include "ofmo-def.h"
#ifdef __cplusplus
}
#endif

#include "cudalib.h"
#include "cuda-twoint-core.h"
#include "cuda-twoint-core-os.h"
#include "cuda-utils.h"
#ifdef CUDA_FMT_M
#include "cuda-fmt-m.h"
#endif

#ifndef ZERO
#define ZERO    0.e0
#endif
#ifndef ONE
#define ONE     1.e0
#endif
#ifndef TWO
#define TWO     2.e0
#endif
#ifndef HALF
#define HALF    0.5e0
#endif

//#define EPS_ERI 1.e-15
//#define EPS_PS4 1.e-30
//#if CUDA_ARCH >= 350
#if defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 350
/*
#define NREGS_064 __launch_bounds__(256,4)
#define NREGS_128 __launch_bounds__(256,2)
#define NREGS_255 __launch_bounds__(256,1)
*/
#define NREGS_0 __launch_bounds__(256)
#define NREGS_1 __launch_bounds__(256,1)
#define NREGS_2 __launch_bounds__(256,2)
#define NREGS_3 __launch_bounds__(256,3)
#define NREGS_4 __launch_bounds__(256,4)
#else
#define NREGS_0
#define NREGS_1
#define NREGS_2
#define NREGS_3
#define NREGS_4
#endif

/* ------------------------------------- */

//#define gpu_dmax2(k, l) LDG(Dcs[(k)*ncs+(l)])
__device__ inline float gpu_dmax2(const int k, const int l)
{
    return (2 * LDG(Dcs[k*ncs_mon+l]));
};

/* ------------------------------------- */
#ifdef SORT_IJ_SCHWARZ
#define CNV_CSP(a) sorted_csp[(a)]
#else
#define CNV_CSP(a) (a)
#endif

// nwks, iwk: wk=dev
__global__ void
NREGS_4
gpu_ifc4c_os_ssss( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  int tsize=0;
//  __shared__ double sV[nthb];
  volatile double *sV=&shared[tsize]; // sV
  tsize+=nthb;
//  double V[1];
//  double V;
  const int La=0, Lb=0, Lc=0, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    //double SSSS[1];
    double *SSSS = &shared[tsize+tidx]; // SSSS
    tsize+=nthb;

    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao    = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
	//IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
        sV[tidx]=ZERO;
        //V[0]=ZERO;
        //V=ZERO;
#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//#pragma omp for schedule(guided)
//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif
            int kcs, kat, kao, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao    = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_ssss_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      SSSS );
	    double coe = (kao==lao? ONE : TWO );
	    int KL    = ((kao*kao+kao)>>1) + lao;
	    if ( fabs(SSSS[0]) > eps_eri ) {
//		V_frg[IJ] += coe * D_mon[KL] * SSSS[0];
		//V[0] += coe * LDG(D_mon[KL]) * SSSS[0];
		//V += coe * LDG(D_mon[KL]) * SSSS[0];
		sV[tidx] += coe * LDG(D_mon[KL]) * SSSS[0];
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
	int IJ     = ((iao*iao+iao)>>1) + jao;
        //sV[tidx]=V[0];
        //sV[tidx]=V;
        warpReduce(&sV[widx*WARP_SIZE], tidw);
//        if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
        __syncthreads();
        if (widx==0) { // assume nwrp <= WARP_SIZE
          if (tidx<nwrp) sV[tidx]=sV[tidx*WARP_SIZE];
          else sV[tidx]=ZERO;
          warpReduce(sV, tidx);
          if (tidx==0) V_frg[IJ]+=sV[0];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ssss_


/** (ss,ps)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_4
gpu_ifc4c_os_ssps( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=0, Lb=0, Lc=1, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double SSPS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table1;
  for (int i=tidx; i<FMT_m_size[1]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[1];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  //double V;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao    = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
	//V=ZERO;
#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_psss_(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      SSPS );
            double V=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++ ) {
		int KL = ((kao*kao+kao)>>1) + lao;
		if ( fabs(SSPS[k]) > eps_eri ) {
//		    V_frg[IJ] += TWO * D_mon[KL] * SSPS[k];
		    V += TWO * LDG(D_mon[KL]) * SSPS[k];
		    //sV[tidx] += TWO * D_mon[KL] * SSPS[k];
		}
	    }
            sV[tidx] += V;
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
	int IJ     = ((iao*iao+iao)>>1) + jao;
        //sV[tidx]=V[0];
        //sV[tidx]=V;
        warpReduce(&sV[widx*WARP_SIZE], tidw);
//        if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
        __syncthreads();
        if (widx==0) { // assume nwrp <= WARP_SIZE
          if (tidx<nwrp) sV[tidx]=sV[tidx*WARP_SIZE];
          else sV[tidx]=ZERO;
          warpReduce(sV, tidx);
          if (tidx==0) V_frg[IJ]+=sV[0];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ssps_


/** (ss,pp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_3
gpu_ifc4c_os_sspp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=0, Lb=0, Lc=1, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double SSPP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table2;
  for (int i=tidx; i<FMT_m_size[2]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[2];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  //double V;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao    = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
	//V=ZERO;
#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_ppss_(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      SSPP );
            double V=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int K2 = (kao*kao+kao)>>1;
#pragma unroll
		for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++, ix++ ) {
		    if ( lao>kao ) continue;
		    int KL = K2 + lao;
		    double coe = (kao==lao? ONE : TWO );
		    if ( fabs(SSPP[ix]) > eps_eri ) {
			//V_frg[IJ] += coe * D_mon[KL] * SSPP[ix];
			V += coe * LDG(D_mon[KL]) * SSPP[ix];
			//sV[tidx] += coe * D_mon[KL] * SSPP[ix];
		    }
		}
	    }
            sV[tidx] += V;
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
	int IJ     = ((iao*iao+iao)>>1) + jao;
        //sV[tidx]=V[0];
        //sV[tidx]=V;
        warpReduce(&sV[widx*WARP_SIZE], tidw);
//        if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
        __syncthreads();
        if (widx==0) { // assume nwrp <= WARP_SIZE
          if (tidx<nwrp) sV[tidx]=sV[tidx*WARP_SIZE];
          else sV[tidx]=ZERO;
          warpReduce(sV, tidx);
          if (tidx==0) V_frg[IJ]+=sV[0];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_sspp_


/** (ss,ds)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_3
gpu_ifc4c_os_ssds( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=0, Lb=0, Lc=2, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double SSDS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table2;
  for (int i=tidx; i<FMT_m_size[2]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[2];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  //double V;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao    = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
	//V=ZERO;
#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dsss(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      SSDS );
            double V=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++ ) {
		int KL = ((kao*kao+kao)>>1) + lao;
		if ( fabs(SSDS[k]) > eps_eri ) {
//		    V_frg[IJ] += TWO * D_mon[KL] * SSDS[k];
		    V += TWO * LDG(D_mon[KL]) * SSDS[k];
		    //sV[tidx] += TWO * D_mon[KL] * SSDS[k];
		}
	    }
            sV[tidx] += V;
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
	int IJ     = ((iao*iao+iao)>>1) + jao;
        //sV[tidx]=V[0];
        //sV[tidx]=V;
        warpReduce(&sV[widx*WARP_SIZE], tidw);
//        if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
        __syncthreads();
        if (widx==0) { // assume nwrp <= WARP_SIZE
          if (tidx<nwrp) sV[tidx]=sV[tidx*WARP_SIZE];
          else sV[tidx]=ZERO;
          warpReduce(sV, tidx);
          if (tidx==0) V_frg[IJ]+=sV[0];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ssds_


/** (ss,dp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_2
gpu_ifc4c_os_ssdp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=0, Lb=0, Lc=2, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double SSDP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table3;
  for (int i=tidx; i<FMT_m_size[3]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[3];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  //double V;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao    = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
	//V=ZERO;
#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpss(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      SSDP );
            double V=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int K2 = (kao*kao+kao)>>1;
#pragma unroll
		for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++, ix++ ) {
		    int KL = K2 + lao;
		    if ( fabs(SSDP[ix]) > eps_eri ) {
			//V_frg[IJ] += TWO * D_mon[KL] * SSDP[ix];
			V += TWO * LDG(D_mon[KL]) * SSDP[ix];
		    }
		}
	    }
            sV[tidx] += V;
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
	int IJ     = ((iao*iao+iao)>>1) + jao;
        //sV[tidx]=V[0];
        //sV[tidx]=V;
        warpReduce(&sV[widx*WARP_SIZE], tidw);
//        if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
        __syncthreads();
        if (widx==0) { // assume nwrp <= WARP_SIZE
          if (tidx<nwrp) sV[tidx]=sV[tidx*WARP_SIZE];
          else sV[tidx]=ZERO;
          warpReduce(sV, tidx);
          if (tidx==0) V_frg[IJ]+=sV[0];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ssdp_


/** (ss,dd)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_3
gpu_ifc4c_os_ssdd( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=0, Lb=0, Lc=2, Ld=2;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double SSDD[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  //double V;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao    = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
	//V=ZERO;
#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_ddss(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      SSDD );
            double V=ZERO;
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int K2 = (kao*kao+kao)>>1;
#pragma unroll
		for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++, ix++ ) {
		    if ( lao>kao ) continue;
		    int KL = K2 + lao;
		    double coe = (kao==lao? ONE : TWO );
		    if ( fabs(SSDD[ix]) > eps_eri ) {
			//V_frg[IJ] += coe * D_mon[KL] * SSDD[ix];
			V += coe * LDG(D_mon[KL]) * SSDD[ix];
		    }
		}
	    }
            sV[tidx] += V;
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
	int IJ     = ((iao*iao+iao)>>1) + jao;
        //sV[tidx]=V[0];
        //sV[tidx]=V;
        warpReduce(&sV[widx*WARP_SIZE], tidw);
//        if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
        __syncthreads();
        if (widx==0) { // assume nwrp <= WARP_SIZE
          if (tidx<nwrp) sV[tidx]=sV[tidx*WARP_SIZE];
          else sV[tidx]=ZERO;
          warpReduce(sV, tidx);
          if (tidx==0) V_frg[IJ]+=sV[0];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ssdd_


/** (ps,ss)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_4
gpu_ifc4c_os_psss( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=0, Lc=0, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PSSS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table1;
  for (int i=tidx; i<FMT_m_size[1]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[1];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[3];
  volatile double *sVw=&shared[tsize];
  tsize+=nwrp*3;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	//sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<3; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao    = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_psss_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      PSSS );
	    double coe = (kao==lao? ONE : TWO );
            int KL = ((kao*kao+kao)>>1) + lao;
#pragma unroll
	    for (int i=0; i<3; i++) {
		if ( fabs(PSSS[i]) > eps_eri ) {
		    V[i] += coe * LDG(D_mon[KL]) * PSSS[i];
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<3; i++) {
          sV[tidx]=V[i];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
            int iao = iao0 + i;
            //int IJ     = ((iao*iao+iao)>>1) + jao;
            //      if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
          if (tidw==0) sVw[i*nwrp+widx] = sV[tidx];
        }
        __syncthreads();
        for (int i=widx; i<3; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<3) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_psss_


/** (ps,ps)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_3
gpu_ifc4c_os_psps( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=0, Lc=1, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PSPS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table2;
  for (int i=tidx; i<FMT_m_size[2]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[2];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  volatile double *sVw=&shared[tsize];
  tsize+=nwrp*Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_psps_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      PSPS );
#pragma unroll
	    for (int i=0,ix=0; i<NNAO(La); i++) {
#pragma unroll
		for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++, ix++ ) {
		    int KL = ((kao*kao+kao)>>1) + lao;
		    if ( fabs(PSPS[ix]) > eps_eri ) {
			V[i] += TWO * LDG(D_mon[KL]) * PSPS[ix];
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          sV[tidx]=V[i];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
            int iao = iao0 + i;
            //int IJ     = ((iao*iao+iao)>>1) + jao;
            //      if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
          if (tidw==0) sVw[i*nwrp+widx] = sV[tidx];
        }
        __syncthreads();
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_psps_


/** (ps,pp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_2
gpu_ifc4c_os_pspp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=0, Lc=1, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PSPP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table3;
  for (int i=tidx; i<FMT_m_size[3]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[3];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  volatile double *sVw=&shared[tsize];
  tsize+=nwrp*Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_ppps_(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PSPP );
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int K2 = (kao*kao+kao)>>1;
#pragma unroll
		for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++ ) {
		    if ( lao>kao ) { ix+=NNAO(La); continue; }
		    int KL = K2 + lao;
		    double coe = (kao==lao? ONE : TWO );
#pragma unroll
		    for (int i=0; i<NNAO(La); i++, ix++ ) {
			if ( fabs(PSPP[ix]) > eps_eri ) {
			    //V_frg[IJ] += coe * D_mon[KL] * PSPP[ix];
			    V[i] += coe * LDG(D_mon[KL]) * PSPP[ix];
			}
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          sV[tidx]=V[i];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
            int iao = iao0 + i;
            //int IJ     = ((iao*iao+iao)>>1) + jao;
            //      if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
          if (tidw==0) sVw[i*nwrp+widx] = sV[tidx];
        }
        __syncthreads();
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_pspp_


/** (ps,ds)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_2
gpu_ifc4c_os_psds( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=0, Lc=2, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PSDS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table3;
  for (int i=tidx; i<FMT_m_size[3]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[3];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  volatile double *sVw=&shared[tsize];
  tsize+=nwrp*Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dsps(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PSDS );
#pragma unroll
            for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
              int KL = ((kao*kao+kao)>>1) + lao;
#pragma unroll
              for (int i=0; i<NNAO(La); i++, ix++) {
		    if ( fabs(PSDS[ix]) > eps_eri ) {
			V[i] += TWO * LDG(D_mon[KL]) * PSDS[ix];
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          sV[tidx]=V[i];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
            int iao = iao0 + i;
            //int IJ     = ((iao*iao+iao)>>1) + jao;
            //      if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
          if (tidw==0) sVw[i*nwrp+widx] = sV[tidx];
        }
        __syncthreads();
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_psds_


/** (ps,dp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_psdp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=0, Lc=2, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PSDP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  volatile double *sVw=&shared[tsize];
  tsize+=nwrp*Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpps(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PSDP );
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int K2 = (kao*kao+kao)>>1;
#pragma unroll
		for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++ ) {
		    int KL = K2 + lao;
#pragma unroll
		    for (int i=0, iao=iao0; i<NNAO(La); i++, iao++, ix++ ) {
//			IJ = ((iao*iao+iao)>>1) + jao;
			if ( fabs(PSDP[ix]) > eps_eri ) {
//			    V_frg[IJ] += TWO * D_mon[KL] * PSDP[ix];
			V[i] += TWO * LDG(D_mon[KL]) * PSDP[ix];
			}
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          sV[tidx]=V[i];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
            int iao = iao0 + i;
            //int IJ     = ((iao*iao+iao)>>1) + jao;
            //      if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
          if (tidw==0) sVw[i*nwrp+widx] = sV[tidx];
        }
        __syncthreads();
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_psdp_


#if 0
/** (ps,dd)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_psdd(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, k, l, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], CA[3];
    double val_ab, val_cd, coe;
    double PSDD[3*6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddps( &La, &Lb, &Lc, &Ld,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PSDD );
	    for ( k=0, kao=kao0, ix=0; k<6; k++, kao++ ) {
		K2 = (kao*kao+kao)>>1;
		for ( l=0, lao=lao0; l<6; l++, lao++ ) {
		    if ( lao>kao ) { ix+=3; continue; }
		    KL = K2 + lao;
		    coe = (kao==lao? ONE : TWO );
		    for ( i=0, iao=iao0; i<3; i++, iao++, ix++ ) {
			IJ = ((iao*iao+iao)>>1) + jao;
			if ( fabs(PSDD[ix]) > eps_eri ) {
			    V_frg[IJ] += coe * D_mon[KL] * PSDD[ix];
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_psdd_
#endif // if 0


/** (pp,ss)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_3
gpu_ifc4c_os_ppss( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=1, Lc=0, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PPSS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table2;
  for (int i=tidx; i<FMT_m_size[2]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[2];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao    = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_ppss_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      PPSS );
	    double coe = (kao==lao? ONE : TWO );
            int KL = ((kao*kao+kao)>>1) + lao;
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
//		int I2 = (iao*iao+iao)>>1;
#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++, ix++ ) {
                  //int ij=i*3+j;
		    if ( jao>iao ) continue;
		    //IJ = I2 + jao;
		    if ( fabs(PPSS[ix]) > eps_eri ) {
		//	V_frg[IJ] += coe * D_mon[KL] * PPSS[ix];
                      V[ix] += coe * LDG(D_mon[KL]) * PPSS[ix];
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ppss_


/** (pp,ps)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_2
gpu_ifc4c_os_ppps( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=1, Lc=1, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PPPS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table3;
  for (int i=tidx; i<FMT_m_size[3]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[3];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_ppps_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      PPPS );
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
//		int I2 = (iao*iao+iao)>>1;
#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++ ) {
                  int ij=i*3+j;
                  double Vt=ZERO;
		    if ( jao>iao ) { ix+=NNAO(Lc); continue; }
#pragma unroll
		    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++, ix++ ) {
			int KL = ((kao*kao+kao)>>1) + lao;
			if ( fabs(PPPS[ix]) > eps_eri ) {
//			    V_frg[IJ] += TWO * D_mon[KL] * PPPS[ix];
			    //Vt += TWO * D_mon[KL] * PPPS[ix];
			    V[ij] += TWO * LDG(D_mon[KL]) * PPPS[ix];
			}
		    }
		  //int IJ = I2 + jao;
                  //atomicAdd(&V_frg[IJ], Vt);
                  //V[ij] += Vt;
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs

#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ppps_


/** (pp,pp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_pppp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=1, Lc=1, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PPPP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_pppp_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      PPPP );
//#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
		//int I2 = (iao*iao+iao)>>1;
//#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++ ) {
		    if ( jao>iao ) { ix+=Ncd; continue; }
		    //int IJ = I2 + jao;
                    double Vt=ZERO;
#pragma unroll
		    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++ ) {
			int K2 = (kao*kao+kao)>>1;
#pragma unroll
			for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++, ix++ ) {
			    if ( lao>kao ) continue;
			    double coe = (kao==lao? ONE : TWO );
			    int KL = K2 + lao;
			    if ( fabs(PPPP[ix]) > eps_eri ) {
				//V_frg[IJ] += coe * D_mon[KL] * PPPP[ix];
				Vt += coe * LDG(D_mon[KL]) * PPPP[ix];
			    }
			}
		    }
                    int ij = i*NNAO(Lb) + j;
                    V[ij] += Vt;
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_pppp_


/** (pp,ds)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_ppds( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=1, Lb=1, Lc=2, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double PPDS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dspp(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PPDS );
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int KL = ((kao*kao+kao)>>1) + lao;
#pragma unroll
		for (int i=0, iao=iao0; i<NNAO(La); i++, iao++ ) {
		    //int I2 = (iao*iao+iao)>>1;
#pragma unroll
		    for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++, ix++ ) {
			if ( jao>iao ) continue;
			//int IJ = I2 + jao;
			if ( fabs(PPDS[ix]) > eps_eri ) {
			    //V_frg[IJ] += TWO * D_mon[KL] * PPDS[ix];
                            int ij = i*NNAO(Lb) + j;
			    V[ij] += TWO * LDG(D_mon[KL]) * PPDS[ix];
			}
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_ppds_

#if 0

/** (pp,dp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_ppdp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, l, I2, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], CA[3];
    double val_ab, val_cd;
    double PPDP[3*3*6*3];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_dppp( &La, &Lb, &Lc, &Ld,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PPDP );
	    for ( k=0, kao=kao0, ix=0; k<6; k++, kao++ ) {
		K2 = (kao*kao+kao)>>1;
		for ( l=0, lao=lao0; l<3; l++, lao++ ) {
		    KL = K2 + lao;
		    for ( i=0, iao=iao0; i<3; i++, iao++ ) {
			I2 = (iao*iao+iao)>>1;
			for ( j=0, jao=jao0; j<3; j++, jao++, ix++ ) {
			    if ( jao>iao ) continue;
			    IJ = I2 + jao;
			    if ( fabs(PPDP[ix]) > eps_eri ) {
				V_frg[IJ] += TWO * D_mon[KL] * PPDP[ix];
			    }
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_ppdp_


/** (pp,dd)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_ppdd(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, l, I2, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], CA[3];
    double val_ab, val_cd, coe;
    double PPDD[3*3*6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddpp( &La, &Lb, &Lc, &Ld,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      PPDD );
	    for ( k=0, kao=kao0, ix=0; k<6; k++, kao++ ) {
		K2 = (kao*kao+kao)>>1;
		for ( l=0, lao=lao0; l<6; l++, lao++ ) {
		    if ( lao>kao ) { ix+=3*3; continue; }
		    KL = K2 + lao;
		    coe = (kao==lao? ONE : TWO );
		    for ( i=0, iao=iao0; i<3; i++, iao++ ) {
			I2 = (iao*iao+iao)>>1;
			for ( j=0, jao=jao0; j<3; j++, jao++, ix++ ) {
			    if ( jao>iao ) continue;
			    IJ = I2 + jao;
			    if ( fabs(PPDD[ix]) > eps_eri ) {
				V_frg[IJ] += coe * D_mon[KL] * PPDD[ix];
			    }
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_ppdd_
#endif /* if 0 */


/** (ds,ss)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_3
gpu_ifc4c_os_dsss( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=0, Lc=0, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DSSS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table2;
  for (int i=tidx; i<FMT_m_size[2]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[2];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  volatile double *sVw=&shared[tsize];
  tsize+=nwrp*Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao    = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_dsss_(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DSSS );
	    double coe = (kao==lao? ONE : TWO );
            int KL = ((kao*kao+kao)>>1) + lao;
#pragma unroll
	    for (int i=0; i<Nab; i++) {
		if ( fabs(DSSS[i]) > eps_eri ) {
		    V[i] += coe * D_mon[KL] * DSSS[i];
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          sV[tidx]=V[i];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
            int iao = iao0 + i;
            //int IJ     = ((iao*iao+iao)>>1) + jao;
            //      if (tidw==0) atomicAdd(&V_frg[IJ], sV[tidx]);
          if (tidw==0) sVw[i*nwrp+widx] = sV[tidx];
        }
        __syncthreads();
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dsss_


/** (ds,ps)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_2
gpu_ifc4c_os_dsps( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=0, Lc=1, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DSPS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table3;
  for (int i=tidx; i<FMT_m_size[3]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[3];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
//  volatile double *sVw=&shared[tsize];
//  tsize+=nwrp*Nab;
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dsps(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DSPS );
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
//		IJ = ((iao*iao+iao)>>1) + jao;
#pragma unroll
		for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++, ix++ ) {
		    if ( fabs(DSPS[ix]) > eps_eri ) {
                      int KL = ((kao*kao+kao)>>1) + lao;
//			V_frg[IJ] += TWO * D_mon[KL] * DSPS[ix];
			V[i] += TWO * LDG(D_mon[KL]) * DSPS[ix];
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
#if 0
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#endif
        for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i;
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dsps_


/** (ds,pp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_dspp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=0, Lc=1, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DSPP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
//  volatile double *sVw=&shared[tsize];
//  tsize+=nwrp*Nab;
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dspp(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DSPP );
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
#pragma unroll
		for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++ ) {
		    int K2 = (kao*kao+kao)>>1;
#pragma unroll
		    for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++, ix++ ) {
			if ( lao>kao ) continue;
			double coe = (kao==lao? ONE : TWO );
			int KL = K2 + lao;
			if ( fabs(DSPP[ix]) > eps_eri ) {
			    //V_frg[IJ] += coe * D_mon[KL] * DSPP[ix];
                            V[i] += coe * LDG(D_mon[KL]) * DSPP[ix];
			}
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
#if 0
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#endif
        for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i;
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dspp_


/** (ds,ds)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_dsds( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=0, Lc=2, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DSDS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
//  volatile double *sVw=&shared[tsize];
//  tsize+=nwrp*Nab;
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dsds(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DSDS );
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
//		IJ = ((iao*iao+iao)>>1) + jao;
#pragma unroll
		for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++, ix++ ) {
		    if ( fabs(DSDS[ix]) > eps_eri ) {
                      int KL = ((kao*kao+kao)>>1) + lao;
//			V_frg[IJ] += TWO * D_mon[KL] * DSDS[ix];
			V[i] += TWO * LDG(D_mon[KL]) * DSDS[ix];
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
#if 0
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#endif
        for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i;
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dsds_


/** (ds,dp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_dsdp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=0, Lc=2, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao, iao0, jcs, jat, jao;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DSDP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table5;
  for (int i=tidx; i<FMT_m_size[5]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[5];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
//  volatile double *sVw=&shared[tsize];
//  tsize+=nwrp*Nab;
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
//	IJ     = ((iao*iao+iao)>>1) + jao;
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
	sV[tidx]=ZERO;
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], CA[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpds(
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      DSDP );
#pragma unroll
	    for (int k=0, kao=kao0, ix=0; k<NNAO(Lc); k++, kao++ ) {
		int K2 = (kao*kao+kao)>>1;
#pragma unroll
		for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++ ) {
		    int KL = K2 + lao;
#pragma unroll
		    for (int i=0, iao=iao0; i<NNAO(La); i++, iao++, ix++ ) {
			//IJ = ((iao*iao+iao)>>1) + jao;
			if ( fabs(DSDP[ix]) > eps_eri ) {
			    //V_frg[IJ] += TWO * D_mon[KL] * DSDP[ix];
			    V[i] += TWO * LDG(D_mon[KL]) * DSDP[ix];
			}
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
#if 0
        for (int i=widx; i<Nab; i+=nwrp) {
          if (tidw<nwrp) sV[tidx]=sVw[i*nwrp+tidw];
          else sV[tidx]=ZERO;
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          /*
          if (tidw==0) {
            int iao = iao0 + i;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx];
          }
          */
        }
        __syncthreads();
        if (tidx<Nab) {
            int iao = iao0 + tidx;
            int IJ     = ((iao*iao+iao)>>1) + jao;
            V_frg[IJ]+=sV[tidx*WARP_SIZE];
        }
#endif
        for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i;
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dsdp_

#if 0

/** (ds,dd)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_dsdd(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, k, l, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], CA[3];
    double val_ab, val_cd, coe;
    double DSDD[6*6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao    = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddds( &La, &Lb, &Lc, &Ld,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      DSDD );
	    for ( k=0, kao=kao0, ix=0; k<6; k++, kao++ ) {
		K2 = (kao*kao+kao)>>1;
		for ( l=0, lao=lao0; l<6; l++, lao++ ) {
		    if ( lao>kao ) { ix+=6; continue; }
		    KL = K2 + lao;
		    coe = (kao==lao? ONE : TWO );
		    for ( i=0, iao=iao0; i<6; i++, iao++, ix++ ) {
			IJ = ((iao*iao+iao)>>1) + jao;
			if ( fabs(DSDD[ix]) > eps_eri ) {
			    V_frg[IJ] += coe * D_mon[KL] * DSDD[ix];
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_dsdd_
#endif // if 0


/** (dp,ss)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_2
gpu_ifc4c_os_dpss( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=1, Lc=0, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DPSS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table3;
  for (int i=tidx; i<FMT_m_size[3]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[3];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao    = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpss(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DPSS );
	    double coe = (kao==lao? ONE : TWO );
            int KL = ((kao*kao+kao)>>1) + lao;
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++, ix++ ) {
		    if ( fabs(DPSS[ix]) > eps_eri ) {
		//	V_frg[IJ] += coe * D_mon[KL] * DPSS[ix];
                      V[ix] += coe * LDG(D_mon[KL]) * DPSS[ix];
		    }
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dpss_


/** (dp,ps)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_dpps( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=1, Lc=1, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DPPS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table4;
  for (int i=tidx; i<FMT_m_size[4]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[4];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpps(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DPPS );
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
//		int I2 = (iao*iao+iao)>>1;
#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++ ) {
                    double Vt=ZERO;
#pragma unroll
		    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++, ix++ ) {
			int KL = ((kao*kao+kao)>>1) + lao;
			if ( fabs(DPPS[ix]) > eps_eri ) {
//			    V_frg[IJ] += TWO * D_mon[KL] * DPPS[ix];
			    Vt += TWO * LDG(D_mon[KL]) * DPPS[ix];
			    //V[ij] += TWO * D_mon[KL] * DPPS[ix];
			}
		    }
		  //int IJ = I2 + jao;
                  //atomicAdd(&V_frg[IJ], Vt);
                  int ij=i*NNAO(Lb)+j;
                  V[ij] += Vt;
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dpps_


/** (dp,pp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_1
gpu_ifc4c_os_dppp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=1, Lc=1, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DPPP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table5;
  for (int i=tidx; i<FMT_m_size[5]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[5];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dppp(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DPPP );
//#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
		//int I2 = (iao*iao+iao)>>1;
//#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++ ) {
		    //int IJ = I2 + jao;
                    double Vt=ZERO;
#pragma unroll
		    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++ ) {
			int K2 = (kao*kao+kao)>>1;
#pragma unroll
			for (int l=0, lao=lao0; l<NNAO(Ld); l++, lao++, ix++ ) {
			    if ( lao>kao ) continue;
			    double coe = (kao==lao? ONE : TWO );
			    int KL = K2 + lao;
			    if ( fabs(DPPP[ix]) > eps_eri ) {
				//V_frg[IJ] += coe * D_mon[KL] * DPPP[ix];
				Vt += coe * LDG(D_mon[KL]) * DPPP[ix];
			    }
			}
		    }
                    int ij=i*NNAO(Lb)+j;
                    V[ij] += Vt;
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dppp_


/** (dp,ds)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_0
gpu_ifc4c_os_dpds( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=1, Lc=2, Ld=0;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DPDS[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table5;
  for (int i=tidx; i<FMT_m_size[5]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[5];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao    = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpds(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DPDS );
#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
//		int I2 = (iao*iao+iao)>>1;
#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++ ) {
		    //int IJ = I2 + jao;
                    double Vt=ZERO;
#pragma unroll
		    for (int k=0, kao=kao0; k<NNAO(Lc); k++, kao++, ix++ ) {
			int KL = ((kao*kao+kao)>>1) + lao;
			if ( fabs(DPDS[ix]) > eps_eri ) {
			    //V_frg[IJ] += TWO * D_mon[KL] * DPDS[ix];
			    Vt += TWO * LDG(D_mon[KL]) * DPDS[ix];
			}
		    }
		  //int IJ = I2 + jao;
                  //atomicAdd(&V_frg[IJ], Vt);
                  int ij=i*NNAO(Lb)+j;
                  V[ij] += Vt;
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dpds_


/** (dp,dp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
__global__ void
NREGS_0
gpu_ifc4c_os_dpdp( const int nwks, const int iwk,
    const float eps_eri, const float eps_ps4, const float eps_sch )
{
  int tidx = threadIdx.x + threadIdx.y * blockDim.x;
  int nthb = blockDim.x * blockDim.y;
  int bidx = blockIdx.x;
  int nblk = gridDim.x;
  int widx = threadIdx.y;
  int tidw = threadIdx.x;
  int nwrp = blockDim.y;
  int nwkblk = nwks * nblk;
//  int iwkblk = iwk * nblk + bidx;
  int iwkblk = bidx * nwks + iwk;
  const int La=2, Lb=1, Lc=2, Ld=1;
//    int Lab, Lcd, IJ, KL;
    int Lab, Lcd;
    int ijcs0, ijcs1;
    int klcs0, klcs1;
//    int ijps0, nijps, klps0, nklps;
    int ijps0, nijps;
    int ics, iat, iao0, jcs, jat, jao0;
//    int kcs, kat, kao, kao0, lcs, lat, lao;
//    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double A[3], B[3], BA[3];
    //double val_ab, val_cd, coe;
    const int Nab=NNAO(La)*NNAO(Lb);
    const int Ncd=NNAO(Lc)*NNAO(Ld);
    double DPDP[Nab*Ncd];

  int tsize=0;
#ifdef CUDA_FMT_M_SM
  double *tbl = FMT_m_table6;
  for (int i=tidx; i<FMT_m_size[6]; i+=nthb) shared[tsize+i] = tbl[i];
  tsize += FMT_m_size[6];
  __syncthreads();
#endif
  volatile double *sV=&shared[tsize];
  tsize+=nthb;
  double V[Nab];
  double *sVw=&shared[tsize];
  tsize+=Nab;
    //int ixx, ncsp, dx, res, pos;
    int *sklcs = sklcs_b + bidx * max_num_klcs;
    __shared__ int nklcs;
#ifdef DLB_KL
    volatile int *klcsw = (int *)&shared[tsize];
    tsize += nwrp;
    __shared__ int cklcs;
#endif

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
//    ijcs0 = leading_cs_pair_frg[Lab] + iwkblk;
    ijcs0 = leading_cs_pair_frg[Lab];
    ijcs1 = leading_cs_pair_frg[Lab+1];
    //ixx   = nwkblk;
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
#ifdef GPU_DLB
    int Labcd=Lab*6+Lcd;
    int *p_ijcounter = &ijcounter[Labcd];
    __shared__ int ijcsw;
    if (tidx==0) ijcsw = ijcs0+iwk + nwks*bidx;
#ifdef DLB_KL
    if (tidx==0) cklcs=nthb;
#endif
    for (int i=tidx; i<Nab; i+=nthb ) sVw[i] = ZERO;
    __syncthreads();
//    int ijcs = ijcsw;
    while(ijcsw<ijcs1) {
#else // !GPU_DLB
//    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
    for (int ijcsw=ijcs0+iwkblk; ijcsw<ijcs1; ijcsw+=nwkblk ) {
#endif // GPU_DLB
      int ijcs = CNV_CSP(ijcsw);
	float val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
#pragma unroll
	for (int i=0; i<3; i++ ) BA[i] = B[i] - A[i];
#pragma unroll
	for (int i=0; i<Nab; i++ ) V[i] = ZERO;

#ifndef USE_INSTANT_SCHWARZ
        {
          if(tidx==0) nklcs=0;
          __syncthreads();
	  for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
            int iklcs = atomicAdd(&nklcs, 1);
            sklcs[iklcs] = klcs;
          }
          __threadfence_block();
          __syncthreads();
        }
#endif /* USE_INSTANT_SCHWARZ */

//	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
#ifdef USE_INSTANT_SCHWARZ
	for (int klcs=klcs0+tidx; klcs<klcs1; klcs+=nthb ) {
	    float val = val_ab * csp_schwarz_mon[klcs];
	    if ( val < eps_ps4 ) continue;
            val *= gpu_dmax2(csp_ics_mon[klcs], csp_jcs_mon[klcs]);
	    if ( val < eps_sch ) continue;
#else
#ifndef DLB_KL
	for (int iklcs=tidx; iklcs<nklcs; iklcs+=nthb ) {
#else
        int iklcs=tidx;
        while (iklcs<nklcs) {
#endif
            int klcs = sklcs[iklcs];
#endif /* USE_INSTANT_SCHWARZ */
            int kcs, kat, kao0, lcs, lat, lao0;
            int klps0, nklps;
	    kcs    = LDG(csp_ics_mon[klcs]);
	    lcs    = LDG(csp_jcs_mon[klcs]);
	    klps0  = LDG(csp_leading_ps_pair_mon[klcs]);
	    nklps  = LDG(csp_leading_ps_pair_mon[klcs+1])-klps0;
	    kat    = LDG(shel_atm_mon[kcs]);
	    lat    = LDG(shel_atm_mon[lcs]);
	    kao0   = LDG(shel_ini_mon[kcs]);
	    lao0   = LDG(shel_ini_mon[lcs]);
            double C[3], D[3], DC[3], AC[3];
	    C[0]=LDG(atom_x_mon[kat]); C[1]=LDG(atom_y_mon[kat]); C[2]=LDG(atom_z_mon[kat]);
	    D[0]=LDG(atom_x_mon[lat]); D[1]=LDG(atom_y_mon[lat]); D[2]=LDG(atom_z_mon[lat]);
#pragma unroll
	    for (int i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    gpu_twoint_core_os_dpdp(
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DPDP );
//#pragma unroll
	    for (int i=0, iao=iao0, ix=0; i<NNAO(La); i++, iao++ ) {
		//int I2 = (iao*iao+iao)>>1;
//#pragma unroll
		for (int j=0, jao=jao0; j<NNAO(Lb); j++, jao++ ) {
		    //int IJ = I2 + jao;
                    double Vt=ZERO;
#pragma unroll
		    for (int k=0, kao=kao0; k<6; k++, kao++ ) {
			int K2 = (kao*kao+kao)>>1;
#pragma unroll
			for (int l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    int KL = K2 + lao;
			    if ( fabs(DPDP[ix]) > eps_eri ) {
				//V_frg[IJ] += TWO * D_mon[KL] * DPDP[ix];
				Vt += TWO * LDG(D_mon[KL]) * DPDP[ix];
			    }
			}
		    }
		    int ij = i*NNAO(Lb)+j;
                    V[ij] += Vt;
		}
	    }
#ifdef DLB_KL
            if (tidw==0) klcsw[widx] = atomicAdd(&cklcs, warpSize);
            iklcs = klcsw[widx]+tidw;
#endif
	}	// klcs
#pragma unroll
        for (int i=0; i<Nab; i++) {
          int it = (i+widx)%Nab;
          sV[tidx]=V[it];
          warpReduce(&sV[widx*WARP_SIZE], tidw);
          if (tidw==0) atomicAdd(&sVw[it], sV[tidx]);
        }
        __syncthreads();
	for (int i=tidx; i<Nab; i+=nthb ) {
          int iao = iao0 + i/NNAO(Lb);
          int jao = jao0 + i%NNAO(Lb);
          int IJ     = ((iao*iao+iao)>>1) + jao;
          V_frg[IJ]+=sVw[i];
          sVw[i] = ZERO;
        }
#ifdef GPU_DLB
        if (tidx==0) {
          ijcsw = ijcs0+iwk + atomicAdd(p_ijcounter, 1)*nwks;
        }
#ifdef DLB_KL
        if (tidx==0) cklcs=nthb;
#endif
//        ijcs = CNV_CSP(ijcsw);
#endif // GPU_DLB
        __syncthreads();
    }		// ijcs
    return;
}	// end of ofmo_ifc4c_dpdp_


#if 0
/** (dp,dd)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_dpdd(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, l, I2, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], CA[3];
    double val_ab, val_cd, coe;
    double DPDD[6*3*6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		CA[i] = C[i] - A[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_dddp( &La, &Lb, &Lc, &Ld,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,   CA,      DPDD );
	    for ( k=0, kao=kao0, ix=0; k<6; k++, kao++ ) {
		K2 = (kao*kao+kao)>>1;
		for ( l=0, lao=lao0; l<6; l++, lao++ ) {
		    if ( lao>kao ) { ix+=6*3; continue; }
		    KL = K2 + lao;
		    coe = (kao==lao? ONE : TWO );
		    for ( i=0, iao=iao0; i<6; i++, iao++ ) {
			I2 = (iao*iao+iao)>>1;
			for ( j=0, jao=jao0; j<3; j++, jao++, ix++ ) {
			    IJ = I2 + jao;
			    if ( fabs(DPDD[ix]) > eps_eri ) {
				V_frg[IJ] += coe * D_mon[KL] * DPDD[ix];
			    }
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_dpdd_


/** (dd,ss)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_ddss(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, I2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DDSS[6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao    = shel_ini_mon[kcs];
	    lao    = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    KL    = ((kao*kao+kao)>>1) + lao;
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddss( &La, &Lb, &Lc, &Ld,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DDSS );
	    coe = (kao==lao? ONE : TWO );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++, ix++ ) {
		    if ( jao>iao ) continue;
		    IJ = I2 + jao;
		    if ( fabs(DDSS[ix]) > eps_eri ) {
			V_frg[IJ] += coe * D_mon[KL] * DDSS[ix];
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_ddss_


/** (dd,ps)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_ddps(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, I2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd;
    double DDPS[6*6*3];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao    = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddps( &La, &Lb, &Lc, &Ld,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DDPS );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=3; continue; }
		    IJ = I2 + jao;
		    for ( k=0, kao=kao0; k<3; k++, kao++, ix++ ) {
			KL = ((kao*kao+kao)>>1) + lao;
			if ( fabs(DDPS[ix]) > eps_eri ) {
			    V_frg[IJ] += TWO * D_mon[KL] * DDPS[ix];
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_ddps_


/** (dd,pp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_ddpp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, l, I2, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DDPP[6*6*3*3];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddpp( &La, &Lb, &Lc, &Ld,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DDPP );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=3*3; continue; }
		    IJ = I2 + jao;
		    for ( k=0, kao=kao0; k<3; k++, kao++ ) {
			K2 = (kao*kao+kao)>>1;
			for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    if ( lao>kao ) continue;
			    coe = (kao==lao? ONE : TWO );
			    KL = K2 + lao;
			    if ( fabs(DDPP[ix]) > eps_eri ) {
				V_frg[IJ] += coe * D_mon[KL] * DDPP[ix];
			    }
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_ddpp_


/** (dd,ds)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_ddds(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, I2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd;
    double DDDS[6*6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao    = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_ddds( &La, &Lb, &Lc, &Ld,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DDDS );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=6; continue; }
		    IJ = I2 + jao;
		    for ( k=0, kao=kao0; k<6; k++, kao++, ix++ ) {
			KL = ((kao*kao+kao)>>1) + lao;
			if ( fabs(DDDS[ix]) > eps_eri ) {
			    V_frg[IJ] += TWO * D_mon[KL] * DDDS[ix];
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_ddds_


/** (dd,dp)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_dddp(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, l, I2, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd;
    double DDDP[6*6*6*3];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_dddp( &La, &Lb, &Lc, &Ld,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DDDP );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=6*3; continue; }
		    IJ = I2 + jao;
		    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
			K2 = (kao*kao+kao)>>1;
			for ( l=0, lao=lao0; l<3; l++, lao++, ix++ ) {
			    KL = K2 + lao;
			    if ( fabs(DDDP[ix]) > eps_eri ) {
				V_frg[IJ] += TWO * D_mon[KL] * DDDP[ix];
			    }
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_dddp_


/** (dd,dd)タイプの４中心クーロンポテンシャル項をまとめて計算する
 * @ingroup integ-ifc4c
 * */
int ofmo_ifc4c_os_dddd(
	// parallelization
	const int *pnworkers, const int *pworkerid,
	// integral type data
	const int *pLa, const int *pLb, const int *pLc, const int *pLd,
	// basis and cutoff table data for fragment
	const int shel_atm_frg[], const int shel_ini_frg[],
	const double atom_x_frg[], const double atom_y_frg[],
	const double atom_z_frg[], const int leading_cs_pair_frg[],
	const double csp_schwarz_frg[],
	const int csp_ics_frg[], const int csp_jcs_frg[],
	const int csp_leading_ps_pair_frg[],
	const double psp_zeta_frg[], const double psp_dkps_frg[],
	const double psp_xiza_frg[],
	// basis and cutoff table data for monomer
	const int shel_atm_mon[], const int shel_ini_mon[],
	const double atom_x_mon[], const double atom_y_mon[],
	const double atom_z_mon[],
	const int leading_cs_pair_mon[],
	const double csp_schwarz_mon[],
	const int csp_ics_mon[], const int csp_jcs_mon[],
	const int csp_leading_ps_pair_mon[],
	const double psp_zeta_mon[], const double psp_dkps_mon[],
	const double psp_xiza_mon[],
	// density matrix of monomer
	const double D_mon[],
	// (output) Coulomb potential
	double V_frg[] ) {
	    int nworkers=*pnworkers, workerid=*pworkerid;
	    int La=*pLa, Lb=*pLb, Lc=*pLc, Ld=*pLd;
    int Lab, Lcd, IJ, KL, i, j, k, l, I2, K2, ix;
    int ijcs, ijcs0, ijcs1;
    int klcs, klcs0, klcs1;
    int ijps0, nijps, klps0, nklps;
    int ics, iat, iao, iao0, jcs, jat, jao, jao0;
    int kcs, kat, kao, kao0, lcs, lat, lao, lao0;
    double A[3], B[3], C[3], D[3], BA[3], DC[3], AC[3];
    double val_ab, val_cd, coe;
    double DDDD[6*6*6*6];
    //
    int ixx, ncsp, dx, res, pos;
    float eps_eri = ofmo_twoint_eps_eri(0);
    float eps_ps4 = ofmo_twoint_eps_ps4(0);
    float eps_sch = ofmo_twoint_eps_sch(0);

    Lab = La * (La+1)/2 + Lb;
    Lcd = Lc * (Lc+1)/2 + Ld;
    if ( nworkers < 0 ) {
	pos   = workerid;
	ncsp  = leading_cs_pair_frg[Lab+1] - leading_cs_pair_frg[Lab];
	dx    = (ncsp>>7);	// >>5 means /32
	res   = (ncsp & 0x007f);// residues in division by 32
	ijcs0 = leading_cs_pair_frg[Lab]
	    + (pos<res ? pos*(dx+1) : pos*dx+res );
	ijcs1 = ijcs0 + ( pos<res ? dx+1 : dx );
	ixx   = 1;
    } else {
	ijcs0 = leading_cs_pair_frg[Lab] + workerid;
	ijcs1 = leading_cs_pair_frg[Lab+1];
	ixx   = nworkers;
    }
    klcs0 = leading_cs_pair_mon[Lcd];
    klcs1 = leading_cs_pair_mon[Lcd+1];
    for ( ijcs=ijcs0; ijcs<ijcs1; ijcs+=ixx ) {
	val_ab = csp_schwarz_frg[ijcs];
	ics    = csp_ics_frg[ijcs];
	jcs    = csp_jcs_frg[ijcs];
	ijps0  = csp_leading_ps_pair_frg[ijcs];
	nijps  = csp_leading_ps_pair_frg[ijcs+1]-ijps0;
	iat    = shel_atm_frg[ics];
	jat    = shel_atm_frg[jcs];
	iao0   = shel_ini_frg[ics];
	jao0   = shel_ini_frg[jcs];
	A[0]=atom_x_frg[iat]; A[1]=atom_y_frg[iat]; A[2]=atom_z_frg[iat];
	B[0]=atom_x_frg[jat]; B[1]=atom_y_frg[jat]; B[2]=atom_z_frg[jat];
	for ( i=0; i<3; i++ ) BA[i] = B[i] - A[i];

//#pragma omp for schedule(guided)
	for ( klcs=klcs0; klcs<klcs1; klcs++ ) {
	    val_cd = csp_schwarz_mon[klcs];
	    if ( val_ab*val_cd < eps_ps4 ) continue;
	    kcs    = csp_ics_mon[klcs];
	    lcs    = csp_jcs_mon[klcs];
	    if ( val_ab*val_cd*ofmo_twoint_dmax2(kcs,lcs) < eps_sch ) continue;
	    klps0  = csp_leading_ps_pair_mon[klcs];
	    nklps  = csp_leading_ps_pair_mon[klcs+1]-klps0;
	    kat    = shel_atm_mon[kcs];
	    lat    = shel_atm_mon[lcs];
	    kao0   = shel_ini_mon[kcs];
	    lao0   = shel_ini_mon[lcs];
	    C[0]=atom_x_mon[kat]; C[1]=atom_y_mon[kat]; C[2]=atom_z_mon[kat];
	    D[0]=atom_x_mon[lat]; D[1]=atom_y_mon[lat]; D[2]=atom_z_mon[lat];
	    for ( i=0; i<3; i++ ) {
		AC[i] = A[i] - C[i];
		DC[i] = D[i] - C[i];
	    }
	    ofmo_twoint_core_os_dddd( &La, &Lb, &Lc, &Ld,
		    &nijps, &psp_zeta_frg[ijps0], &psp_dkps_frg[ijps0],
		    &psp_xiza_frg[ijps0], BA,
		    &nklps, &psp_zeta_mon[klps0], &psp_dkps_mon[klps0],
		    &psp_xiza_mon[klps0], DC,   AC,      DDDD );
	    for ( i=0, iao=iao0, ix=0; i<6; i++, iao++ ) {
		I2 = (iao*iao+iao)>>1;
		for ( j=0, jao=jao0; j<6; j++, jao++ ) {
		    if ( jao>iao ) { ix+=6*6; continue; }
		    IJ = I2 + jao;
		    for ( k=0, kao=kao0; k<6; k++, kao++ ) {
			K2 = (kao*kao+kao)>>1;
			for ( l=0, lao=lao0; l<6; l++, lao++, ix++ ) {
			    if ( lao>kao ) continue;
			    coe = (kao==lao? ONE : TWO );
			    KL = K2 + lao;
			    if ( fabs(DDDD[ix]) > eps_eri ) {
				V_frg[IJ] += coe * D_mon[KL] * DDDD[ix];
			    }
			}
		    }
		}
	    }
	}	// klcs
    }		// ijcs
    return 0;
}	// end of ofmo_ifc4c_dddd_

#endif /* if 0 */

#undef NREGS_0
#undef NREGS_1
#undef NREGS_2
#undef NREGS_3
#undef NREGS_4

#undef CNV_CSP
